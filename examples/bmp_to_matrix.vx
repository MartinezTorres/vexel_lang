// Reads a 24-bit BMP at compile time and exports dimensions + RGB matrix.
// The matrix shape comes from BMP header fields, not hardcoded constants.

bmp:#s = ::assets::random_256x192.bmp;

&u16le(offset:#i32) -> #i32 {
  (#i32)bmp[offset] + ((#i32)bmp[offset + 1] * 256)
}

&u32le(offset:#i32) -> #i32 {
  (#i32)bmp[offset]
    + ((#i32)bmp[offset + 1] * 256)
    + ((#i32)bmp[offset + 2] * 65536)
    + ((#i32)bmp[offset + 3] * 16777216)
}

^bmp_data_offset:#i32 = u32le(10);
^bmp_width:#i32 = u32le(18);
^bmp_height:#i32 = u32le(22);
^bmp_bpp:#i32 = u16le(28);
^bmp_channels:#i32 = bmp_bpp / 8;
^bmp_row_stride:#i32 = ((bmp_width * bmp_channels + 3) / 4) * 4;

&pixel_offset(y:#i32, x:#i32) -> #i32 {
  row:#i32 = bmp_height - 1 - y;
  bmp_data_offset + row * bmp_row_stride + x * bmp_channels
}

&decode_bmp() -> #u8[bmp_height][bmp_width][3] {
  out:#u8[bmp_height][bmp_width][3];

  y:#i32 = 0;
  (y < bmp_height)@{
    x:#i32 = 0;
    (x < bmp_width)@{
      idx:#i32 = pixel_offset(y, x);
      out[y][x][0] = bmp[idx + 2];
      out[y][x][1] = bmp[idx + 1];
      out[y][x][2] = bmp[idx];
      x = x + 1;
    };
    y = y + 1;
  };

  out
}

^bmp_pixels:#u8[bmp_height][bmp_width][3] = decode_bmp();
