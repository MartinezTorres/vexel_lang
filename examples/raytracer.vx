// Vexel Raytracer - Demonstrates language capabilities within constraints
// - Stack-only memory (no heap)
// - Fixed-size arrays for scene objects
// - Compile-time math where possible
// - Value semantics throughout
// - PPM output via external putchar

// External I/O function
&!putchar(c:#i32) -> #i32;

// ============================================================================
// 3D Vector Math
// ============================================================================

#Vec3(x:#f64, y:#f64, z:#f64);

&(v)#Vec3::dot(o:#Vec3) -> #f64 {
    -> v.x * o.x + v.y * o.y + v.z * o.z;
}

&(v)#Vec3::length_sq() -> #f64 {
    -> v.dot(v);
}

&(v)#Vec3::length() -> #f64 {
    -> sqrt(v.length_sq());
}

&(v)#Vec3::normalize() -> #Vec3 {
    len = v.length();
    -> Vec3(v.x / len, v.y / len, v.z / len);
}

&(v)#Vec3::add(o:#Vec3) -> #Vec3 {
    -> Vec3(v.x + o.x, v.y + o.y, v.z + o.z);
}

&(v)#Vec3::sub(o:#Vec3) -> #Vec3 {
    -> Vec3(v.x - o.x, v.y - o.y, v.z - o.z);
}

&(v)#Vec3::mul(s:#f64) -> #Vec3 {
    -> Vec3(v.x * s, v.y * s, v.z * s);
}

&(v)#Vec3::reflect(n:#Vec3) -> #Vec3 {
    // r = v - 2 * dot(v, n) * n
    d = v.dot(n);
    -> v.sub(n.mul(2.0 * d));
}

// Component-wise multiply for colors
&(v)#Vec3::cmul(o:#Vec3) -> #Vec3 {
    -> Vec3(v.x * o.x, v.y * o.y, v.z * o.z);
}

// ============================================================================
// Ray
// ============================================================================

#Ray(origin:#Vec3, direction:#Vec3);

&(r)#Ray::point_at(t:#f64) -> #Vec3 {
    -> r.origin.add(r.direction.mul(t));
}

// ============================================================================
// Sphere
// ============================================================================

#Sphere(
    center:#Vec3,
    radius:#f64,
    color:#Vec3,
    specular:#f64,
    reflective:#f64
);

// Ray-sphere intersection
// Returns hit distance (negative if no hit)
&(s)#Sphere::intersect(r:#Ray) -> #f64 {
    oc = r.origin.sub(s.center);
    a = r.direction.dot(r.direction);
    b = 2.0 * oc.dot(r.direction);
    c = oc.dot(oc) - s.radius * s.radius;
    discriminant = b * b - 4.0 * a * c;

    discriminant < 0.0 ? {
        -> -1.0;
    };

    sqrt_d = sqrt(discriminant);
    t1 = (-b - sqrt_d) / (2.0 * a);
    t2 = (-b + sqrt_d) / (2.0 * a);

    // Return closest positive hit
    t1 > 0.001 ? {
        -> t1;
    };

    t2 > 0.001 ? {
        -> t2;
    };

    -> -1.0;
}

// ============================================================================
// Light
// ============================================================================

#Light(position:#Vec3, intensity:#f64);

// ============================================================================
// Math Utilities
// ============================================================================

&sqrt(x:#f64) -> #f64 {
    // Newton-Raphson method
    x <= 0.0 ? {
        -> 0.0;
    };

    guess:#f64 = x;
    i:#u8 = 0;

    (i < 10)@{
        guess = (guess + x / guess) * 0.5;
        i = i + 1;
    };

    -> guess;
}

&min(a:#f64, b:#f64) -> #f64 {
    -> a < b ? a : b;
}

&max(a:#f64, b:#f64) -> #f64 {
    -> a > b ? a : b;
}

&clamp(x:#f64, lo:#f64, hi:#f64) -> #f64 {
    -> min(max(x, lo), hi);
}

// ============================================================================
// Scene Definition
// ============================================================================

// Fixed-size arrays demonstrate stack-only constraint
// Scene has 5 spheres and 2 lights

&make_spheres() -> #Sphere[5] {
    -> [
        // Large sphere - floor
        Sphere(
            Vec3(0.0, -5001.0, 0.0),
            5000.0,
            Vec3(0.5, 0.5, 0.5),
            10.0,
            0.2
        ),
        // Red sphere
        Sphere(
            Vec3(-2.0, 0.0, -5.0),
            1.0,
            Vec3(0.9, 0.2, 0.2),
            500.0,
            0.3
        ),
        // Green sphere
        Sphere(
            Vec3(0.0, 0.0, -4.0),
            1.0,
            Vec3(0.2, 0.9, 0.2),
            100.0,
            0.4
        ),
        // Blue sphere
        Sphere(
            Vec3(2.0, 0.0, -5.0),
            1.0,
            Vec3(0.2, 0.2, 0.9),
            500.0,
            0.3
        ),
        // Yellow sphere (small, elevated)
        Sphere(
            Vec3(0.0, 1.5, -4.5),
            0.5,
            Vec3(0.9, 0.9, 0.2),
            200.0,
            0.5
        )
    ];
}

&make_lights() -> #Light[2] {
    -> [
        Light(Vec3(3.0, 5.0, -2.0), 0.6),
        Light(Vec3(-3.0, 5.0, -3.0), 0.4)
    ];
}

// ============================================================================
// Hit Record
// ============================================================================

#HitRecord(
    hit:#b,
    t:#f64,
    point:#Vec3,
    normal:#Vec3,
    sphere_idx:#u8
);

// ============================================================================
// Scene Intersection
// ============================================================================

&trace_scene(r:#Ray, spheres:#Sphere[5], min_t:#f64, max_t:#f64) -> #HitRecord {
    closest_t:#f64 = max_t;
    hit:#b = 0;
    hit_idx:#u8 = 0;

    i:#u8 = 0;
    (i < (#u8)5)@{
        t = spheres[i].intersect(r);
        (t > min_t) && (t < closest_t) ? {
            closest_t = t;
            hit = 1;
            hit_idx = i;
        };
        i = i + (#u8)1;
    };

    hit ? {
        hit_point:#Vec3;
        hit_point.x = r.origin.x + r.direction.x * closest_t;
        hit_point.y = r.origin.y + r.direction.y * closest_t;
        hit_point.z = r.origin.z + r.direction.z * closest_t;
        hit_sphere:#Sphere = spheres[hit_idx];

        nx:#f64 = hit_point.x - hit_sphere.center.x;
        ny:#f64 = hit_point.y - hit_sphere.center.y;
        nz:#f64 = hit_point.z - hit_sphere.center.z;
        nlen:#f64 = sqrt(nx * nx + ny * ny + nz * nz);
        normal:#Vec3;
        normal.x = nx / nlen;
        normal.y = ny / nlen;
        normal.z = nz / nlen;

        -> HitRecord(1, closest_t, hit_point, normal, hit_idx);
    };

    -> HitRecord(0, -1.0, Vec3(0.0, 0.0, 0.0), Vec3(0.0, 0.0, 0.0), 0);
}

// ============================================================================
// Lighting Calculation
// ============================================================================

&compute_lighting(
    point:#Vec3,
    normal:#Vec3,
    view:#Vec3,
    specular:#f64,
    spheres:#Sphere[5],
    lights:#Light[2]
) -> #f64 {
    intensity:#f64 = 0.1; // Ambient light

    // Iterate through lights
    li:#u8 = 0;
    (li < 2)@{
        light = lights[li];

        // Shadow ray
        light_dir = light.position.sub(point);
        light_distance = light_dir.length();
        light_dir = light_dir.normalize();

        shadow_ray = Ray(point, light_dir);
        shadow_hit = trace_scene(shadow_ray, spheres, 0.001, light_distance);

        // Only add lighting if not in shadow
        shadow_hit.hit ? {
            0
        } : {
            // Diffuse
            n_dot_l = normal.dot(light_dir);
            n_dot_l > 0.0 ? {
                intensity = intensity + light.intensity * n_dot_l;
            };

            // Specular
            specular > 0.0 ? {
                reflect_dir = light_dir.mul(-1.0).reflect(normal);
                r_dot_v = reflect_dir.dot(view);
                r_dot_v > 0.0 ? {
                    spec_factor = pow(r_dot_v, specular);
                    intensity = intensity + light.intensity * spec_factor;
                };
            };
            0
        };

        li = li + 1;
    };

    -> intensity;
}

// Power function for specular highlights
&pow(base:#f64, exp:#f64) -> #f64 {
    // Simple iterative power for positive integer exponents
    // For specular calculations, exp is large but we approximate
    exp < 1.0 ? {
        -> 1.0;
    };

    result:#f64 = 1.0;
    i:#u32 = 0;
    exp_int = (#u32)exp;

    ((i < exp_int) && (i < (#u32)1000))@{
        result = result * base;
        i = i + (#u32)1;
    };

    -> result;
}

// ============================================================================
// Ray Tracing with Reflections
// ============================================================================

&trace_ray(
    r:#Ray,
    spheres:#Sphere[5],
    lights:#Light[2],
    depth:#u8
) -> #Vec3 {
    depth == 0 ? {
        -> Vec3(0.0, 0.0, 0.0);
    };

    hit = trace_scene(r, spheres, 0.001, 1000.0);

    hit.hit ? {
        sphere = spheres[hit.sphere_idx];

        // Compute local color
        view = r.direction.mul(-1.0);
        light_intensity = compute_lighting(
            hit.point,
            hit.normal,
            view,
            sphere.specular,
            spheres,
            lights
        );

        local_color = sphere.color.mul(light_intensity);

        // Compute reflection
        reflective = sphere.reflective;
        reflective <= 0.0 || depth <= 1 ? {
            -> local_color;
        };

        reflect_dir = r.direction.mul(-1.0).reflect(hit.normal);
        reflect_ray = Ray(hit.point, reflect_dir);
        reflected_color = trace_ray(reflect_ray, spheres, lights, depth - 1);

        // Blend local and reflected color
        local_weight = 1.0 - reflective;
        final_color = local_color.mul(local_weight).add(reflected_color.mul(reflective));

        -> final_color;
    };

    // Sky gradient background
    t = 0.5 * (r.direction.y + 1.0);
    sky_color = Vec3(0.5, 0.7, 1.0).mul(t).add(Vec3(1.0, 1.0, 1.0).mul(1.0 - t));
    -> sky_color;
}

// ============================================================================
// Camera & Image Generation
// ============================================================================

// Image dimensions - compile-time constants
WIDTH = 320;
HEIGHT = 240;
ASPECT_RATIO = (#f64)WIDTH / (#f64)HEIGHT;

// Camera setup
VIEWPORT_HEIGHT = 2.0;
VIEWPORT_WIDTH = VIEWPORT_HEIGHT * ASPECT_RATIO;
FOCAL_LENGTH = 1.0;

CAMERA_ORIGIN = Vec3(0.0, 1.0, 0.0);
VIEWPORT_U = Vec3(VIEWPORT_WIDTH, 0.0, 0.0);
VIEWPORT_V = Vec3(0.0, -VIEWPORT_HEIGHT, 0.0);
VIEWPORT_LOWER_LEFT = CAMERA_ORIGIN
    .sub(VIEWPORT_U.mul(0.5))
    .sub(VIEWPORT_V.mul(0.5))
    .sub(Vec3(0.0, 0.0, FOCAL_LENGTH));

// ============================================================================
// PPM Output Functions
// ============================================================================

&print_char(c:#u8) {
    putchar((#i32)c);
}

&print_num(n:#u32) {
    n >= (#u32)10 ? {
        print_num(n / (#u32)10);
    };
    print_char((#u8)((#i32)48 + (#i32)(n % (#u32)10)));
}

&print_str(s:#s) {
    i:#u32 = 0;
    (i < (#u32)|s|)@{
        print_char(s[i]);
        i = i + (#u32)1;
    };
}

&print_newline() {
    print_char((#u8)10);
}

&print_space() {
    print_char((#u8)32);
}

// ============================================================================
// Main Render Function
// ============================================================================

&^main() -> #i32 {
    // Initialize scene
    spheres = make_spheres();
    lights = make_lights();

    // PPM header
    print_str("P3");
    print_newline();
    print_num((#u32)WIDTH);
    print_space();
    print_num((#u32)HEIGHT);
    print_newline();
    print_str("255");
    print_newline();

    // Render loop
    y:#u32 = 0;
    (y < (#u32)HEIGHT)@{
        x:#u32 = 0;
        (x < (#u32)WIDTH)@{
            // Calculate ray direction
            u = (#f64)x / (#f64)(WIDTH - (#i32)1);
            v = (#f64)y / (#f64)(HEIGHT - (#i32)1);

            pixel_pos = VIEWPORT_LOWER_LEFT
                .add(VIEWPORT_U.mul(u))
                .add(VIEWPORT_V.mul(v));

            ray_dir = pixel_pos.sub(CAMERA_ORIGIN).normalize();
            ray = Ray(CAMERA_ORIGIN, ray_dir);

            // Trace ray with reflections (max depth 3)
            color = trace_ray(ray, spheres, lights, (#u8)3);

            // Clamp and convert to RGB
            r = (#u32)(clamp(color.x, 0.0, 1.0) * 255.0);
            g = (#u32)(clamp(color.y, 0.0, 1.0) * 255.0);
            b = (#u32)(clamp(color.z, 0.0, 1.0) * 255.0);

            print_num(r);
            print_space();
            print_num(g);
            print_space();
            print_num(b);
            print_space();

            x = x + (#u32)1;
        };
        print_newline();
        y = y + (#u32)1;
    };

    -> 0;
}
