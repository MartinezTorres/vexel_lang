#!/usr/bin/env python3
"""Generate a deterministic 256x192 BMP and matching Vexel matrix example."""

from __future__ import annotations

import pathlib
import random
import struct


WIDTH = 256
HEIGHT = 192
SEED = 20260217


def build_bmp_bytes() -> bytes:
    row_stride = (WIDTH * 3 + 3) & ~3
    pixel_bytes = row_stride * HEIGHT
    pixel_offset = 54
    file_size = pixel_offset + pixel_bytes

    header = bytearray()
    header += b"BM"
    header += struct.pack("<I", file_size)
    header += b"\x00\x00\x00\x00"
    header += struct.pack("<I", pixel_offset)
    header += struct.pack("<I", 40)  # BITMAPINFOHEADER
    header += struct.pack("<i", WIDTH)
    header += struct.pack("<i", HEIGHT)  # positive => bottom-up rows
    header += struct.pack("<H", 1)  # planes
    header += struct.pack("<H", 24)  # bpp
    header += struct.pack("<I", 0)  # BI_RGB
    header += struct.pack("<I", pixel_bytes)
    header += struct.pack("<i", 2835)  # x ppm
    header += struct.pack("<i", 2835)  # y ppm
    header += struct.pack("<I", 0)  # palette colors
    header += struct.pack("<I", 0)  # important colors

    rng = random.Random(SEED)
    pixels = bytearray(pixel_bytes)
    for y in range(HEIGHT):
        row_start = y * row_stride
        for x in range(WIDTH):
            i = row_start + x * 3
            b = rng.randrange(256)
            g = rng.randrange(256)
            r = rng.randrange(256)
            pixels[i : i + 3] = bytes((b, g, r))

    return bytes(header + pixels)


def build_vexel_source() -> str:
    lines = [
        "// Auto-generated by examples/tools/generate_bmp_to_matrix_example.py",
        "// Reads a 24-bit BMP at compile time and exports dimensions + RGB matrix.",
        "",
        "bmp:#s = ::assets::random_256x192.bmp;",
        "",
        "&u16le(offset:#i32) -> #i32 {",
        "  (#i32)bmp[offset] + ((#i32)bmp[offset + 1] * 256)",
        "}",
        "",
        "&u32le(offset:#i32) -> #i32 {",
        "  (#i32)bmp[offset]",
        "    + ((#i32)bmp[offset + 1] * 256)",
        "    + ((#i32)bmp[offset + 2] * 65536)",
        "    + ((#i32)bmp[offset + 3] * 16777216)",
        "}",
        "",
        "^bmp_width:#i32 = u32le(18);",
        "^bmp_height:#i32 = u32le(22);",
        "^bmp_bpp:#i32 = u16le(28);",
        "^bmp_channels:#i32 = 3;",
        "^bmp_data_offset:#i32 = u32le(10);",
        "^bmp_row_stride:#i32 = ((bmp_width * 3 + 3) / 4) * 4;",
        "",
        "&pixel_offset(y:#i32, x:#i32) -> #i32 {",
        "  row:#i32 = bmp_height - 1 - y;",
        "  bmp_data_offset + row * bmp_row_stride + x * 3",
        "}",
        "",
        "&rgb(y:#i32, x:#i32) -> #u8[3] {",
        "  idx:#i32 = pixel_offset(y, x);",
        "  [bmp[idx + 2], bmp[idx + 1], bmp[idx]]",
        "}",
        "",
        "^bmp_pixels = [",
    ]

    for y in range(HEIGHT):
        row = ", ".join(f"rgb({y}, {x})" for x in range(WIDTH))
        suffix = "," if y + 1 < HEIGHT else ""
        lines.append(f"  [{row}]{suffix}")

    lines.extend(
        [
            "];",
            "",
            "&^main() -> #i32 {",
            "  0",
            "}",
            "",
        ]
    )
    return "\n".join(lines)


def main() -> None:
    repo_root = pathlib.Path(__file__).resolve().parents[2]
    bmp_path = repo_root / "examples" / "assets" / "random_256x192.bmp"
    vexel_path = repo_root / "examples" / "bmp_to_matrix.vx"

    bmp_path.parent.mkdir(parents=True, exist_ok=True)
    bmp_path.write_bytes(build_bmp_bytes())
    vexel_path.write_text(build_vexel_source(), encoding="utf-8")

    print(f"wrote {bmp_path}")
    print(f"wrote {vexel_path}")


if __name__ == "__main__":
    main()
