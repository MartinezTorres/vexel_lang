#include "codegen.h"
#include "evaluator.h"
#include "typechecker.h"
#include "constants.h"
#include <algorithm>
#include <functional>
#include <iomanip>
#include <cctype>
#include <tuple>
#include <sstream>
#include <deque>

namespace {
std::string escape_c_string(const std::string& input) {
    std::ostringstream oss;
    oss << std::hex << std::setfill('0');
    for (unsigned char c : input) {
        switch (c) {
            case '\\':
                oss << "\\\\";
                break;
            case '"':
                oss << "\\\"";
                break;
            case '\n':
                oss << "\\n";
                break;
            case '\r':
                oss << "\\r";
                break;
            case '\t':
                oss << "\\t";
                break;
            default:
                if (c >= 0x20 && c <= 0x7e) {
                    oss << static_cast<char>(c);
                } else {
                    oss << "\\x" << std::uppercase << std::setw(2) << static_cast<int>(c) << std::nouppercase;
                }
                break;
        }
    }
    return oss.str();
}

std::string sanitize_identifier(const std::string& input) {
    std::string result;
    result.reserve(input.size());
    for (unsigned char c : input) {
        if (std::isalnum(c)) {
            result.push_back(static_cast<char>(c));
        } else {
            result.push_back('_');
        }
    }
    if (result.empty() || std::isdigit(static_cast<unsigned char>(result.front()))) {
        result.insert(result.begin(), '_');
    }
    return result;
}

constexpr char kScopeSep = '\x1F';
}

namespace vexel {

static std::string render_annotation_comment(const std::vector<Annotation>& anns) {
    if (anns.empty()) return "";
    std::ostringstream os;
    os << "// Annotations:";
    for (const auto& ann : anns) {
        os << " [[" << ann.name;
        if (!ann.args.empty()) {
            os << "(";
            for (size_t i = 0; i < ann.args.size(); ++i) {
                if (i > 0) os << ", ";
                os << ann.args[i];
            }
            os << ")";
        }
        os << "]]";
    }
    return os.str();
}

CodeGenerator::CodeGenerator() : temp_counter(0), type_checker(nullptr), in_function(false) {
    output_stack.push(&body);
}

CCodegenResult CodeGenerator::generate(const Module& mod, TypeChecker* tc) {
    type_checker = tc;

    header.str("");
    header.clear();
    body.str("");
    body.clear();
    generated_functions.clear();
    generated_vars.clear();
    reachable_functions.clear();
    current_ref_params.clear();
    function_writes_global.clear();
    function_is_pure.clear();
    used_global_vars.clear();
    used_type_names.clear();
    reentrancy_variants.clear();
    current_reentrancy_key = 'N';
    tuple_types.clear();
    expr_param_substitutions.clear();
    value_param_replacements.clear();
    underscore_var.clear();
    if (tc) {
        for (const auto& pair : tc->get_forced_tuple_types()) {
            tuple_types[pair.first] = pair.second;
        }
    }
    comparator_cache.clear();
    comparator_definitions.clear();
    while (!output_stack.empty()) output_stack.pop();
    output_stack.push(&body);

    emit_header("// Generated by Vexel compiler");
    emit_header("// https://github.com/vexel-lang/vexel");
    emit_header("// Dead code elimination: only reachable functions and referenced globals/types are generated");
    emit_header("");
    emit_header("#pragma once");
    emit_header("");
    emit_header("#include <stdint.h>");
    emit_header("#include <stdbool.h>");
    emit_header("#include <string.h>");
    emit_header("#include <stdlib.h>");
    emit_header("#include <math.h>");
    emit_header("");
    emit_header("#ifndef VX_MUTABLE");
    emit_header("#define VX_MUTABLE");
    emit_header("#endif");
    emit_header("#ifndef VX_NON_MUTABLE");
    emit_header("#define VX_NON_MUTABLE const");
    emit_header("#endif");
    emit_header("#ifndef VX_CONSTEXPR");
    emit_header("#define VX_CONSTEXPR const");
    emit_header("#endif");
    emit_header("#ifndef VX_REENTRANT");
    emit_header("#define VX_REENTRANT");
    emit_header("#endif");
    emit_header("#ifndef VX_NON_REENTRANT");
    emit_header("#define VX_NON_REENTRANT");
    emit_header("#endif");
    emit_header("#ifndef VX_REF_MASK");
    emit_header("#define VX_REF_MASK(x)");
    emit_header("#endif");
    emit_header("#ifndef VX_INLINE");
    emit_header("#define VX_INLINE");
    emit_header("#endif");
    emit_header("#ifndef VX_NOINLINE");
    emit_header("#define VX_NOINLINE");
    emit_header("#endif");
    emit_header("#ifndef VX_PURE");
    emit_header("#define VX_PURE");
    emit_header("#endif");
    emit_header("#ifndef VX_NO_GLOBAL_WRITE");
    emit_header("#define VX_NO_GLOBAL_WRITE");
    emit_header("#endif");
    emit_header("#ifndef VX_ENTRYPOINT");
    emit_header("#define VX_ENTRYPOINT");
    emit_header("#endif");
    emit_header("");

    // Analyze reachability before generating code
    analyze_reachability(mod);
    analyze_reentrancy(mod);
    analyze_mutability(mod);
    analyze_ref_variants(mod);
    analyze_effects(mod);
    analyze_usage(mod);

    gen_module(mod);

    CCodegenResult result;
    result.header = header.str();
    if (comparator_definitions.empty()) {
        result.source = body.str();
    } else {
        std::ostringstream combined;
        for (const auto& helper : comparator_definitions) {
            combined << helper << "\n";
        }
        combined << body.str();
        result.source = combined.str();
    }
    return result;
}

void CodeGenerator::analyze_reachability(const Module& mod) {
    // Start from all exported functions
    for (const auto& stmt : mod.top_level) {
        if (stmt->kind == Stmt::Kind::FuncDecl && stmt->is_exported) {
            std::string func_name = stmt->func_name;
            if (!stmt->type_namespace.empty()) {
                func_name = stmt->type_namespace + "::" + stmt->func_name;
            }
            mark_reachable(func_name, stmt->scope_instance_id, mod);
        }
    }

    // Also mark any global variable initializers that reference functions
    // BUT only if they weren't compile-time evaluated
    for (const auto& stmt : mod.top_level) {
        if (stmt->kind == Stmt::Kind::VarDecl && stmt->var_init) {
            // Try to evaluate at compile time
            bool evaluated_at_compile_time = false;
            if (type_checker) {
                CompileTimeEvaluator evaluator(type_checker);
                CTValue result;
                if (evaluator.try_evaluate(stmt->var_init, result)) {
                    evaluated_at_compile_time = true;
                }
            }

            // Only mark functions as reachable if NOT compile-time evaluated
            if (!evaluated_at_compile_time) {
                std::unordered_set<std::string> calls;
                collect_calls(stmt->var_init, calls);
                for (const auto& func_key : calls) {
                    std::string func_name;
                    int scope_id = -1;
                    split_reachability_key(func_key, func_name, scope_id);
                    mark_reachable(func_name, scope_id, mod);
                }
            }
        }
    }
}

void CodeGenerator::analyze_reentrancy(const Module& mod) {
    reentrancy_variants.clear();

    auto has_ann = [](const std::vector<Annotation>& anns, const std::string& name) {
        return std::any_of(anns.begin(), anns.end(), [&](const Annotation& a) { return a.name == name; });
    };

    auto qualified_name = [](const StmtPtr& stmt) {
        if (!stmt->type_namespace.empty()) {
            return stmt->type_namespace + "::" + stmt->func_name;
        }
        return stmt->func_name;
    };

    std::unordered_map<std::string, StmtPtr> function_map;
    std::unordered_set<std::string> external_reentrant;
    std::unordered_set<std::string> external_nonreentrant;

    for (const auto& stmt : mod.top_level) {
        if (stmt->kind != Stmt::Kind::FuncDecl) continue;
        std::string func_name = qualified_name(stmt);
        std::string key = reachability_key(func_name, stmt->scope_instance_id);
        if (stmt->is_external) {
            bool is_reentrant = has_ann(stmt->annotations, "reentrant");
            bool is_nonreentrant = has_ann(stmt->annotations, "nonreentrant");
            if (is_reentrant && is_nonreentrant) {
                throw CompileError("Conflicting annotations: [[reentrant]] and [[nonreentrant]] on external function '" +
                                   stmt->func_name + "'", stmt->location);
            }
            if (is_reentrant) {
                external_reentrant.insert(key);
            } else {
                external_nonreentrant.insert(key);
            }
            continue;
        }
        if (!reachable_functions.count(key)) continue;
        function_map[key] = stmt;
    }

    std::deque<std::pair<std::string, char>> work;

    for (const auto& stmt : mod.top_level) {
        if (stmt->kind != Stmt::Kind::FuncDecl) continue;
        if (!stmt->is_exported) continue;
        std::string func_name = qualified_name(stmt);
        std::string key = reachability_key(func_name, stmt->scope_instance_id);
        if (!reachable_functions.count(key)) continue;

        bool is_reentrant = has_ann(stmt->annotations, "reentrant");
        bool is_nonreentrant = has_ann(stmt->annotations, "nonreentrant");
        if (is_reentrant && is_nonreentrant) {
            throw CompileError("Conflicting annotations: [[reentrant]] and [[nonreentrant]] on entry function '" +
                               stmt->func_name + "'", stmt->location);
        }

        char ctx = (is_reentrant ? 'R' : 'N');
        if (reentrancy_variants[key].insert(ctx).second) {
            work.emplace_back(key, ctx);
        }
    }

    // Seed runtime global initializers as non-reentrant paths.
    for (const auto& stmt : mod.top_level) {
        if (stmt->kind == Stmt::Kind::VarDecl && stmt->var_init) {
            bool evaluated_at_compile_time = false;
            if (type_checker) {
                CompileTimeEvaluator evaluator(type_checker);
                CTValue result;
                if (evaluator.try_evaluate(stmt->var_init, result)) {
                    evaluated_at_compile_time = true;
                }
            }
            if (evaluated_at_compile_time) continue;
            std::unordered_set<std::string> calls;
            collect_calls(stmt->var_init, calls);
            for (const auto& callee_key : calls) {
                if (function_map.count(callee_key) == 0) continue;
                if (reentrancy_variants[callee_key].insert('N').second) {
                    work.emplace_back(callee_key, 'N');
                }
            }
        }
    }

    while (!work.empty()) {
        auto [func_key, ctx] = work.front();
        work.pop_front();
        auto it = function_map.find(func_key);
        if (it == function_map.end()) continue;
        StmtPtr func = it->second;
        if (!func || !func->body) continue;

        std::unordered_set<std::string> calls;
        collect_calls(func->body, calls);
        for (const auto& callee_key : calls) {
            auto callee_it = function_map.find(callee_key);
            if (callee_it == function_map.end()) {
                if (ctx == 'R' && external_nonreentrant.count(callee_key)) {
                    std::string callee_name;
                    int callee_scope = -1;
                    split_reachability_key(callee_key, callee_name, callee_scope);
                    if (callee_scope >= 0) {
                        callee_name += " (scope " + std::to_string(callee_scope) + ")";
                    }
                    throw CompileError("Reentrant path calls non-reentrant external function '" + callee_name + "'",
                                       func->location);
                }
                continue;
            }
            if (reentrancy_variants[callee_key].insert(ctx).second) {
                work.emplace_back(callee_key, ctx);
            }
        }
    }

    for (const auto& entry : function_map) {
        const std::string& func_key = entry.first;
        if (reentrancy_variants[func_key].empty()) {
            reentrancy_variants[func_key].insert('N');
        }
    }
}

void CodeGenerator::analyze_mutability(const Module& mod) {
    var_mutability.clear();
    receiver_mutates.clear();
    std::unordered_map<std::string, StmtPtr> function_map;
    std::unordered_map<const Stmt*, StmtPtr> var_decl_map;
    std::unordered_map<const Stmt*, bool> var_written;

    auto qualified_name = [](const StmtPtr& stmt) {
        if (!stmt->type_namespace.empty()) {
            return stmt->type_namespace + "::" + stmt->func_name;
        }
        return stmt->func_name;
    };

    // Collect function declarations and top-level variables
    for (const auto& stmt : mod.top_level) {
        if (stmt->kind == Stmt::Kind::FuncDecl) {
            function_map[qualified_name(stmt)] = stmt;
            if (!stmt->ref_params.empty()) {
                std::vector<bool> mut(stmt->ref_params.size(), false);
                if (stmt->is_external || !stmt->body) {
                    std::fill(mut.begin(), mut.end(), true);
                }
                receiver_mutates[qualified_name(stmt)] = mut;
            }
        } else if (stmt->kind == Stmt::Kind::VarDecl) {
            var_decl_map[stmt.get()] = stmt;
            var_written[stmt.get()] = false;
        }
    }

    auto base_identifier = [](ExprPtr expr) -> std::string {
        while (expr) {
            if (expr->kind == Expr::Kind::Identifier) {
                return expr->name;
            }
            if (expr->kind == Expr::Kind::Member || expr->kind == Expr::Kind::Index) {
                expr = expr->operand;
                continue;
            }
            break;
        }
        return "";
    };

    // Determine which receivers are mutated by each function (fixpoint).
    bool changed = true;
    while (changed) {
        changed = false;
        for (const auto& entry : function_map) {
            const std::string& func_name = entry.first;
            const StmtPtr& func = entry.second;
            if (func->is_external || !func->body || func->ref_params.empty()) continue;

            std::vector<bool> updated = receiver_mutates[func_name];
            std::unordered_map<std::string, size_t> receiver_index;
            receiver_index.reserve(func->ref_params.size());
            for (size_t i = 0; i < func->ref_params.size(); i++) {
                receiver_index[func->ref_params[i]] = i;
            }

            std::function<void(ExprPtr)> visit_expr;
            std::function<void(StmtPtr)> visit_stmt;

            visit_expr = [&](ExprPtr expr) {
                if (!expr) return;
                switch (expr->kind) {
                    case Expr::Kind::Assignment: {
                        std::string base = base_identifier(expr->left);
                        auto it = receiver_index.find(base);
                        if (it != receiver_index.end()) {
                            updated[it->second] = true;
                        }
                        visit_expr(expr->right);
                        break;
                    }
                    case Expr::Kind::Call: {
                        // Propagate receiver mutations from callees.
                        if (!expr->receivers.empty()) {
                            std::string callee;
                            if (expr->operand && expr->operand->kind == Expr::Kind::Identifier) {
                                callee = expr->operand->name;
                            }
                            auto callee_it = receiver_mutates.find(callee);
                            for (size_t i = 0; i < expr->receivers.size(); i++) {
                                ExprPtr rec_expr = expr->receivers[i];
                                std::string rec_name = base_identifier(rec_expr);
                                if (rec_name.empty()) continue;
                                auto rec_it = receiver_index.find(rec_name);
                                if (rec_it == receiver_index.end()) continue;
                                bool mut = true; // default to conservative if unknown
                                if (callee_it != receiver_mutates.end() && i < callee_it->second.size()) {
                                    mut = callee_it->second[i];
                                }
                                if (mut) {
                                    updated[rec_it->second] = true;
                                }
                            }
                        }
                        for (const auto& rec : expr->receivers) {
                            visit_expr(rec);
                        }
                        for (const auto& arg : expr->args) {
                            visit_expr(arg);
                        }
                        visit_expr(expr->operand);
                        break;
                    }
                    case Expr::Kind::Binary:
                        visit_expr(expr->left);
                        visit_expr(expr->right);
                        break;
                    case Expr::Kind::Unary:
                    case Expr::Kind::Cast:
                    case Expr::Kind::Length:
                        visit_expr(expr->operand);
                        break;
                    case Expr::Kind::Index:
                        visit_expr(expr->operand);
                        if (!expr->args.empty()) visit_expr(expr->args[0]);
                        break;
                    case Expr::Kind::Member:
                        visit_expr(expr->operand);
                        break;
                    case Expr::Kind::ArrayLiteral:
                    case Expr::Kind::TupleLiteral:
                        for (const auto& elem : expr->elements) visit_expr(elem);
                        break;
                    case Expr::Kind::Block:
                        for (const auto& stmt : expr->statements) visit_stmt(stmt);
                        visit_expr(expr->result_expr);
                        break;
                    case Expr::Kind::Conditional:
                        visit_expr(expr->condition);
                        visit_expr(expr->true_expr);
                        visit_expr(expr->false_expr);
                        break;
                    case Expr::Kind::Range:
                    case Expr::Kind::Iteration:
                    case Expr::Kind::Repeat:
                        visit_expr(expr->left);
                        visit_expr(expr->right);
                        break;
                    default:
                        break;
                }
            };

            visit_stmt = [&](StmtPtr stmt) {
                if (!stmt) return;
                switch (stmt->kind) {
                    case Stmt::Kind::Expr:
                        visit_expr(stmt->expr);
                        break;
                    case Stmt::Kind::Return:
                        visit_expr(stmt->return_expr);
                        break;
                    case Stmt::Kind::VarDecl:
                        visit_expr(stmt->var_init);
                        break;
                    case Stmt::Kind::ConditionalStmt:
                        visit_expr(stmt->condition);
                        visit_stmt(stmt->true_stmt);
                        break;
                    default:
                        break;
                }
            };

            visit_expr(func->body);

            if (updated != receiver_mutates[func_name]) {
                receiver_mutates[func_name] = updated;
                changed = true;
            }
        }
    }

    struct ScopeFrame {
        std::unordered_map<std::string, const Stmt*> vars;
    };
    std::vector<ScopeFrame> scopes;
    scopes.emplace_back();

    auto resolve_var = [&](const std::string& name) -> const Stmt* {
        for (auto it = scopes.rbegin(); it != scopes.rend(); ++it) {
            auto found = it->vars.find(name);
            if (found != it->vars.end()) {
                return found->second;
            }
        }
        return nullptr;
    };

    auto mark_written = [&](const std::string& name) {
        const Stmt* decl = resolve_var(name);
        if (decl) {
            var_written[decl] = true;
        }
    };

    std::function<void(ExprPtr)> visit_expr;
    std::function<void(StmtPtr)> visit_stmt;

    visit_expr = [&](ExprPtr expr) {
        if (!expr) return;
        switch (expr->kind) {
            case Expr::Kind::Assignment: {
                std::string base = base_identifier(expr->left);
                if (!base.empty()) {
                    mark_written(base);
                }
                visit_expr(expr->right);
                break;
            }
            case Expr::Kind::Call: {
                if (!expr->receivers.empty()) {
                    std::string callee;
                    if (expr->operand && expr->operand->kind == Expr::Kind::Identifier) {
                        callee = expr->operand->name;
                    }
                    auto callee_it = receiver_mutates.find(callee);
                    for (size_t i = 0; i < expr->receivers.size(); i++) {
                        bool mut = true;
                        if (callee_it != receiver_mutates.end() && i < callee_it->second.size()) {
                            mut = callee_it->second[i];
                        }
                        if (!mut) continue;
                        ExprPtr rec_expr = expr->receivers[i];
                        if (!rec_expr) continue;
                        if (!is_addressable_lvalue(rec_expr) || !is_mutable_lvalue(rec_expr)) {
                            continue;
                        }
                        std::string base = base_identifier(rec_expr);
                        if (!base.empty()) {
                            mark_written(base);
                        }
                    }
                }
                for (const auto& rec : expr->receivers) {
                    visit_expr(rec);
                }
                for (const auto& arg : expr->args) visit_expr(arg);
                visit_expr(expr->operand);
                break;
            }
            case Expr::Kind::Binary:
                visit_expr(expr->left);
                visit_expr(expr->right);
                break;
            case Expr::Kind::Unary:
            case Expr::Kind::Cast:
            case Expr::Kind::Length:
                visit_expr(expr->operand);
                break;
            case Expr::Kind::Index:
                visit_expr(expr->operand);
                if (!expr->args.empty()) visit_expr(expr->args[0]);
                break;
            case Expr::Kind::Member:
                visit_expr(expr->operand);
                break;
            case Expr::Kind::ArrayLiteral:
            case Expr::Kind::TupleLiteral:
                for (const auto& elem : expr->elements) visit_expr(elem);
                break;
            case Expr::Kind::Block:
                scopes.emplace_back();
                for (const auto& stmt : expr->statements) visit_stmt(stmt);
                visit_expr(expr->result_expr);
                scopes.pop_back();
                break;
            case Expr::Kind::Conditional:
                visit_expr(expr->condition);
                visit_expr(expr->true_expr);
                visit_expr(expr->false_expr);
                break;
            case Expr::Kind::Range:
            case Expr::Kind::Iteration:
            case Expr::Kind::Repeat:
                visit_expr(expr->left);
                visit_expr(expr->right);
                break;
            default:
                break;
        }
    };

    visit_stmt = [&](StmtPtr stmt) {
        if (!stmt) return;
        switch (stmt->kind) {
            case Stmt::Kind::VarDecl:
                scopes.back().vars[stmt->var_name] = stmt.get();
                var_decl_map[stmt.get()] = stmt;
                var_written.emplace(stmt.get(), false);
                visit_expr(stmt->var_init);
                break;
            case Stmt::Kind::Expr:
                visit_expr(stmt->expr);
                break;
            case Stmt::Kind::Return:
                visit_expr(stmt->return_expr);
                break;
            case Stmt::Kind::ConditionalStmt:
                visit_expr(stmt->condition);
                visit_stmt(stmt->true_stmt);
                break;
            default:
                break;
        }
    };

    // Analyze functions and top-level expressions for variable writes.
    for (const auto& stmt : mod.top_level) {
        if (stmt->kind == Stmt::Kind::FuncDecl && stmt->body) {
            scopes.emplace_back();
            // Shadow parameters and receiver params to avoid mutating globals with the same name.
            for (const auto& param : stmt->params) {
                scopes.back().vars[param.name] = nullptr;
            }
            for (const auto& ref : stmt->ref_params) {
                scopes.back().vars[ref] = nullptr;
            }
            visit_expr(stmt->body);
            scopes.pop_back();
        } else if (stmt->kind == Stmt::Kind::Expr) {
            visit_expr(stmt->expr);
        }
    }

    // Classify variables.
    for (const auto& entry : var_decl_map) {
        const Stmt* key = entry.first;
        StmtPtr decl = entry.second;
        bool written = var_written[key];
        bool effective_mutable = decl->is_mutable && written;
        if (effective_mutable) {
            var_mutability[key] = VarMutability::Mutable;
        } else if (is_compile_time_init(decl)) {
            var_mutability[key] = VarMutability::Constexpr;
        } else {
            var_mutability[key] = VarMutability::NonMutableRuntime;
        }
    }
}

void CodeGenerator::analyze_ref_variants(const Module& mod) {
    ref_variants.clear();
    std::unordered_map<std::string, StmtPtr> function_map;

    auto qualified_name = [](const StmtPtr& stmt) {
        if (!stmt->type_namespace.empty()) {
            return stmt->type_namespace + "::" + stmt->func_name;
        }
        return stmt->func_name;
    };

    for (const auto& stmt : mod.top_level) {
        if (stmt->kind == Stmt::Kind::FuncDecl) {
            function_map[qualified_name(stmt)] = stmt;
        }
    }

    auto record_call = [&](ExprPtr expr) {
        if (!expr || expr->kind != Expr::Kind::Call) return;
        if (!expr->operand || expr->operand->kind != Expr::Kind::Identifier) return;
        const std::string& func_name = expr->operand->name;
        auto fit = function_map.find(func_name);
        if (fit == function_map.end()) return;
        size_t ref_count = fit->second->ref_params.size();
        if (ref_count == 0) return;
        std::string key = ref_variant_key(expr, ref_count);
        ref_variants[func_name].insert(key);
    };

    std::function<void(ExprPtr)> visit_expr;
    std::function<void(StmtPtr)> visit_stmt;

    visit_expr = [&](ExprPtr expr) {
        if (!expr) return;
        switch (expr->kind) {
            case Expr::Kind::Call:
                record_call(expr);
                for (const auto& rec : expr->receivers) visit_expr(rec);
                for (const auto& arg : expr->args) visit_expr(arg);
                visit_expr(expr->operand);
                break;
            case Expr::Kind::Binary:
                visit_expr(expr->left);
                visit_expr(expr->right);
                break;
            case Expr::Kind::Unary:
            case Expr::Kind::Cast:
            case Expr::Kind::Length:
                visit_expr(expr->operand);
                break;
            case Expr::Kind::Index:
                visit_expr(expr->operand);
                if (!expr->args.empty()) visit_expr(expr->args[0]);
                break;
            case Expr::Kind::Member:
                visit_expr(expr->operand);
                break;
            case Expr::Kind::ArrayLiteral:
            case Expr::Kind::TupleLiteral:
                for (const auto& elem : expr->elements) visit_expr(elem);
                break;
            case Expr::Kind::Block:
                for (const auto& stmt : expr->statements) visit_stmt(stmt);
                visit_expr(expr->result_expr);
                break;
            case Expr::Kind::Conditional:
                visit_expr(expr->condition);
                visit_expr(expr->true_expr);
                visit_expr(expr->false_expr);
                break;
            case Expr::Kind::Range:
            case Expr::Kind::Iteration:
            case Expr::Kind::Repeat:
                visit_expr(expr->left);
                visit_expr(expr->right);
                break;
            case Expr::Kind::Assignment:
                visit_expr(expr->left);
                visit_expr(expr->right);
                break;
            default:
                break;
        }
    };

    visit_stmt = [&](StmtPtr stmt) {
        if (!stmt) return;
        switch (stmt->kind) {
            case Stmt::Kind::Expr:
                visit_expr(stmt->expr);
                break;
            case Stmt::Kind::Return:
                visit_expr(stmt->return_expr);
                break;
            case Stmt::Kind::VarDecl:
                visit_expr(stmt->var_init);
                break;
            case Stmt::Kind::ConditionalStmt:
                visit_expr(stmt->condition);
                visit_stmt(stmt->true_stmt);
                break;
            default:
                break;
        }
    };

    for (const auto& stmt : mod.top_level) {
        if (stmt->kind == Stmt::Kind::FuncDecl) {
            std::string func_name = qualified_name(stmt);
            std::string key = reachability_key(func_name, stmt->scope_instance_id);
            if (!reachable_functions.count(key)) {
                continue;
            }
            if (stmt->body) visit_expr(stmt->body);
        } else if (stmt->kind == Stmt::Kind::VarDecl && stmt->var_init) {
            bool evaluated_at_compile_time = false;
            if (type_checker) {
                CompileTimeEvaluator evaluator(type_checker);
                CTValue result;
                if (evaluator.try_evaluate(stmt->var_init, result)) {
                    evaluated_at_compile_time = true;
                }
            }
            if (!evaluated_at_compile_time) {
                visit_expr(stmt->var_init);
            }
        }
    }
}

void CodeGenerator::analyze_effects(const Module& mod) {
    function_writes_global.clear();
    function_is_pure.clear();

    std::unordered_map<std::string, StmtPtr> function_map;
    std::unordered_map<std::string, std::unordered_set<std::string>> function_calls;
    std::unordered_map<std::string, bool> function_direct_writes_global;
    std::unordered_map<std::string, bool> function_direct_impure;
    std::unordered_map<std::string, bool> function_unknown_call;
    std::unordered_map<std::string, bool> function_mutates_receiver;
    std::unordered_set<std::string> external_functions;

    auto qualified_name = [](const StmtPtr& stmt) {
        if (!stmt->type_namespace.empty()) {
            return stmt->type_namespace + "::" + stmt->func_name;
        }
        return stmt->func_name;
    };

    for (const auto& stmt : mod.top_level) {
        if (stmt->kind != Stmt::Kind::FuncDecl) continue;
        std::string func_name = qualified_name(stmt);
        std::string func_key = reachability_key(func_name, stmt->scope_instance_id);
        if (stmt->is_external) {
            external_functions.insert(func_key);
            continue;
        }
        if (!reachable_functions.count(func_key)) {
            continue;
        }
        function_map[func_key] = stmt;
        function_calls[func_key] = {};
        function_direct_writes_global[func_key] = false;
        function_direct_impure[func_key] = false;
        function_unknown_call[func_key] = false;

        bool mutates = false;
        auto mut_it = receiver_mutates.find(func_name);
        if (mut_it != receiver_mutates.end()) {
            mutates = std::any_of(mut_it->second.begin(), mut_it->second.end(),
                                  [](bool v) { return v; });
        }
        function_mutates_receiver[func_key] = mutates;
    }

    struct ScopeFrame {
        std::unordered_set<std::string> vars;
    };

    auto base_identifier_info = [](ExprPtr expr) -> std::optional<std::tuple<std::string, int, bool>> {
        while (expr) {
            if (expr->kind == Expr::Kind::Identifier) {
                return std::make_tuple(expr->name, expr->scope_instance_id, expr->is_mutable_binding);
            }
            if (expr->kind == Expr::Kind::Member || expr->kind == Expr::Kind::Index) {
                expr = expr->operand;
                continue;
            }
            break;
        }
        return std::nullopt;
    };

    for (const auto& entry : function_map) {
        const std::string& func_key = entry.first;
        const StmtPtr& func = entry.second;
        if (!func->body) {
            function_direct_impure[func_key] = true;
            function_unknown_call[func_key] = true;
            continue;
        }

        std::vector<ScopeFrame> scopes;
        scopes.emplace_back();
        for (const auto& param : func->params) {
            scopes.back().vars.insert(param.name);
        }
        for (const auto& ref : func->ref_params) {
            scopes.back().vars.insert(ref);
        }

        auto is_local = [&](const std::string& name) {
            for (auto it = scopes.rbegin(); it != scopes.rend(); ++it) {
                if (it->vars.count(name)) {
                    return true;
                }
            }
            return false;
        };

        bool direct_write = false;
        bool direct_impure = false;
        bool unknown_call = false;

        std::function<void(ExprPtr)> visit_expr;
        std::function<void(StmtPtr)> visit_stmt;

        visit_expr = [&](ExprPtr expr) {
            if (!expr) return;
            switch (expr->kind) {
                case Expr::Kind::Assignment: {
                    if (expr->creates_new_variable &&
                        expr->left && expr->left->kind == Expr::Kind::Identifier) {
                        scopes.back().vars.insert(expr->left->name);
                    } else {
                        auto base = base_identifier_info(expr->left);
                        if (base) {
                            const std::string& name = std::get<0>(*base);
                            bool is_mut = std::get<2>(*base);
                            if (is_mut && !is_local(name)) {
                                direct_write = true;
                            }
                        }
                    }
                    visit_expr(expr->right);
                    break;
                }
                case Expr::Kind::Call: {
                    if (!expr->operand || expr->operand->kind != Expr::Kind::Identifier) {
                        unknown_call = true;
                        direct_impure = true;
                    } else {
                        std::string callee_key = reachability_key(expr->operand->name, expr->operand->scope_instance_id);
                        function_calls[func_key].insert(callee_key);

                        auto callee_it = receiver_mutates.find(expr->operand->name);
                        for (size_t i = 0; i < expr->receivers.size(); i++) {
                            bool mut = true;
                            if (callee_it != receiver_mutates.end() && i < callee_it->second.size()) {
                                mut = callee_it->second[i];
                            }
                            if (!mut) continue;
                            ExprPtr rec = expr->receivers[i];
                            if (!receiver_is_mutable_arg(rec)) {
                                continue;
                            }
                            auto base = base_identifier_info(rec);
                            if (base) {
                                const std::string& name = std::get<0>(*base);
                                if (!is_local(name)) {
                                    direct_write = true;
                                }
                            }
                        }
                    }
                    for (const auto& rec : expr->receivers) visit_expr(rec);
                    for (const auto& arg : expr->args) visit_expr(arg);
                    visit_expr(expr->operand);
                    break;
                }
                case Expr::Kind::Process:
                    direct_impure = true;
                    break;
                case Expr::Kind::Binary:
                    visit_expr(expr->left);
                    visit_expr(expr->right);
                    break;
                case Expr::Kind::Unary:
                case Expr::Kind::Cast:
                case Expr::Kind::Length:
                    visit_expr(expr->operand);
                    break;
                case Expr::Kind::Index:
                    visit_expr(expr->operand);
                    if (!expr->args.empty()) visit_expr(expr->args[0]);
                    break;
                case Expr::Kind::Member:
                    visit_expr(expr->operand);
                    break;
                case Expr::Kind::ArrayLiteral:
                case Expr::Kind::TupleLiteral:
                    for (const auto& elem : expr->elements) visit_expr(elem);
                    break;
                case Expr::Kind::Block:
                    scopes.emplace_back();
                    for (const auto& stmt : expr->statements) visit_stmt(stmt);
                    visit_expr(expr->result_expr);
                    scopes.pop_back();
                    break;
                case Expr::Kind::Conditional:
                    visit_expr(expr->condition);
                    visit_expr(expr->true_expr);
                    visit_expr(expr->false_expr);
                    break;
                case Expr::Kind::Range:
                case Expr::Kind::Iteration:
                case Expr::Kind::Repeat:
                    visit_expr(expr->left);
                    visit_expr(expr->right);
                    break;
                default:
                    break;
            }
        };

        visit_stmt = [&](StmtPtr stmt) {
            if (!stmt) return;
            switch (stmt->kind) {
                case Stmt::Kind::VarDecl:
                    scopes.back().vars.insert(stmt->var_name);
                    visit_expr(stmt->var_init);
                    break;
                case Stmt::Kind::Expr:
                    visit_expr(stmt->expr);
                    break;
                case Stmt::Kind::Return:
                    visit_expr(stmt->return_expr);
                    break;
                case Stmt::Kind::ConditionalStmt:
                    visit_expr(stmt->condition);
                    visit_stmt(stmt->true_stmt);
                    break;
                default:
                    break;
            }
        };

        visit_expr(func->body);

        function_direct_writes_global[func_key] = direct_write;
        function_direct_impure[func_key] = direct_impure;
        function_unknown_call[func_key] = unknown_call;
    }

    for (const auto& entry : function_map) {
        const std::string& func_key = entry.first;
        function_writes_global[func_key] = function_direct_writes_global[func_key] || function_unknown_call[func_key];
    }

    bool changed = true;
    while (changed) {
        changed = false;
        for (const auto& entry : function_map) {
            const std::string& func_key = entry.first;
            bool writes = function_direct_writes_global[func_key] || function_unknown_call[func_key];
            if (!writes) {
                for (const auto& callee_key : function_calls[func_key]) {
                    if (external_functions.count(callee_key) || !function_map.count(callee_key)) {
                        writes = true;
                        break;
                    }
                    if (function_writes_global[callee_key]) {
                        writes = true;
                        break;
                    }
                }
            }
            if (writes != function_writes_global[func_key]) {
                function_writes_global[func_key] = writes;
                changed = true;
            }
        }
    }

    for (const auto& entry : function_map) {
        const std::string& func_key = entry.first;
        bool base = !function_writes_global[func_key] &&
                    !function_direct_impure[func_key] &&
                    !function_mutates_receiver[func_key];
        function_is_pure[func_key] = base;
    }

    changed = true;
    while (changed) {
        changed = false;
        for (const auto& entry : function_map) {
            const std::string& func_key = entry.first;
            bool base = !function_writes_global[func_key] &&
                        !function_direct_impure[func_key] &&
                        !function_mutates_receiver[func_key];
            bool pure = base;
            if (pure) {
                for (const auto& callee_key : function_calls[func_key]) {
                    if (external_functions.count(callee_key) || !function_map.count(callee_key)) {
                        pure = false;
                        break;
                    }
                    if (!function_is_pure[callee_key]) {
                        pure = false;
                        break;
                    }
                }
            }
            if (pure != function_is_pure[func_key]) {
                function_is_pure[func_key] = pure;
                changed = true;
            }
        }
    }
}

void CodeGenerator::analyze_usage(const Module& mod) {
    used_global_vars.clear();
    used_type_names.clear();

    std::unordered_map<std::string, StmtPtr> global_vars;
    std::unordered_map<std::string, StmtPtr> type_decls;

    for (const auto& stmt : mod.top_level) {
        if (stmt->kind == Stmt::Kind::VarDecl) {
            std::string key = reachability_key(stmt->var_name, stmt->scope_instance_id);
            global_vars[key] = stmt;
        } else if (stmt->kind == Stmt::Kind::TypeDecl) {
            type_decls[stmt->type_decl_name] = stmt;
        }
    }

    std::deque<std::string> type_worklist;
    auto add_type_name = [&](const std::string& name) {
        if (name.empty()) return;
        if (used_type_names.insert(name).second) {
            type_worklist.push_back(name);
        }
    };

    std::function<void(TypePtr)> mark_type;
    mark_type = [&](TypePtr type) {
        if (!type) return;
        switch (type->kind) {
            case Type::Kind::Named:
                add_type_name(type->type_name);
                break;
            case Type::Kind::Array:
                mark_type(type->element_type);
                break;
            case Type::Kind::Primitive:
            case Type::Kind::TypeVar:
            default:
                break;
        }
    };

    std::function<void(ExprPtr)> visit_expr_types;
    std::function<void(StmtPtr)> visit_stmt_types;

    visit_expr_types = [&](ExprPtr expr) {
        if (!expr) return;
        mark_type(expr->type);
        switch (expr->kind) {
            case Expr::Kind::Binary:
                visit_expr_types(expr->left);
                visit_expr_types(expr->right);
                break;
            case Expr::Kind::Unary:
            case Expr::Kind::Cast:
            case Expr::Kind::Length:
                visit_expr_types(expr->operand);
                break;
            case Expr::Kind::Call:
                visit_expr_types(expr->operand);
                for (const auto& rec : expr->receivers) visit_expr_types(rec);
                for (const auto& arg : expr->args) visit_expr_types(arg);
                break;
            case Expr::Kind::Index:
                visit_expr_types(expr->operand);
                if (!expr->args.empty()) visit_expr_types(expr->args[0]);
                break;
            case Expr::Kind::Member:
                visit_expr_types(expr->operand);
                break;
            case Expr::Kind::ArrayLiteral:
            case Expr::Kind::TupleLiteral:
                for (const auto& elem : expr->elements) visit_expr_types(elem);
                break;
            case Expr::Kind::Block:
                for (const auto& stmt : expr->statements) visit_stmt_types(stmt);
                visit_expr_types(expr->result_expr);
                break;
            case Expr::Kind::Conditional:
                visit_expr_types(expr->condition);
                visit_expr_types(expr->true_expr);
                visit_expr_types(expr->false_expr);
                break;
            case Expr::Kind::Assignment:
                visit_expr_types(expr->left);
                visit_expr_types(expr->right);
                break;
            case Expr::Kind::Range:
            case Expr::Kind::Iteration:
            case Expr::Kind::Repeat:
                visit_expr_types(expr->left);
                visit_expr_types(expr->right);
                break;
            default:
                break;
        }
    };

    visit_stmt_types = [&](StmtPtr stmt) {
        if (!stmt) return;
        switch (stmt->kind) {
            case Stmt::Kind::VarDecl:
                mark_type(stmt->var_type);
                visit_expr_types(stmt->var_init);
                break;
            case Stmt::Kind::Expr:
                visit_expr_types(stmt->expr);
                break;
            case Stmt::Kind::Return:
                visit_expr_types(stmt->return_expr);
                break;
            case Stmt::Kind::ConditionalStmt:
                visit_expr_types(stmt->condition);
                visit_stmt_types(stmt->true_stmt);
                break;
            default:
                break;
        }
    };

    struct ScopeFrame {
        std::unordered_set<std::string> vars;
    };

    auto is_local = [&](const std::string& name, const std::vector<ScopeFrame>& scopes) {
        for (auto it = scopes.rbegin(); it != scopes.rend(); ++it) {
            if (it->vars.count(name)) return true;
        }
        return false;
    };

    std::deque<StmtPtr> global_worklist;

    auto mark_global = [&](const std::string& name, int scope_id) {
        std::string key = reachability_key(name, scope_id);
        auto it = global_vars.find(key);
        if (it == global_vars.end()) return;
        if (used_global_vars.insert(it->second.get()).second) {
            global_worklist.push_back(it->second);
        }
    };

    std::function<void(ExprPtr, std::vector<ScopeFrame>&)> visit_expr_globals;
    std::function<void(StmtPtr, std::vector<ScopeFrame>&)> visit_stmt_globals;

    visit_expr_globals = [&](ExprPtr expr, std::vector<ScopeFrame>& scopes) {
        if (!expr) return;
        switch (expr->kind) {
            case Expr::Kind::Identifier:
                if (!is_local(expr->name, scopes)) {
                    mark_global(expr->name, expr->scope_instance_id);
                }
                break;
            case Expr::Kind::Assignment:
                if (expr->creates_new_variable &&
                    expr->left && expr->left->kind == Expr::Kind::Identifier) {
                    scopes.back().vars.insert(expr->left->name);
                }
                visit_expr_globals(expr->left, scopes);
                visit_expr_globals(expr->right, scopes);
                break;
            case Expr::Kind::Binary:
                visit_expr_globals(expr->left, scopes);
                visit_expr_globals(expr->right, scopes);
                break;
            case Expr::Kind::Unary:
            case Expr::Kind::Cast:
            case Expr::Kind::Length:
                visit_expr_globals(expr->operand, scopes);
                break;
            case Expr::Kind::Call:
                visit_expr_globals(expr->operand, scopes);
                for (const auto& rec : expr->receivers) visit_expr_globals(rec, scopes);
                for (const auto& arg : expr->args) visit_expr_globals(arg, scopes);
                break;
            case Expr::Kind::Index:
                visit_expr_globals(expr->operand, scopes);
                if (!expr->args.empty()) visit_expr_globals(expr->args[0], scopes);
                break;
            case Expr::Kind::Member:
                visit_expr_globals(expr->operand, scopes);
                break;
            case Expr::Kind::ArrayLiteral:
            case Expr::Kind::TupleLiteral:
                for (const auto& elem : expr->elements) visit_expr_globals(elem, scopes);
                break;
            case Expr::Kind::Block:
                scopes.emplace_back();
                for (const auto& stmt : expr->statements) visit_stmt_globals(stmt, scopes);
                visit_expr_globals(expr->result_expr, scopes);
                scopes.pop_back();
                break;
            case Expr::Kind::Conditional:
                visit_expr_globals(expr->condition, scopes);
                visit_expr_globals(expr->true_expr, scopes);
                visit_expr_globals(expr->false_expr, scopes);
                break;
            case Expr::Kind::Range:
            case Expr::Kind::Iteration:
            case Expr::Kind::Repeat:
                visit_expr_globals(expr->left, scopes);
                visit_expr_globals(expr->right, scopes);
                break;
            default:
                break;
        }
    };

    visit_stmt_globals = [&](StmtPtr stmt, std::vector<ScopeFrame>& scopes) {
        if (!stmt) return;
        switch (stmt->kind) {
            case Stmt::Kind::VarDecl:
                scopes.back().vars.insert(stmt->var_name);
                visit_expr_globals(stmt->var_init, scopes);
                break;
            case Stmt::Kind::Expr:
                visit_expr_globals(stmt->expr, scopes);
                break;
            case Stmt::Kind::Return:
                visit_expr_globals(stmt->return_expr, scopes);
                break;
            case Stmt::Kind::ConditionalStmt:
                visit_expr_globals(stmt->condition, scopes);
                visit_stmt_globals(stmt->true_stmt, scopes);
                break;
            default:
                break;
        }
    };

    // Reachable functions drive usage.
    for (const auto& stmt : mod.top_level) {
        if (stmt->kind == Stmt::Kind::FuncDecl) {
            std::string func_name = stmt->func_name;
            if (!stmt->type_namespace.empty()) {
                func_name = stmt->type_namespace + "::" + stmt->func_name;
                add_type_name(stmt->type_namespace);
            }
            std::string key = reachability_key(func_name, stmt->scope_instance_id);
            if (!reachable_functions.count(key)) {
                continue;
            }

            mark_type(stmt->return_type);
            for (const auto& t : stmt->return_types) {
                mark_type(t);
            }
            for (const auto& param : stmt->params) {
                mark_type(param.type);
            }
            for (const auto& ref_type : stmt->ref_param_types) {
                mark_type(ref_type);
            }

            if (stmt->body) {
                visit_expr_types(stmt->body);
                std::vector<ScopeFrame> scopes;
                scopes.emplace_back();
                for (const auto& param : stmt->params) {
                    scopes.back().vars.insert(param.name);
                }
                for (const auto& ref : stmt->ref_params) {
                    scopes.back().vars.insert(ref);
                }
                visit_expr_globals(stmt->body, scopes);
            }
        } else if (stmt->kind == Stmt::Kind::Expr) {
            visit_expr_types(stmt->expr);
            std::vector<ScopeFrame> scopes;
            scopes.emplace_back();
            visit_expr_globals(stmt->expr, scopes);
        }
    }

    // Walk globals referenced by reachable code.
    while (!global_worklist.empty()) {
        StmtPtr global = global_worklist.front();
        global_worklist.pop_front();
        if (!global) continue;
        mark_type(global->var_type);
        visit_expr_types(global->var_init);
        std::vector<ScopeFrame> scopes;
        scopes.emplace_back();
        visit_expr_globals(global->var_init, scopes);
    }

    // Close over field types for used type declarations.
    while (!type_worklist.empty()) {
        std::string type_name = type_worklist.front();
        type_worklist.pop_front();
        auto it = type_decls.find(type_name);
        if (it == type_decls.end()) continue;
        const StmtPtr& decl = it->second;
        for (const auto& field : decl->fields) {
            mark_type(field.type);
        }
    }
}

void CodeGenerator::mark_reachable(const std::string& func_name, int scope_id, const Module& mod) {
    std::string key = reachability_key(func_name, scope_id);
    if (reachable_functions.count(key)) {
        return;
    }

    reachable_functions.insert(key);

    // Find the function definition
    for (const auto& stmt : mod.top_level) {
        if (stmt->kind == Stmt::Kind::FuncDecl && !stmt->is_external) {
            // Build qualified name if this is a method
            std::string stmt_func_name = stmt->func_name;
            if (!stmt->type_namespace.empty()) {
                stmt_func_name = stmt->type_namespace + "::" + stmt->func_name;
            }

            if (stmt_func_name == func_name) {
                if (scope_id >= 0) {
                    if (stmt->scope_instance_id != scope_id) continue;
                } else if (stmt->scope_instance_id >= 0) {
                    continue;
                }
                // Collect all function calls in this function's body
                if (stmt->body) {
                    std::unordered_set<std::string> calls;
                    collect_calls(stmt->body, calls);

                    // Recursively mark called functions as reachable
                    for (const auto& called_key : calls) {
                        std::string called_name;
                        int called_scope = -1;
                        split_reachability_key(called_key, called_name, called_scope);
                        mark_reachable(called_name, called_scope, mod);
                    }
                }
                break;
            }
        }
    }
}

void CodeGenerator::collect_calls(ExprPtr expr, std::unordered_set<std::string>& calls) {
    if (!expr) return;

    switch (expr->kind) {
        case Expr::Kind::Call:
            // Extract function name from call (already qualified by type checker for methods)
            if (expr->operand && expr->operand->kind == Expr::Kind::Identifier) {
                calls.insert(reachability_key(expr->operand->name, expr->operand->scope_instance_id));
            }
            for (const auto& rec : expr->receivers) {
                collect_calls(rec, calls);
            }
            // Also check arguments
            for (const auto& arg : expr->args) {
                collect_calls(arg, calls);
            }
            collect_calls(expr->operand, calls);
            break;

        case Expr::Kind::Binary:
            collect_calls(expr->left, calls);
            collect_calls(expr->right, calls);
            break;

        case Expr::Kind::Unary:
            collect_calls(expr->operand, calls);
            break;

        case Expr::Kind::Index:
            collect_calls(expr->operand, calls);
            if (!expr->args.empty()) collect_calls(expr->args[0], calls);
            break;

        case Expr::Kind::Member:
            collect_calls(expr->operand, calls);
            break;

        case Expr::Kind::ArrayLiteral:
            for (const auto& elem : expr->elements) {
                collect_calls(elem, calls);
            }
            break;

        case Expr::Kind::Block:
            for (const auto& stmt : expr->statements) {
                if (stmt->kind == Stmt::Kind::Expr && stmt->expr) {
                    collect_calls(stmt->expr, calls);
                } else if (stmt->kind == Stmt::Kind::Return && stmt->return_expr) {
                    collect_calls(stmt->return_expr, calls);
                } else if (stmt->kind == Stmt::Kind::VarDecl && stmt->var_init) {
                    collect_calls(stmt->var_init, calls);
                }
            }
            if (expr->result_expr) {
                collect_calls(expr->result_expr, calls);
            }
            break;

        case Expr::Kind::Conditional:
            collect_calls(expr->condition, calls);
            collect_calls(expr->true_expr, calls);
            if (expr->false_expr) collect_calls(expr->false_expr, calls);
            break;

        case Expr::Kind::Cast:
            collect_calls(expr->operand, calls);
            break;

        case Expr::Kind::Assignment:
            collect_calls(expr->left, calls);
            collect_calls(expr->right, calls);
            break;

        case Expr::Kind::Range:
            collect_calls(expr->left, calls);
            collect_calls(expr->right, calls);
            break;

        case Expr::Kind::Length:
            collect_calls(expr->operand, calls);
            break;

        case Expr::Kind::Iteration:
        case Expr::Kind::Repeat:
            collect_calls(expr->left, calls);
            if (expr->right) collect_calls(expr->right, calls);
            break;

        default:
            // Literals and identifiers don't contain calls
            break;
    }
}

void CodeGenerator::gen_module(const Module& mod) {
    // External function forward declarations
    for (const auto& stmt : mod.top_level) {
        if (stmt->kind == Stmt::Kind::FuncDecl && stmt->is_external) {
            std::string func_name = stmt->func_name;
            if (!stmt->type_namespace.empty()) {
                func_name = stmt->type_namespace + "::" + stmt->func_name;
            }
            bool is_reentrant = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                            [](const Annotation& a) { return a.name == "reentrant"; });
            bool is_nonreentrant = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                               [](const Annotation& a) { return a.name == "nonreentrant"; });
            if (is_reentrant && is_nonreentrant) {
                throw CompileError("Conflicting annotations: [[reentrant]] and [[nonreentrant]] on external function '" +
                                   stmt->func_name + "'", stmt->location);
            }
            std::string reent_prefix = is_reentrant ? "VX_REENTRANT " : "VX_NON_REENTRANT ";
            bool has_inline = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                          [](const Annotation& a) { return a.name == "inline"; });
            bool has_noinline = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                            [](const Annotation& a) { return a.name == "noinline"; });
            std::string label_prefix;
            if (!stmt->ref_params.empty()) {
                std::string ref_key(stmt->ref_params.size(), 'M');
                label_prefix += "VX_REF_MASK(\"" + ref_key + "\") ";
            }
            if (stmt->is_exported) {
                label_prefix += "VX_ENTRYPOINT ";
            }
            if (has_noinline) {
                label_prefix += "VX_NOINLINE ";
            } else if (has_inline) {
                label_prefix += "VX_INLINE ";
            }
            std::string ret_type = stmt->return_type ? gen_type(stmt->return_type) : "void";
            emit_header(label_prefix + reent_prefix + ret_type + " " + mangle_name(func_name) + "(");
            for (size_t i = 0; i < stmt->params.size(); i++) {
                if (i > 0) emit_header(", ");
                std::string ptype = stmt->params[i].type ? gen_type(stmt->params[i].type) : "int";
                emit_header(ptype + " " + mangle_name(stmt->params[i].name));
            }
            emit_header(");");
        }
    }
    emit_header("");

    // Type declarations
    for (const auto& stmt : mod.top_level) {
        if (stmt->kind == Stmt::Kind::TypeDecl) {
            if (!used_type_names.empty() && !used_type_names.count(stmt->type_decl_name)) {
                continue;
            }
            gen_type_decl(stmt);
        }
    }

    // Note: tuple type declarations will be emitted after code generation

    // Forward declarations (only for reachable functions)
    for (const auto& stmt : mod.top_level) {
        if (stmt->kind == Stmt::Kind::FuncDecl && !stmt->is_external) {
            // Build qualified name for methods
            std::string func_name = stmt->func_name;
            if (!stmt->type_namespace.empty()) {
                func_name = stmt->type_namespace + "::" + stmt->func_name;
            }

            // Skip unreachable functions
            // For imported functions (scope_instance_id >= 0), always generate if base name is reachable
            std::string key = reachability_key(func_name, stmt->scope_instance_id);
            if (!reachable_functions.count(key)) {
                continue;
            }

            // Skip functions with expression parameters - they're inlined at call sites
            bool has_expr_params = false;
            for (const auto& param : stmt->params) {
                if (param.is_expression_param) {
                    has_expr_params = true;
                    break;
                }
            }
            if (has_expr_params) {
                continue;
            }

            // Internal functions are static, exported functions are public
            std::string storage = stmt->is_exported ? "" : "static ";
            bool has_inline = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                          [](const Annotation& a) { return a.name == "inline"; });
            bool has_noinline = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                            [](const Annotation& a) { return a.name == "noinline"; });
            bool is_pure = false;
            bool no_global_write = false;
            {
                auto pure_it = function_is_pure.find(key);
                if (pure_it != function_is_pure.end() && pure_it->second) {
                    is_pure = true;
                }
                auto gw_it = function_writes_global.find(key);
                if (gw_it != function_writes_global.end() && !gw_it->second) {
                    no_global_write = true;
                }
            }

            // Handle tuple return types
            std::string ret_type;
            if (!stmt->return_types.empty()) {
                // Tuple return: generate tuple type name (same format as typechecker)
                std::string tuple_name = std::string(TUPLE_TYPE_PREFIX) + std::to_string(stmt->return_types.size());
                for (const auto& t : stmt->return_types) {
                    tuple_name += "_";
                    if (t) {
                        tuple_name += t->to_string();
                    } else {
                        tuple_name += "unknown";
                    }
                }
                // Track this tuple type for declaration
                if (!tuple_types.count(tuple_name)) {
                    tuple_types[tuple_name] = stmt->return_types;
                }
                ret_type = mangle_name(tuple_name);
            } else {
                if (stmt->return_type) {
                    ret_type = gen_type(stmt->return_type);
                } else {
                    // For functions without explicit return type, infer from body
                    if (stmt->body && stmt->body->type) {
                        ret_type = gen_type(stmt->body->type);
                    } else {
                        ret_type = "void";
                    }
                }
            }

            auto ref_keys = ref_variant_keys_for(stmt);
            auto reent_keys = reentrancy_keys_for(key);
            for (const auto& reent_key : reent_keys) {
                std::string reent_prefix = (reent_key == 'R') ? "VX_REENTRANT " : "VX_NON_REENTRANT ";
                for (const auto& ref_key : ref_keys) {
                    std::string variant = variant_name(func_name, key, reent_key, ref_key);
                    std::string codegen_name = mangle_name(variant);
                    // Add scope instance suffix for imported functions
                    if (stmt->scope_instance_id >= 0) {
                        codegen_name += "_s" + std::to_string(stmt->scope_instance_id);
                    }
                    std::string label_prefix;
                    if (!ref_key.empty()) {
                        label_prefix += "VX_REF_MASK(\"" + ref_key + "\") ";
                    }
                    if (stmt->is_exported) {
                        label_prefix += "VX_ENTRYPOINT ";
                    }
                    if (is_pure) {
                        label_prefix += "VX_PURE ";
                    }
                    if (no_global_write) {
                        label_prefix += "VX_NO_GLOBAL_WRITE ";
                    }
                    if (has_noinline) {
                        label_prefix += "VX_NOINLINE ";
                    } else if (has_inline) {
                        label_prefix += "VX_INLINE ";
                    }
                    emit_header(label_prefix + reent_prefix + storage + ret_type + " " + codegen_name + "(");

                    // Reference parameters (mutable receivers use pointers, non-mutable use values)
                    for (size_t i = 0; i < stmt->ref_params.size(); i++) {
                        if (i > 0) emit_header(", ");

                        std::string ref_type;
                        TypePtr ref_type_ptr = (i < stmt->ref_param_types.size()) ? stmt->ref_param_types[i] : nullptr;
                        bool by_ref = true;
                        if (!ref_key.empty() && i < ref_key.size()) {
                            by_ref = ref_key[i] == 'M';
                        }
                        if (ref_type_ptr) {
                            ref_type = gen_type(ref_type_ptr);
                        } else if (!stmt->type_namespace.empty() && i == 0) {
                            ref_type = mangle_name(stmt->type_namespace);
                        } else {
                            ref_type = "void";
                        }

                        if (by_ref) {
                            ref_type += "*";
                        } else if (ref_type == "void") {
                            ref_type = "void*";
                        }

                        emit_header(ref_type + " " + mangle_name(stmt->ref_params[i]));
                    }

                    // Value parameters (skip expression parameters)
                    bool first_param = stmt->ref_params.empty();
                    for (size_t i = 0; i < stmt->params.size(); i++) {
                        if (stmt->params[i].is_expression_param) continue;  // Skip expression parameters
                        if (!first_param) emit_header(", ");
                        first_param = false;
                        std::string ptype = stmt->params[i].type ? gen_type(stmt->params[i].type) : "int";
                        emit_header(ptype + " " + mangle_name(stmt->params[i].name));
                    }
                    emit_header(");");
                }
            }
        }
    }
    emit_header("");

    // Global variables and functions
    emit("// DEBUG: Starting gen_stmt loop, top_level size = " + std::to_string(mod.top_level.size()));
    for (const auto& stmt : mod.top_level) {
        if (stmt->kind == Stmt::Kind::FuncDecl) {
            emit("// DEBUG: gen_stmt calling gen_func_decl for " + stmt->func_name + " scope_id=" + std::to_string(stmt->scope_instance_id));
        }
        gen_stmt(stmt);
    }

    // Generate tuple type declarations (collected during code generation)
    // These are emitted at the end of gen_module after everything is processed
    // We need to insert them after includes but before function declarations
    std::vector<std::pair<std::string, std::vector<TypePtr>>> tuple_decls;
    if (!tuple_types.empty()) {
        for (const auto& pair : tuple_types) {
            if (!used_type_names.empty() && !used_type_names.count(pair.first)) {
                continue;
            }
            tuple_decls.push_back(pair);
        }
    }

    if (!tuple_decls.empty()) {
        // Save current header and body
        std::string header_str = header.str();
        std::string body_str = body.str();

        // Clear streams
        header.str("");
        header.clear();
        body.str("");
        body.clear();

        // Find the end of includes in header (after the empty line following includes)
        size_t includes_end = header_str.find("#include <math.h>");
        if (includes_end != std::string::npos) {
            includes_end = header_str.find('\n', includes_end);
            includes_end = header_str.find('\n', includes_end + 1) + 1; // Skip the empty line
        } else {
            includes_end = 0;
        }

        // Reconstruct header with tuple declarations inserted after includes
        header << header_str.substr(0, includes_end);

        emit_header("// Tuple type declarations");
        for (const auto& pair : tuple_decls) {
            const std::string& tuple_name = pair.first;
            const std::vector<TypePtr>& elem_types = pair.second;

            emit_header("typedef struct {");
            for (size_t i = 0; i < elem_types.size(); i++) {
                std::string elem_type = elem_types[i] ? gen_type(elem_types[i]) : "int32_t";
                emit_header("  " + elem_type + " __" + std::to_string(i) + ";");
            }
            emit_header("} " + mangle_name(tuple_name) + ";");
        }
        emit_header("");

        // Append rest of header
        header << header_str.substr(includes_end);

        // Restore body section
        body << body_str;
    }
}

void CodeGenerator::gen_stmt(StmtPtr stmt) {
    switch (stmt->kind) {
        case Stmt::Kind::FuncDecl:
            {
                std::string func_name = stmt->func_name;
                if (!stmt->type_namespace.empty()) {
                    func_name = stmt->type_namespace + "::" + stmt->func_name;
                }
                std::string key = reachability_key(func_name, stmt->scope_instance_id);
                auto reent_keys = reentrancy_keys_for(key);
                auto ref_keys = ref_variant_keys_for(stmt);
                for (const auto& reent_key : reent_keys) {
                    for (const auto& ref_key : ref_keys) {
                        gen_func_decl(stmt, ref_key, reent_key);
                    }
                }
            }
            break;
        case Stmt::Kind::TypeDecl:
            // Already generated
            break;
        case Stmt::Kind::VarDecl:
            gen_var_decl(stmt);
            break;
        case Stmt::Kind::Expr:
            if (stmt->expr) {
                // Special handling for assignment expressions that create new variables
                // Check the creates_new_variable flag set by typechecker
                if (stmt->expr->kind == Expr::Kind::Assignment &&
                    stmt->expr->left->kind == Expr::Kind::Identifier &&
                    stmt->expr->creates_new_variable) {

                    // Generate variable declaration with initialization
                    std::string var_type_str;

                    // Special handling for tuple-returning function calls
                    if (stmt->expr->right && stmt->expr->right->kind == Expr::Kind::Call &&
                        stmt->expr->right->operand && stmt->expr->right->operand->kind == Expr::Kind::Identifier &&
                        type_checker) {

                        std::string func_name = stmt->expr->right->operand->name;
                        Symbol* sym = type_checker->get_scope()->lookup(func_name);

                        if (sym && sym->kind == Symbol::Kind::Function && sym->declaration &&
                            !sym->declaration->return_types.empty()) {
                            // This is a tuple-returning function
                            std::string tuple_name = std::string(TUPLE_TYPE_PREFIX) + std::to_string(sym->declaration->return_types.size());
                            for (const auto& t : sym->declaration->return_types) {
                                tuple_name += "_";
                                if (t) {
                                    tuple_name += t->to_string();
                                } else {
                                    tuple_name += "unknown";
                                }
                            }
                            var_type_str = mangle_name(tuple_name);
                        } else if (stmt->expr->right->type) {
                            var_type_str = gen_type(stmt->expr->right->type);
                        } else {
                            // Fallback
                            var_type_str = "int";
                        }
                    } else if (stmt->expr->left && stmt->expr->left->type) {
                        // Use explicit type annotation from left side
                        var_type_str = gen_type(stmt->expr->left->type);
                    } else if (stmt->expr->right && stmt->expr->right->type) {
                        // Infer from right side
                        var_type_str = gen_type(stmt->expr->right->type);
                    } else {
                        // Fallback
                        var_type_str = "int";
                    }

                    std::string var_name = mangle_name(stmt->expr->left->name);

                    // Special handling for array initialization
                    TypePtr var_type = stmt->expr->left->type ? stmt->expr->left->type : stmt->expr->type;
                    if (var_type && var_type->kind == Type::Kind::Array &&
                        stmt->expr->right->kind == Expr::Kind::ArrayLiteral) {
                        // Generate array declaration with inline initialization
                        std::string elem_type = gen_type(var_type->element_type);
                        std::string size_str = "0";
                        if (type_checker && var_type->array_size) {
                            CompileTimeEvaluator evaluator(type_checker);
                            CTValue size_val;
                            if (evaluator.try_evaluate(var_type->array_size, size_val)) {
                                size_str = std::to_string(std::get<int64_t>(size_val));
                            }
                        }
                        emit(elem_type + " " + var_name + "[" + size_str + "] = {");
                        for (size_t i = 0; i < stmt->expr->right->elements.size(); i++) {
                            if (i > 0) emit(", ");
                            emit(gen_expr(stmt->expr->right->elements[i]));
                        }
                        emit("};");
                        break;
                    }

                    std::string rhs = gen_expr(stmt->expr->right);
                    emit(var_type_str + " " + var_name + " = " + rhs + ";");
                    // Release RHS temp if it's a temporary
                    if (rhs.substr(0, 3) == "tmp") {
                        release_temp(rhs);
                    }
                    break;
                }

                // Regular expression statement (including assignments to existing variables)
                emit(gen_expr(stmt->expr) + ";");
            }
            break;
        case Stmt::Kind::Return:
            if (stmt->return_expr) {
                emit("return " + gen_expr(stmt->return_expr) + ";");
            } else {
                emit("return;");
            }
            break;
        case Stmt::Kind::Break:
            emit("break;");
            break;
        case Stmt::Kind::Continue:
            emit("continue;");
            break;
        case Stmt::Kind::ConditionalStmt:
            // Try compile-time evaluation for dead branch elimination
            if (type_checker) {
                CompileTimeEvaluator evaluator(type_checker);
                CTValue cond_val;
                if (evaluator.try_evaluate(stmt->condition, cond_val)) {
                    // Compile-time constant condition
                    bool is_true = false;
                    if (std::holds_alternative<int64_t>(cond_val)) {
                        is_true = std::get<int64_t>(cond_val) != 0;
                    } else if (std::holds_alternative<bool>(cond_val)) {
                        is_true = std::get<bool>(cond_val);
                    } else if (std::holds_alternative<uint64_t>(cond_val)) {
                        is_true = std::get<uint64_t>(cond_val) != 0;
                    }

                    if (is_true) {
                        // Only generate true branch
                        gen_stmt(stmt->true_stmt);
                    }
                    // If false, generate nothing (dead branch eliminated)
                    break;
                }
            }

            // Runtime conditional
            emit("if (" + gen_expr(stmt->condition) + ") {");
            gen_stmt(stmt->true_stmt);
            emit("}");
            break;
        default:
            break;
    }
}

void CodeGenerator::gen_func_decl(StmtPtr stmt, const std::string& ref_key, char reent_key) {
    if (stmt->is_external) return;

    // Build qualified function name for methods
    std::string func_name = stmt->func_name;
    if (!stmt->type_namespace.empty()) {
        func_name = stmt->type_namespace + "::" + stmt->func_name;
    }
    std::string reach_key = reachability_key(func_name, stmt->scope_instance_id);
    std::string variant_id = variant_name(func_name, reach_key, reent_key, ref_key);

    current_reentrancy_key = reent_key;
    current_function_non_reentrant = (reent_key == 'N');
    std::string reent_prefix = (reent_key == 'R') ? "VX_REENTRANT " : "VX_NON_REENTRANT ";

    // Skip unreachable functions (dead code elimination)
    // For imported functions (scope_instance_id >= 0), always generate if base name is reachable
    // reach_key already computed for variant selection
    if (!reachable_functions.count(reach_key)) {
        current_function_non_reentrant = false;
        current_reentrancy_key = 'N';
        return;
    }

    bool has_inline = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                  [](const Annotation& a) { return a.name == "inline"; });
    bool has_noinline = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                    [](const Annotation& a) { return a.name == "noinline"; });
    bool is_pure = false;
    bool no_global_write = false;
    {
        auto pure_it = function_is_pure.find(reach_key);
        if (pure_it != function_is_pure.end() && pure_it->second) {
            is_pure = true;
        }
        auto gw_it = function_writes_global.find(reach_key);
        if (gw_it != function_writes_global.end() && !gw_it->second) {
            no_global_write = true;
        }
    }

    // Skip functions with expression parameters - they're inlined at call sites
    for (const auto& param : stmt->params) {
        if (param.is_expression_param) {
            current_function_non_reentrant = false;
            current_reentrancy_key = 'N';
            return;
        }
    }

    // Reset temporary state for new function
    while (!available_temps.empty()) available_temps.pop();
    live_temps.clear();
    declared_temps.clear();
    temp_counter = 0;

    // Track reference parameters for this function (mutable paths use pointers)
    current_ref_params.clear();
    for (size_t i = 0; i < stmt->ref_params.size(); i++) {
        bool by_ref = true;
        if (!ref_key.empty() && i < ref_key.size()) {
            by_ref = ref_key[i] == 'M';
        }
        if (by_ref) {
            current_ref_params.insert(stmt->ref_params[i]);
        }
    }

    // Internal functions are static, exported functions are public
    std::string storage = stmt->is_exported ? "" : "static ";
    std::string attr;
    if (stmt->is_exported) {
        if (std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                        [](const Annotation& a) { return a.name == "hot"; })) {
            attr = "__attribute__((hot)) ";
        }
        if (std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                        [](const Annotation& a) { return a.name == "cold"; })) {
            attr = "__attribute__((cold)) ";
        }
    }

    // Handle tuple return types
    std::string ret_type;
    if (!stmt->return_types.empty()) {
        std::string tuple_name = std::string(TUPLE_TYPE_PREFIX) + std::to_string(stmt->return_types.size());
        for (const auto& t : stmt->return_types) {
            tuple_name += "_";
            if (t) {
                tuple_name += t->to_string();
            } else {
                tuple_name += "unknown";
            }
        }
        if (!tuple_types.count(tuple_name)) {
            tuple_types[tuple_name] = stmt->return_types;
        }
        ret_type = mangle_name(tuple_name);
    } else {
        if (stmt->return_type) {
            ret_type = gen_type(stmt->return_type);
        } else {
            if (stmt->body && stmt->body->type) {
                ret_type = gen_type(stmt->body->type);
            } else {
                ret_type = "void";
            }
        }
    }

    bool prev_in_function = in_function;
    in_function = true;
    std::ostringstream func_stream;
    output_stack.push(&func_stream);

    emit("");
    std::string ann_comment = render_annotation_comment(stmt->annotations);
    if (!ann_comment.empty()) emit(ann_comment);
    std::string codegen_name = mangle_name(variant_id);
    if (stmt->scope_instance_id >= 0) {
        codegen_name += "_s" + std::to_string(stmt->scope_instance_id);
    }
    std::string label_prefix;
    if (!ref_key.empty()) {
        label_prefix += "VX_REF_MASK(\"" + ref_key + "\") ";
    }
    if (stmt->is_exported) {
        label_prefix += "VX_ENTRYPOINT ";
    }
    if (is_pure) {
        label_prefix += "VX_PURE ";
    }
    if (no_global_write) {
        label_prefix += "VX_NO_GLOBAL_WRITE ";
    }
    if (has_noinline) {
        label_prefix += "VX_NOINLINE ";
    } else if (has_inline) {
        label_prefix += "VX_INLINE ";
    }
    emit(label_prefix + reent_prefix + storage + attr + ret_type + " " + codegen_name + "(");

    for (size_t i = 0; i < stmt->ref_params.size(); i++) {
        if (i > 0) emit(", ");
        std::string ref_type;
        TypePtr ref_type_ptr = (i < stmt->ref_param_types.size()) ? stmt->ref_param_types[i] : nullptr;
        bool by_ref = true;
        if (!ref_key.empty() && i < ref_key.size()) {
            by_ref = ref_key[i] == 'M';
        }
        if (ref_type_ptr) {
            ref_type = gen_type(ref_type_ptr);
        } else if (!stmt->type_namespace.empty() && i == 0) {
            ref_type = mangle_name(stmt->type_namespace);
        } else {
            ref_type = "void";
        }
        if (by_ref) {
            ref_type += "*";
        } else if (ref_type == "void") {
            ref_type = "void*";
        }
        emit(ref_type + " " + mangle_name(stmt->ref_params[i]));
    }

    bool first_param = stmt->ref_params.empty();
    for (size_t i = 0; i < stmt->params.size(); i++) {
        if (stmt->params[i].is_expression_param) continue;
        if (!first_param) emit(", ");
        first_param = false;
        std::string ptype = stmt->params[i].type ? gen_type(stmt->params[i].type) : "int";
        emit(ptype + " " + mangle_name(stmt->params[i].name));
    }

    emit(") {");

    bool handled_body = false;

    if (stmt->body) {
        if (type_checker && stmt->params.empty() && stmt->ref_params.empty()) {
            CompileTimeEvaluator evaluator(type_checker);
            CTValue result;
            if (evaluator.try_evaluate(stmt->body, result)) {
                if (std::holds_alternative<int64_t>(result)) {
                    emit("return " + std::to_string(std::get<int64_t>(result)) + ";");
                    handled_body = true;
                } else if (std::holds_alternative<uint64_t>(result)) {
                    emit("return " + std::to_string(std::get<uint64_t>(result)) + ";");
                    handled_body = true;
                } else if (std::holds_alternative<bool>(result)) {
                    emit("return " + std::string(std::get<bool>(result) ? "1" : "0") + ";");
                    handled_body = true;
                } else if (std::holds_alternative<double>(result)) {
                    emit("return " + std::to_string(std::get<double>(result)) + ";");
                    handled_body = true;
                }
            }
        }

        if (!handled_body && type_checker && stmt->body->kind == Expr::Kind::Block &&
            stmt->params.empty() && stmt->ref_params.empty()) {
            std::string optimized = gen_block_optimized(stmt->body);
            if (!optimized.empty()) {
                emit(optimized);
                handled_body = true;
            }
        }

        if (!handled_body) {
            std::string body_expr = gen_expr(stmt->body);
            if (stmt->return_type) {
                emit("return " + body_expr + ";");
            } else {
                emit(body_expr + ";");
            }
        }
    }

    emit("}");

    current_function_non_reentrant = false;
    current_reentrancy_key = 'N';
    
    output_stack.pop();
    in_function = prev_in_function;
    std::string func_code = func_stream.str();
    if (!func_code.empty()) {
        GeneratedFunctionInfo info;
        info.declaration = stmt;
        info.qualified_name = variant_id;
        info.c_name = codegen_name;
        info.storage = storage;
        info.code = func_code;
        generated_functions.push_back(std::move(info));
        body << func_code;
    }
}

void CodeGenerator::gen_type_decl(StmtPtr stmt) {
    std::string ann_comment = render_annotation_comment(stmt->annotations);
    if (!ann_comment.empty()) emit_header(ann_comment);
    emit_header("typedef struct {");
    for (const auto& field : stmt->fields) {
        std::string ftype = field.type ? gen_type(field.type) : "int";
        emit_header("  " + ftype + " " + mangle_name(field.name) + ";");
    }
    emit_header("} " + mangle_name(stmt->type_decl_name) + ";");
    emit_header("");

    type_map[stmt->type_decl_name] = mangle_name(stmt->type_decl_name);
}

void CodeGenerator::gen_var_decl(StmtPtr stmt) {
    bool is_local = in_function;
    if (!is_local && !used_global_vars.count(stmt.get())) {
        return;
    }
    // Top-level mutable globals must be internal to the translation unit
    std::string storage = (!is_local && stmt->is_mutable) ? "static " : "";
    std::ostringstream var_stream;
    output_stack.push(&var_stream);
    std::string ann_comment = render_annotation_comment(stmt->annotations);
    if (!ann_comment.empty()) {
        emit(ann_comment);
    }
    auto finalize = [&]() {
        output_stack.pop();
        std::string code = var_stream.str();
        if (is_local) {
            if (!output_stack.empty()) {
                *output_stack.top() << code;
            }
        } else {
            GeneratedVarInfo info;
            info.declaration = stmt;
            info.code = code;
            generated_vars.push_back(std::move(info));
            body << code;
        }
    };

    std::string var_name = stmt->var_name;
    // Add scope instance suffix for imported variables
    if (stmt->scope_instance_id >= 0) {
        var_name += "_s" + std::to_string(stmt->scope_instance_id);
    }

    std::string vtype = stmt->var_type ? gen_type(stmt->var_type) : "int";
    std::string mutability = mutability_prefix(stmt);
    if (stmt->var_init) {
        // Special handling for array literals and ranges
            if (stmt->var_type && stmt->var_type->kind == Type::Kind::Array &&
            (stmt->var_init->kind == Expr::Kind::ArrayLiteral || stmt->var_init->kind == Expr::Kind::Range)) {

            std::string elem_type = gen_type(stmt->var_type->element_type);
            std::string size_str = "0";
            if (type_checker && stmt->var_type->array_size) {
                CompileTimeEvaluator evaluator(type_checker);
                CTValue size_val;
                if (evaluator.try_evaluate(stmt->var_type->array_size, size_val)) {
                    size_str = std::to_string(std::get<int64_t>(size_val));
                }
            }

            // Handle range expansion
            if (stmt->var_init->kind == Expr::Kind::Range) {
                auto bounds = evaluate_range(stmt->var_init);
                if (bounds) {
                    int64_t start = bounds->first;
                    int64_t end = bounds->second;
                    if (start == end) {
                        throw CompileError("Range cannot produce an empty array", stmt->var_init->location);
                    }
                    int64_t count = (start < end) ? (end - start) : (start - end);
                    std::ostringstream init;
                    init << storage << mutability << elem_type << " " << mangle_name(var_name) << "[" << count << "] = {";
                    bool first = true;
                    if (start < end) {
                        for (int64_t i = start; i < end; ++i) {
                            if (!first) init << ", ";
                            first = false;
                            init << i;
                        }
                    } else {
                        for (int64_t i = start; i > end; --i) {
                            if (!first) init << ", ";
                            first = false;
                            init << i;
                        }
                    }
                    init << "};";
                    emit(init.str());
                    finalize();
                    return;
                }
            }

                // Handle array literal
                if (stmt->var_init->kind == Expr::Kind::ArrayLiteral) {
                    emit(storage + mutability + elem_type + " " + mangle_name(var_name) + "[" + size_str + "] = {");
                    for (size_t i = 0; i < stmt->var_init->elements.size(); i++) {
                        if (i > 0) emit(", ");
                        emit(gen_expr(stmt->var_init->elements[i]));
                    }
                    emit("};");
                    finalize();
                    return;
                }
            }

            // Fallback for arrays initialized from existing arrays/expressions: allocate and copy
            if (stmt->var_type && stmt->var_type->kind == Type::Kind::Array) {
                std::string elem_type = gen_type(stmt->var_type->element_type);
                std::string size_str = "0";
                if (type_checker && stmt->var_type->array_size) {
                    CompileTimeEvaluator evaluator(type_checker);
                    CTValue size_val;
                    if (evaluator.try_evaluate(stmt->var_type->array_size, size_val)) {
                        size_str = std::to_string(std::get<int64_t>(size_val));
                    }
                }
                emit(storage + mutability + elem_type + " " + mangle_name(var_name) + "[" + size_str + "];");
                emit("memcpy(" + mangle_name(var_name) + ", " + gen_expr(stmt->var_init) + ", sizeof(" + mangle_name(var_name) + "));");
                finalize();
                return;
            }

            // Try compile-time evaluation for simple constants
            if (type_checker) {
            CompileTimeEvaluator evaluator(type_checker);
            CTValue result;
            if (evaluator.try_evaluate(stmt->var_init, result)) {
                // Successfully evaluated at compile time
                std::string init_val;
                if (std::holds_alternative<int64_t>(result)) {
                    int64_t val = std::get<int64_t>(result);
                    // For integer types, ensure the value is in range for C
                    // Apply wrapping if needed
                    if (stmt->var_type && stmt->var_type->kind == Type::Kind::Primitive) {
                        switch (stmt->var_type->primitive) {
                            case PrimitiveType::I8:
                                val = static_cast<int8_t>(val);
                                break;
                            case PrimitiveType::I16:
                                val = static_cast<int16_t>(val);
                                break;
                            case PrimitiveType::I32:
                                val = static_cast<int32_t>(val);
                                break;
                            case PrimitiveType::U8:
                                val = static_cast<uint8_t>(val);
                                break;
                            case PrimitiveType::U16:
                                val = static_cast<uint16_t>(val);
                                break;
                            case PrimitiveType::U32:
                                val = static_cast<uint32_t>(val);
                                break;
                            default:
                                break;
                        }
                    }
                    init_val = std::to_string(val);
                } else if (std::holds_alternative<uint64_t>(result)) {
                    uint64_t val = std::get<uint64_t>(result);
                    // Apply wrapping for smaller unsigned types
                    if (stmt->var_type && stmt->var_type->kind == Type::Kind::Primitive) {
                        switch (stmt->var_type->primitive) {
                            case PrimitiveType::U8:
                                val = static_cast<uint8_t>(val);
                                break;
                            case PrimitiveType::U16:
                                val = static_cast<uint16_t>(val);
                                break;
                            case PrimitiveType::U32:
                                val = static_cast<uint32_t>(val);
                                break;
                            default:
                                break;
                        }
                    }
                    init_val = std::to_string(val);
                } else if (std::holds_alternative<double>(result)) {
                    init_val = std::to_string(std::get<double>(result));
                } else if (std::holds_alternative<std::string>(result)) {
                    init_val = "\"" + escape_c_string(std::get<std::string>(result)) + "\"";
                }
                emit(storage + mutability + vtype + " " + mangle_name(var_name) + " = " + init_val + ";");
                finalize();
                return;
            } else if (!stmt->is_mutable) {
                // Immutable constant must be compile-time evaluable
                throw CompileError("Constant '" + stmt->var_name + "' cannot be evaluated at compile time: " +
                                 evaluator.get_error(), stmt->location);
            }
        }
        // Fallback to runtime evaluation (only for mutable variables)
        emit(storage + mutability + vtype + " " + mangle_name(var_name) + " = " + gen_expr(stmt->var_init) + ";");
    } else {
        // No initializer - special handling for arrays
        if (stmt->var_type && stmt->var_type->kind == Type::Kind::Array) {
            std::string elem_type = gen_type(stmt->var_type->element_type);
            std::string size_str = "0";
            if (type_checker && stmt->var_type->array_size) {
                CompileTimeEvaluator evaluator(type_checker);
                CTValue size_val;
                if (evaluator.try_evaluate(stmt->var_type->array_size, size_val)) {
                    size_str = std::to_string(std::get<int64_t>(size_val));
                }
            }
            emit(storage + mutability + elem_type + " " + mangle_name(var_name) + "[" + size_str + "];");
        } else {
            emit(storage + mutability + vtype + " " + mangle_name(var_name) + ";");
        }
    }

    finalize();
}

bool CodeGenerator::is_compile_time_init(StmtPtr stmt) const {
    if (!stmt || !stmt->var_init) return false;
    if (stmt->var_type && stmt->var_type->kind == Type::Kind::Array &&
        (stmt->var_init->kind == Expr::Kind::ArrayLiteral || stmt->var_init->kind == Expr::Kind::Range)) {
        return true;
    }
    if (!type_checker) return false;
    CompileTimeEvaluator evaluator(type_checker);
    CTValue result;
    return evaluator.try_evaluate(stmt->var_init, result);
}

std::string CodeGenerator::mutability_prefix(StmtPtr stmt) const {
    auto it = var_mutability.find(stmt.get());
    VarMutability kind = stmt->is_mutable ? VarMutability::Mutable : VarMutability::Constexpr;
    if (it != var_mutability.end()) {
        kind = it->second;
    }
    switch (kind) {
        case VarMutability::Mutable:
            return "VX_MUTABLE ";
        case VarMutability::NonMutableRuntime:
            return "VX_NON_MUTABLE ";
        case VarMutability::Constexpr:
            return "VX_CONSTEXPR ";
        default:
            return "";
    }
}

std::string CodeGenerator::ref_variant_key(const ExprPtr& call, size_t ref_count) const {
    std::string key;
    key.reserve(ref_count);
    for (size_t i = 0; i < ref_count; i++) {
        bool is_mut = false;
        if (call && i < call->receivers.size()) {
            is_mut = receiver_is_mutable_arg(call->receivers[i]);
        }
        key.push_back(is_mut ? 'M' : 'N');
    }
    return key;
}

std::vector<std::string> CodeGenerator::ref_variant_keys_for(StmtPtr stmt) const {
    std::vector<std::string> keys;
    if (!stmt || stmt->ref_params.empty()) {
        keys.push_back("");
        return keys;
    }
    std::string func_name = stmt->func_name;
    if (!stmt->type_namespace.empty()) {
        func_name = stmt->type_namespace + "::" + stmt->func_name;
    }
    auto it = ref_variants.find(func_name);
    if (it != ref_variants.end()) {
        keys.assign(it->second.begin(), it->second.end());
    }
    if (keys.empty()) {
        keys.push_back(std::string(stmt->ref_params.size(), 'M'));
    }
    std::sort(keys.begin(), keys.end());
    return keys;
}

std::string CodeGenerator::ref_variant_name(const std::string& func_name, const std::string& ref_key) const {
    if (ref_key.empty()) return func_name;
    bool all_mut = std::all_of(ref_key.begin(), ref_key.end(), [](char c) { return c == 'M'; });
    if (all_mut) return func_name;
    return func_name + "__ref" + ref_key;
}

std::vector<char> CodeGenerator::reentrancy_keys_for(const std::string& func_key) const {
    std::vector<char> keys;
    auto it = reentrancy_variants.find(func_key);
    if (it != reentrancy_variants.end()) {
        keys.assign(it->second.begin(), it->second.end());
    }
    if (keys.empty()) {
        keys.push_back('N');
    }
    std::sort(keys.begin(), keys.end());
    return keys;
}

std::string CodeGenerator::reentrancy_variant_name(const std::string& func_name, const std::string& func_key, char reent_key) const {
    auto it = reentrancy_variants.find(func_key);
    if (it == reentrancy_variants.end() || it->second.size() <= 1) {
        return func_name;
    }
    if (reent_key == 'R') {
        return func_name + "__reent";
    }
    return func_name + "__nonreent";
}

std::string CodeGenerator::variant_name(const std::string& func_name, const std::string& func_key,
                                        char reent_key, const std::string& ref_key) const {
    std::string name = reentrancy_variant_name(func_name, func_key, reent_key);
    return ref_variant_name(name, ref_key);
}

bool CodeGenerator::receiver_is_mutable_arg(ExprPtr expr) const {
    return is_addressable_lvalue(expr) && is_mutable_lvalue(expr);
}

std::string CodeGenerator::reachability_key(const std::string& func_name, int scope_id) const {
    if (scope_id < 0) {
        return func_name;
    }
    return func_name + kScopeSep + std::to_string(scope_id);
}

void CodeGenerator::split_reachability_key(const std::string& key, std::string& func_name, int& scope_id) const {
    size_t pos = key.rfind(kScopeSep);
    if (pos == std::string::npos) {
        func_name = key;
        scope_id = -1;
        return;
    }
    func_name = key.substr(0, pos);
    scope_id = std::stoi(key.substr(pos + 1));
}

bool CodeGenerator::is_addressable_lvalue(ExprPtr expr) const {
    if (!expr) return false;
    switch (expr->kind) {
        case Expr::Kind::Identifier:
            return true;
        case Expr::Kind::Member:
        case Expr::Kind::Index:
            return is_addressable_lvalue(expr->operand);
        default:
            return false;
    }
}

bool CodeGenerator::is_mutable_lvalue(ExprPtr expr) const {
    if (!expr) return false;
    switch (expr->kind) {
        case Expr::Kind::Identifier:
            return expr->is_mutable_binding;
        case Expr::Kind::Member:
        case Expr::Kind::Index:
            return is_mutable_lvalue(expr->operand);
        default:
            return false;
    }
}

std::string CodeGenerator::gen_expr(ExprPtr expr) {
    if (!expr) return "";

    switch (expr->kind) {
        case Expr::Kind::IntLiteral:
            return std::to_string((int64_t)expr->uint_val);
        case Expr::Kind::FloatLiteral:
            return std::to_string(expr->float_val);
        case Expr::Kind::StringLiteral:
            return "\"" + escape_c_string(expr->string_val) + "\"";
        case Expr::Kind::CharLiteral:
            return std::to_string(expr->uint_val);
        case Expr::Kind::Identifier:
            // Check if this is an expression parameter reference
            if (expr->is_expr_param_ref && expr_param_substitutions.count(expr->name)) {
                // Substitute the expression
                return gen_expr(expr_param_substitutions[expr->name]);
            }
            {
                auto value_it = value_param_replacements.find(expr->name);
                if (value_it != value_param_replacements.end()) {
                    return value_it->second;
                }
            }
            // Check if this is the underscore loop variable
            if (expr->name == "_" && !underscore_var.empty()) {
                return underscore_var;
            }
            {
                std::string name = mangle_name(expr->name);
                bool is_ref_param = current_ref_params.count(expr->name) > 0;
                // Add scope instance suffix for imported symbols
                int scope_id = expr->scope_instance_id;
                if (scope_id < 0 && type_checker) {
                    // Try looking up the symbol to get scope instance
                    Symbol* sym = type_checker->get_scope()->lookup(expr->name);
                    if (sym && sym->scope_instance_id >= 0) {
                        scope_id = sym->scope_instance_id;
                    }
                }
                if (scope_id >= 0) {
                    name += "_s" + std::to_string(scope_id);
                }
                if (is_ref_param) {
                    return "(*" + name + ")";
                }
                return name;
            }
        case Expr::Kind::Binary:
            return gen_binary(expr);
        case Expr::Kind::Unary:
            return gen_unary(expr);
        case Expr::Kind::Call:
            return gen_call(expr);
        case Expr::Kind::Index:
            return gen_index(expr);
        case Expr::Kind::Member:
            return gen_member(expr);
        case Expr::Kind::ArrayLiteral:
            return gen_array_literal(expr);
        case Expr::Kind::TupleLiteral:
            return gen_tuple_literal(expr);
        case Expr::Kind::Block:
            return gen_block(expr);
        case Expr::Kind::Conditional:
            return gen_conditional(expr);
        case Expr::Kind::Cast:
            return gen_cast(expr);
        case Expr::Kind::Assignment:
            return gen_assignment(expr);
        case Expr::Kind::Range:
            return gen_range(expr);
        case Expr::Kind::Length:
            return gen_length(expr);
        case Expr::Kind::Iteration:
            return gen_iteration(expr);
        case Expr::Kind::Repeat:
            return gen_repeat(expr);
        case Expr::Kind::Resource:
            return "";
        case Expr::Kind::Process:
            return "";
    }
    return "";
}

std::string CodeGenerator::gen_binary(ExprPtr expr) {
    std::string left = gen_expr(expr->left);
    std::string right = gen_expr(expr->right);
    if (expr->op == "==" || expr->op == "!=") {
        TypePtr cmp_type = expr->left ? expr->left->type : nullptr;
        if (!cmp_type && type_checker && expr->left && expr->left->kind == Expr::Kind::Identifier) {
            Symbol* sym = type_checker->get_scope()->lookup(expr->left->name);
            if (sym) {
                cmp_type = sym->type;
            }
        }
        if (!cmp_type && expr->right) {
            cmp_type = expr->right->type;
        }
        if (cmp_type &&
            (cmp_type->kind == Type::Kind::Array ||
             cmp_type->kind == Type::Kind::Named ||
             (cmp_type->kind == Type::Kind::Primitive && cmp_type->primitive == PrimitiveType::String))) {
            std::string cmp_name = ensure_comparator(cmp_type);
            return "(" + cmp_name + "(" + left + ", " + right + ") " + expr->op + " 0)";
        }
    }
    return "(" + left + " " + expr->op + " " + right + ")";
}

std::string CodeGenerator::gen_unary(ExprPtr expr) {
    std::string operand = gen_expr(expr->operand);
    return "(" + expr->op + operand + ")";
}

std::string CodeGenerator::gen_call(ExprPtr expr) {
    // Check if this is a type constructor call
    if (expr->operand && expr->operand->kind == Expr::Kind::Identifier &&
        expr->type && expr->type->kind == Type::Kind::Named) {

        Symbol* sym = nullptr;
        if (type_checker) {
            sym = type_checker->get_scope()->lookup(expr->operand->name);
        }

        if (sym && sym->kind == Symbol::Kind::Type && sym->declaration) {
            // Generate C struct initialization
            std::string type_name = mangle_name(expr->operand->name);
            std::string result = "((" + type_name + "){";

            // Match arguments to fields by position
            for (size_t i = 0; i < expr->args.size() && i < sym->declaration->fields.size(); i++) {
                if (i > 0) result += ", ";
                result += "." + mangle_name(sym->declaration->fields[i].name) + " = ";
                result += gen_expr(expr->args[i]);
            }

            result += "})";
            return result;
        }
    }

    // Check if this function has expression parameters - if so, inline it
    if (type_checker && expr->operand && expr->operand->kind == Expr::Kind::Identifier) {
        Symbol* sym = type_checker->get_scope()->lookup(expr->operand->name);
        if (sym && sym->kind == Symbol::Kind::Function && sym->declaration) {
            // Check if any parameters are expression parameters
            bool has_expr_params = false;
            for (const auto& param : sym->declaration->params) {
                if (param.is_expression_param) {
                    has_expr_params = true;
                    break;
                }
            }

            if (has_expr_params) {
                // Inline the function body with expression parameter substitutions
                // Save current substitutions
                auto saved_substitutions = expr_param_substitutions;
                expr_param_substitutions.clear();
                auto saved_value_replacements = value_param_replacements;
                value_param_replacements.clear();

                // Map expression parameters to their argument expressions
                for (size_t i = 0; i < expr->args.size() && i < sym->declaration->params.size(); i++) {
                    const auto& param = sym->declaration->params[i];
                    if (param.is_expression_param) {
                        expr_param_substitutions[param.name] = expr->args[i];
                    } else {
                        std::string arg_expr = gen_expr(expr->args[i]);
                        value_param_replacements[param.name] = arg_expr;
                    }
                }

                // Generate the inlined function body
                std::string result = gen_expr(sym->declaration->body);

                // Restore previous substitutions
                expr_param_substitutions = saved_substitutions;
                value_param_replacements = saved_value_replacements;

                return result;
            }
        }
    }

    // Regular function call or method call
    std::string func_name;
    std::string ref_key;
    std::vector<std::string> all_args;

    // Get function name (already qualified by type checker for methods)
    if (expr->operand && expr->operand->kind == Expr::Kind::Identifier) {
        // Look up symbol to get original function name and scope instance
        std::string original_name = expr->operand->name;
        int scope_id = expr->operand->scope_instance_id;

        Symbol* sym = nullptr;
        if (type_checker) {
            sym = type_checker->get_scope()->lookup(expr->operand->name);
            if (sym && sym->declaration && sym->kind == Symbol::Kind::Function) {
                // Use the original unmangled name from the declaration
                original_name = sym->declaration->func_name;
                if (!sym->declaration->type_namespace.empty()) {
                    original_name = sym->declaration->type_namespace + "::" + original_name;
                }
                if (sym->scope_instance_id >= 0) {
                    scope_id = sym->scope_instance_id;
                }
            }
        }

        bool is_external = false;
        if (sym && sym->declaration && sym->kind == Symbol::Kind::Function) {
            is_external = sym->declaration->is_external;
            if (!sym->declaration->ref_params.empty()) {
                if (is_external) {
                    ref_key = std::string(sym->declaration->ref_params.size(), 'M');
                } else {
                    ref_key = ref_variant_key(expr, sym->declaration->ref_params.size());
                }
            }
            if (!is_external) {
                std::string func_key = reachability_key(original_name, scope_id);
                original_name = variant_name(original_name, func_key, current_reentrancy_key, ref_key);
            } else if (!ref_key.empty()) {
                original_name = ref_variant_name(original_name, ref_key);
            }
        }

        func_name = mangle_name(original_name);
        if (scope_id >= 0) {
            func_name += "_s" + std::to_string(scope_id);
        }
    } else if (expr->operand) {
        func_name = gen_expr(expr->operand);
    }

    // Handle method calls with receivers - add them as first arguments
    if (!expr->receivers.empty()) {
        for (size_t i = 0; i < expr->receivers.size(); i++) {
            ExprPtr rec = expr->receivers[i];
            bool by_ref = receiver_is_mutable_arg(rec);
            if (!ref_key.empty() && i < ref_key.size()) {
                by_ref = ref_key[i] == 'M';
            }
            if (by_ref) {
                if (is_addressable_lvalue(rec) && is_mutable_lvalue(rec)) {
                    all_args.push_back("&" + gen_expr(rec));
                } else {
                    std::string temp = fresh_temp();
                    std::string rtype = rec && rec->type ? gen_type(rec->type) : "int";
                    emit(rtype + " " + temp + " = " + gen_expr(rec) + ";");
                    all_args.push_back("&" + temp);
                }
            } else {
                all_args.push_back(gen_expr(rec));
            }
        }
    }

    // Add regular arguments (skip expression parameters)
    size_t param_idx = 0;
    for (size_t i = 0; i < expr->args.size(); i++) {
        // Check if this argument corresponds to an expression parameter
        if (type_checker && expr->operand && expr->operand->kind == Expr::Kind::Identifier) {
            Symbol* sym = type_checker->get_scope()->lookup(expr->operand->name);
            if (sym && sym->kind == Symbol::Kind::Function && sym->declaration &&
                param_idx < sym->declaration->params.size() &&
                sym->declaration->params[param_idx].is_expression_param) {
                param_idx++;
                continue;  // Skip expression parameters
            }
        }
        all_args.push_back(gen_expr(expr->args[i]));
        param_idx++;
    }

    std::string result = func_name + "(";
    for (size_t i = 0; i < all_args.size(); i++) {
        if (i > 0) result += ", ";
        result += all_args[i];
    }
    result += ")";
    return result;
}

std::string CodeGenerator::gen_index(ExprPtr expr) {
    std::string arr = gen_expr(expr->operand);
    std::string idx = gen_expr(expr->args[0]);
    return arr + "[" + idx + "]";
}

std::string CodeGenerator::gen_member(ExprPtr expr) {
    bool operand_is_ref = false;
    std::string obj;
    if (expr->operand && expr->operand->kind == Expr::Kind::Identifier &&
        current_ref_params.count(expr->operand->name)) {
        operand_is_ref = true;
        obj = mangle_name(expr->operand->name);
        int scope_id = expr->operand->scope_instance_id;
        if (scope_id < 0 && type_checker) {
            Symbol* sym = type_checker->get_scope()->lookup(expr->operand->name);
            if (sym && sym->scope_instance_id >= 0) {
                scope_id = sym->scope_instance_id;
            }
        }
        if (scope_id >= 0) {
            obj += "_s" + std::to_string(scope_id);
        }
    } else {
        obj = gen_expr(expr->operand);
    }

    // Check if the operand is a reference parameter (pointer in C)
    std::string accessor = operand_is_ref ? "->" : ".";

    // Don't mangle compiler-generated tuple field names (e.g., __0, __1)
    std::string member_name = expr->name;
    if (member_name.size() < 2 || member_name.substr(0, 2) != MANGLED_PREFIX) {
        member_name = mangle_name(member_name);
    }

    return obj + accessor + member_name;
}

std::string CodeGenerator::gen_array_literal(ExprPtr expr) {
    std::string temp = fresh_temp();

    // Determine element type
    std::string elem_type = "int";
    if (expr->type && expr->type->kind == Type::Kind::Array && expr->type->element_type) {
        elem_type = gen_type(expr->type->element_type);
    }

    size_t count = expr->elements.size();
    size_t storage_count = count == 0 ? 1 : count;
    // Generate array declaration and initialization
    // Use static to ensure it persists beyond the current scope (important for struct fields)
    emit("static " + elem_type + " " + temp + "[" + std::to_string(storage_count) + "] = {");
    for (size_t i = 0; i < count; i++) {
        if (i > 0) emit(", ");
        emit(gen_expr(expr->elements[i]));
    }
    emit("};");

    return temp;
}

std::string CodeGenerator::gen_tuple_literal(ExprPtr expr) {
    // Generate tuple struct literal: (Type){.field0 = val0, .field1 = val1, ...}
    std::string type_name = expr->type ? gen_type(expr->type) : "void*";

    // Track this tuple type for declaration generation
    if (expr->type && expr->type->kind == Type::Kind::Named) {
        std::string tuple_name = expr->type->type_name;
        if (tuple_name.find(TUPLE_TYPE_PREFIX) == 0 && !tuple_types.count(tuple_name)) {
            // Collect element types
            std::vector<TypePtr> elem_types;
            for (const auto& elem : expr->elements) {
                elem_types.push_back(elem->type);
            }
            tuple_types[tuple_name] = elem_types;
        }
    }

    std::string result = "((" + type_name + "){";
    for (size_t i = 0; i < expr->elements.size(); i++) {
        if (i > 0) result += ", ";
        result += ".__" + std::to_string(i) + " = ";
        result += gen_expr(expr->elements[i]);
    }
    result += "})";

    return result;
}

std::string CodeGenerator::gen_block(ExprPtr expr) {
    // If block has no result expression, don't create a temp
    if (!expr->result_expr) {
        emit("{");
        for (const auto& stmt : expr->statements) {
            gen_stmt(stmt);
        }
        emit("}");
        return "";  // No result value
    }

    std::string temp = fresh_temp();
    std::string result_type;

    // Infer result type from expression type or result_expr type
    if (expr->type) {
        result_type = gen_type(expr->type);
    } else if (expr->result_expr && expr->result_expr->type) {
        result_type = gen_type(expr->result_expr->type);
    } else {
        result_type = "int";  // Safe default for unknown types
    }

    // Declare temp variable outside block scope only if not already declared
    if (!declared_temps.count(temp)) {
        emit(storage_prefix() + result_type + " " + temp + ";");
        declared_temps.insert(temp);
    }

    emit("{");
    for (const auto& stmt : expr->statements) {
        gen_stmt(stmt);
    }

    std::string result = gen_expr(expr->result_expr);
    emit(temp + " = " + result + ";");
    // Release the result temp if it's a temporary
    if (result.substr(0, 3) == "tmp") {
        release_temp(result);
    }
    emit("}");

    return temp;
}

std::string CodeGenerator::gen_block_optimized(ExprPtr expr) {
    if (!type_checker) return "";

    CompileTimeEvaluator evaluator(type_checker);
    std::ostringstream optimized;

    // Process each statement
    for (const auto& stmt : expr->statements) {
        if (stmt->kind == Stmt::Kind::Expr && stmt->expr) {
            // Handle assignment expressions
            if (stmt->expr->kind == Expr::Kind::Assignment &&
                stmt->expr->left->kind == Expr::Kind::Identifier) {

                std::string var_name = stmt->expr->left->name;

                // Try to evaluate RHS at compile-time
                CTValue rhs_val;
                if (evaluator.try_evaluate(stmt->expr->right, rhs_val)) {
                    // Store compile-time value in evaluator, don't generate code
                    evaluator.set_constant(var_name, rhs_val);
                    continue;
                }
                // Can't evaluate - must generate runtime code
                return "";
            }

            // Handle other expressions (like function calls)
            // Check if it's a call to external function
            if (stmt->expr->kind == Expr::Kind::Call) {
                // Try to evaluate arguments and generate optimized call
                std::string call_str = gen_call_optimized_with_evaluator(stmt->expr, evaluator);
                if (!call_str.empty()) {
                    optimized << call_str << ";\n";
                    continue;
                }
                // Can't optimize, bail out
                return "";
            }

            // Try to evaluate other expressions with current compile-time context
            CTValue stmt_val;
            if (!evaluator.try_evaluate(stmt->expr, stmt_val)) {
                return "";
            }
        } else if (stmt->kind == Stmt::Kind::VarDecl) {
            // Try to evaluate initializer
            if (stmt->var_init) {
                CTValue init_val;
                if (evaluator.try_evaluate(stmt->var_init, init_val)) {
                    evaluator.set_constant(stmt->var_name, init_val);
                    continue;
                } else {
                    // Can't evaluate (e.g., array literal)
                    // Store a placeholder so references to this variable won't fail
                    evaluator.set_constant(stmt->var_name, (int64_t)0);
                    // Don't generate code for it - we'll inline everything
                    continue;
                }
            }
        } else {
            // Can't handle this statement type
            return "";
        }
    }

    // Try to evaluate result expression
    if (expr->result_expr) {
        CTValue result_val;
        if (evaluator.try_evaluate(expr->result_expr, result_val)) {
            if (std::holds_alternative<int64_t>(result_val)) {
                optimized << "return " << std::get<int64_t>(result_val) << ";\n";
                return optimized.str();
            } else if (std::holds_alternative<uint64_t>(result_val)) {
                optimized << "return " << std::get<uint64_t>(result_val) << ";\n";
                return optimized.str();
            }
        }
    }

    return "";
}

std::string CodeGenerator::gen_call_optimized_with_evaluator(ExprPtr expr, CompileTimeEvaluator& evaluator) {
    if (!expr || expr->kind != Expr::Kind::Call) return "";
    if (!expr->operand || expr->operand->kind != Expr::Kind::Identifier) return "";

    std::string func_name = expr->operand->name;

    // Check if it's an external function
    Symbol* sym = type_checker->get_scope()->lookup(func_name);
    if (!sym || sym->kind != Symbol::Kind::Function || !sym->declaration) return "";
    if (!sym->declaration->is_external) return "";

    // Try to evaluate all arguments at compile-time
    std::vector<std::string> arg_strs;

    for (const auto& arg : expr->args) {
        CTValue arg_val;
        if (evaluator.try_evaluate(arg, arg_val)) {
            if (std::holds_alternative<int64_t>(arg_val)) {
                arg_strs.push_back(std::to_string(std::get<int64_t>(arg_val)));
            } else if (std::holds_alternative<uint64_t>(arg_val)) {
                arg_strs.push_back(std::to_string(std::get<uint64_t>(arg_val)));
            } else {
                return "";
            }
        } else {
            return "";
        }
    }

    // Generate optimized call
    std::string result = mangle_name(func_name) + "(";
    for (size_t i = 0; i < arg_strs.size(); i++) {
        if (i > 0) result += ", ";
        result += arg_strs[i];
    }
    result += ")";
    return result;
}

std::string CodeGenerator::gen_conditional(ExprPtr expr) {
    // Try to evaluate condition at compile time for dead branch elimination
    if (type_checker) {
        CompileTimeEvaluator evaluator(type_checker);
        CTValue cond_val;
        if (evaluator.try_evaluate(expr->condition, cond_val)) {
            // Condition is compile-time constant - eliminate dead branch
            bool is_true = false;
            if (std::holds_alternative<int64_t>(cond_val)) {
                is_true = std::get<int64_t>(cond_val) != 0;
            } else if (std::holds_alternative<bool>(cond_val)) {
                is_true = std::get<bool>(cond_val);
            } else if (std::holds_alternative<uint64_t>(cond_val)) {
                is_true = std::get<uint64_t>(cond_val) != 0;
            }

            if (is_true) {
                return gen_expr(expr->true_expr);
            } else {
                return gen_expr(expr->false_expr);
            }
        }
    }

    // Runtime conditional
    std::string cond = gen_expr(expr->condition);
    std::string true_expr = gen_expr(expr->true_expr);
    std::string false_expr = gen_expr(expr->false_expr);
    return "(" + cond + " ? " + true_expr + " : " + false_expr + ")";
}

std::string CodeGenerator::gen_cast(ExprPtr expr) {
    // Primitive to byte array conversion (big-endian order)
    if (expr->target_type && expr->target_type->kind == Type::Kind::Array &&
        expr->target_type->element_type &&
        expr->target_type->element_type->kind == Type::Kind::Primitive &&
        expr->target_type->element_type->primitive == PrimitiveType::U8 &&
        expr->operand && expr->operand->type &&
        expr->operand->type->kind == Type::Kind::Primitive &&
        !is_float(expr->operand->type->primitive)) {

        int64_t length = resolve_array_length(expr->target_type, expr->location);
        int bits = type_bits(expr->operand->type->primitive);
        if (bits / 8 != length) {
            throw CompileError("Array length/type size mismatch in cast", expr->location);
        }

        std::string source_val = gen_expr(expr->operand);
        std::string source_tmp = fresh_temp();
        std::string source_type = gen_type(expr->operand->type);
        if (!declared_temps.count(source_tmp)) {
            emit(storage_prefix() + source_type + " " + source_tmp + ";");
            declared_temps.insert(source_tmp);
        }
        emit(source_tmp + " = " + source_val + ";");

        std::string result = fresh_temp();
        std::string elem_type = gen_type(expr->target_type->element_type);
        std::string size_str = std::to_string(length);
        if (!declared_temps.count(result)) {
            emit(storage_prefix() + elem_type + " " + result + "[" + size_str + "];");
            declared_temps.insert(result);
        }

        for (int64_t i = 0; i < length; ++i) {
            int64_t shift = (length - 1 - i) * 8;
            emit(result + "[" + std::to_string(i) + "] = (" + elem_type + ")((" + source_tmp +
                 " >> " + std::to_string(shift) + ") & 0xFF);");
        }

        return result;
    }

    // Special-case: pack boolean arrays into unsigned integers
    if (expr->operand && expr->operand->type &&
        expr->operand->type->kind == Type::Kind::Array &&
        expr->operand->type->element_type &&
        expr->operand->type->element_type->kind == Type::Kind::Primitive &&
        expr->operand->type->element_type->primitive == PrimitiveType::Bool &&
        expr->target_type && expr->target_type->kind == Type::Kind::Primitive &&
        is_unsigned_int(expr->target_type->primitive)) {

        int64_t length = resolve_array_length(expr->operand->type, expr->location);
        std::string target = gen_type(expr->target_type);
        std::string source = gen_expr(expr->operand);
        std::string temp = fresh_temp();
        if (!declared_temps.count(temp)) {
            emit(storage_prefix() + target + " " + temp + ";");
            declared_temps.insert(temp);
        }
        emit(temp + " = 0;");
        for (int64_t i = 0; i < length; ++i) {
            int64_t shift = (length - 1 - i);
            emit(temp + " |= (" + source + "[" + std::to_string(i) + "] ? (" + target + ")(1u << " + std::to_string(shift) + ") : 0);");
        }
        return temp;
    }

    std::string target = gen_type(expr->target_type);
    std::string operand = gen_expr(expr->operand);
    return "((" + target + ")" + operand + ")";
}

std::string CodeGenerator::gen_assignment(ExprPtr expr) {
    // Use the flag set by the typechecker to determine if this creates a new variable
    if (expr->creates_new_variable) {
        TypePtr var_type = expr->left->type ? expr->left->type : expr->type;
        std::string var_type_str = gen_type(var_type);
        std::string var_name = mangle_name(expr->left->name);

        // For array declarations, we need to handle the literal specially
        if (var_type && var_type->kind == Type::Kind::Array && expr->right->kind == Expr::Kind::ArrayLiteral) {
            // Generate array literal inline with correct type
            std::string elem_type = gen_type(var_type->element_type);

            // Get array size
            std::string size_str = "0";
            if (type_checker && var_type->array_size) {
                CompileTimeEvaluator evaluator(type_checker);
                CTValue size_val;
                if (evaluator.try_evaluate(var_type->array_size, size_val)) {
                    size_str = std::to_string(std::get<int64_t>(size_val));
                }
            }

            emit(elem_type + " " + var_name + "[" + size_str + "] = {");
            for (size_t i = 0; i < expr->right->elements.size(); i++) {
                if (i > 0) emit(", ");
                emit(gen_expr(expr->right->elements[i]));
            }
            emit("};");

            std::string temp = fresh_temp();
            emit(storage_prefix() + std::string("int ") + temp + " = 0;");
            return temp;
        }

        std::string rhs = gen_expr(expr->right);
        // Release RHS temp if it's a temporary
        if (rhs.substr(0, 3) == "tmp") {
            release_temp(rhs);
        }
        std::string temp = fresh_temp();
        emit(var_type_str + " " + var_name + " = " + rhs + ";");
        emit(storage_prefix() + std::string("int ") + temp + " = 0;"); // Assignment as expression returns dummy value
        return temp;
    }

    // Regular assignment
    std::string lhs = gen_expr(expr->left);
    std::string rhs = gen_expr(expr->right);
    // Release RHS temp if it's a temporary
    if (rhs.substr(0, 3) == "tmp") {
        release_temp(rhs);
    }
    return "(" + lhs + " = " + rhs + ")";
}

std::optional<std::pair<int64_t, int64_t>> CodeGenerator::evaluate_range(ExprPtr range_expr) {
    if (!range_expr || range_expr->kind != Expr::Kind::Range) {
        return std::nullopt;
    }

    if (!type_checker) return std::nullopt;

    CompileTimeEvaluator evaluator(type_checker);
    CTValue start_val, end_val;
    if (evaluator.try_evaluate(range_expr->left, start_val) &&
        evaluator.try_evaluate(range_expr->right, end_val)) {
        return std::make_pair(std::get<int64_t>(start_val), std::get<int64_t>(end_val));
    }
    return std::nullopt;
}

std::string CodeGenerator::gen_range(ExprPtr expr) {
    auto bounds = evaluate_range(expr);
    if (!bounds) {
        throw CompileError("Range bounds must be compile-time constants", expr->location);
    }

    int64_t start = bounds->first;
    int64_t end = bounds->second;

    if (start == end) {
        throw CompileError("Range cannot produce an empty array; bounds must differ", expr->location);
    }

    std::string temp = fresh_temp();
    std::string elem_type = "int32_t";
    if (expr->type && expr->type->kind == Type::Kind::Array && expr->type->element_type) {
        elem_type = gen_type(expr->type->element_type);
    }

    int64_t size = (start < end) ? (end - start) : (start - end);
    if (size <= 0) {
        throw CompileError("Invalid range bounds", expr->location);
    }

    std::ostringstream init;
    init << storage_prefix() << elem_type << " " << temp << "[" << size << "] = {";
    bool first = true;
    if (start < end) {
        for (int64_t i = start; i < end; ++i) {
            if (!first) init << ", ";
            first = false;
            init << i;
        }
    } else {
        for (int64_t i = start; i > end; --i) {
            if (!first) init << ", ";
            first = false;
            init << i;
        }
    }
    init << "};";
    emit(init.str());
    return temp;
}

std::string CodeGenerator::gen_length(ExprPtr expr) {
    // Array length or absolute value
    if (expr->operand->type) {
        if (expr->operand->type->kind == Type::Kind::Array) {
            // Array length - try to evaluate at compile time
            if (type_checker && expr->operand->type->array_size) {
                CompileTimeEvaluator evaluator(type_checker);
                CTValue size_val;
                if (evaluator.try_evaluate(expr->operand->type->array_size, size_val)) {
                    return std::to_string(std::get<int64_t>(size_val));
                }
            }
            throw CompileError("Array length must be a compile-time constant", expr->location);
        } else if (expr->operand->type->kind == Type::Kind::Primitive &&
                   expr->operand->type->primitive == PrimitiveType::String) {
            // String length - compile time constant
            if (expr->operand->kind == Expr::Kind::StringLiteral) {
                return std::to_string(expr->operand->string_val.size());
            }
            return "strlen(" + gen_expr(expr->operand) + ")";
        }
    }

    // Absolute value for numeric types
    std::string operand = gen_expr(expr->operand);
    if (expr->operand->type && expr->operand->type->kind == Type::Kind::Primitive) {
        if (is_float(expr->operand->type->primitive)) {
            return "fabs(" + operand + ")";
        } else if (is_signed_int(expr->operand->type->primitive)) {
            return "abs(" + operand + ")";
        } else {
            // Unsigned - identity
            return operand;
        }
    }
    return "abs(" + operand + ")";
}

std::string CodeGenerator::gen_iteration(ExprPtr expr) {
    if (!expr->operand || !expr->operand->type || expr->operand->type->kind != Type::Kind::Array) {
        throw CompileError("Iteration requires array or range", expr->location);
    }

    TypePtr array_type = expr->operand->type;
    TypePtr element_type = array_type->element_type;
    std::string element_c_type = element_type ? gen_type(element_type) : "int32_t";

    std::string size_str;
    int64_t element_count = 0;
    auto value_to_int64 = [&](const CTValue& v, const SourceLocation& loc) -> int64_t {
        if (std::holds_alternative<int64_t>(v)) {
            return std::get<int64_t>(v);
        }
        if (std::holds_alternative<uint64_t>(v)) {
            return static_cast<int64_t>(std::get<uint64_t>(v));
        }
        throw CompileError("Iteration bounds must be integer constants", loc);
    };

    if (expr->operand->kind == Expr::Kind::Range) {
        if (!type_checker) {
            throw CompileError("Internal error: range iteration without type checker", expr->location);
        }
        CompileTimeEvaluator evaluator(type_checker);
        CTValue start_val, end_val;
        if (!evaluator.try_evaluate(expr->operand->left, start_val) ||
            !evaluator.try_evaluate(expr->operand->right, end_val)) {
            throw CompileError("Range iteration requires compile-time constant bounds", expr->location);
        }
        int64_t start = value_to_int64(start_val, expr->operand->left->location);
        int64_t end = value_to_int64(end_val, expr->operand->right->location);
        element_count = (start < end) ? (end - start) : (start - end);
        if (element_count <= 0) {
            throw CompileError("Range iteration produced empty sequence", expr->location);
        }
        size_str = std::to_string(element_count);
    } else {
        if (!type_checker || !array_type->array_size) {
            throw CompileError("Array size must be compile-time constant for iteration", expr->location);
        }
        CompileTimeEvaluator evaluator(type_checker);
        CTValue size_val;
        if (!evaluator.try_evaluate(array_type->array_size, size_val)) {
            throw CompileError("Array size must be compile-time constant for iteration", expr->location);
        }
        element_count = value_to_int64(size_val, array_type->array_size->location);
        if (element_count < 0) {
            throw CompileError("Array size cannot be negative", expr->location);
        }
        size_str = std::to_string(element_count);
    }

    std::string array_expr = gen_expr(expr->operand);
    std::string array_ptr = fresh_temp();
    std::string loop_var = fresh_temp();
    std::string underscore = fresh_temp();

    emit("{");
    emit("  " + element_c_type + "* " + array_ptr + " = " + array_expr + ";");

    if (expr->is_sorted_iteration && element_count > 1) {
        if (!element_type) {
            throw CompileError("Cannot sort array with unknown element type", expr->location);
        }
        std::string copy_var = fresh_temp();
        std::string sort_buffer = fresh_temp();
        std::string cmp_name = ensure_comparator(element_type);
        std::string i_var = fresh_temp();
        std::string j_var = fresh_temp();
        std::string key_var = fresh_temp();

        emit("  " + storage_prefix() + element_c_type + " " + sort_buffer + "[" + size_str + "];");
        emit("  for (int " + copy_var + " = 0; " + copy_var + " < " + size_str + "; " + copy_var + "++) {");
        emit("    " + sort_buffer + "[" + copy_var + "] = " + array_ptr + "[" + copy_var + "];");
        emit("  }");
        emit("  for (int " + i_var + " = 1; " + i_var + " < " + size_str + "; " + i_var + "++) {");
        emit("    " + element_c_type + " " + key_var + " = " + sort_buffer + "[" + i_var + "];");
        emit("    int " + j_var + " = " + i_var + " - 1;");
        emit("    while (" + j_var + " >= 0 && " + cmp_name + "(" + sort_buffer + "[" + j_var + "], " + key_var + ") > 0) {");
        emit("      " + sort_buffer + "[" + j_var + " + 1] = " + sort_buffer + "[" + j_var + "];");
        emit("      " + j_var + " = " + j_var + " - 1;");
        emit("    }");
        emit("    " + sort_buffer + "[" + j_var + " + 1] = " + key_var + ";");
        emit("  }");
        emit("  " + array_ptr + " = " + sort_buffer + ";");
    }

    emit("  for (int " + loop_var + " = 0; " + loop_var + " < " + size_str + "; " + loop_var + "++) {");
    emit("    " + element_c_type + " " + underscore + " = " + array_ptr + "[" + loop_var + "];");

    std::string saved_underscore = underscore_var;
    underscore_var = underscore;

    std::string body_code = gen_expr(expr->right);
    emit("    " + body_code + ";");

    underscore_var = saved_underscore;

    emit("  }");
    emit("}");

    return "";
}

std::string CodeGenerator::gen_repeat(ExprPtr expr) {
    std::string cond = gen_expr(expr->condition);
    emit("while (" + cond + ") {");
    emit("  " + gen_expr(expr->right) + ";");
    emit("}");
    return "";
}

std::string CodeGenerator::gen_type(TypePtr type) {
    if (!type) return "void";

    switch (type->kind) {
        case Type::Kind::Primitive:
            switch (type->primitive) {
                case PrimitiveType::I8: return "int8_t";
                case PrimitiveType::I16: return "int16_t";
                case PrimitiveType::I32: return "int32_t";
                case PrimitiveType::I64: return "int64_t";
                case PrimitiveType::U8: return "uint8_t";
                case PrimitiveType::U16: return "uint16_t";
                case PrimitiveType::U32: return "uint32_t";
                case PrimitiveType::U64: return "uint64_t";
                case PrimitiveType::F32: return "float";
                case PrimitiveType::F64: return "double";
                case PrimitiveType::Bool: return "_Bool";
                case PrimitiveType::String: return "const char*";
            }
            break;

        case Type::Kind::Array: {
            std::string elem = gen_type(type->element_type);
            // Simplified: size would need compile-time evaluation
            return elem + "*";
        }

        case Type::Kind::Named:
            if (type_map.count(type->type_name)) {
                return type_map[type->type_name];
            }
            return mangle_name(type->type_name);

        case Type::Kind::TypeVar:
            // TypeVars appear when types aren't explicitly annotated
            // Default to int32_t as a reasonable default for untyped fields
            return "int32_t";
    }

    return "void";
}

std::string CodeGenerator::mangle_name(const std::string& name) {
    // Special case: main function doesn't get mangled
    if (name == "main") {
        return "main";
    }

    std::string result = "vx_";
    auto append_encoded = [&](unsigned char c) {
        if (std::isalnum(c) || c == '_') {
            result.push_back(static_cast<char>(c));
        } else {
            std::ostringstream oss;
            oss << "_" << std::uppercase << std::hex << std::setw(2) << std::setfill('0')
                << static_cast<int>(c);
            result += oss.str();
        }
    };

    // Replace :: with __ for method names
    for (size_t i = 0; i < name.size(); i++) {
        if (i + 1 < name.size() && name[i] == ':' && name[i+1] == ':') {
            result += MANGLED_PREFIX;
            i++; // Skip the second :
        } else {
            append_encoded(static_cast<unsigned char>(name[i]));
        }
    }
    return result;
}

std::string CodeGenerator::fresh_temp() {
    if (!available_temps.empty()) {
        std::string temp = available_temps.top();
        available_temps.pop();
        live_temps.insert(temp);
        return temp;
    }
    std::string temp = "tmp" + std::to_string(temp_counter++);
    live_temps.insert(temp);
    return temp;
}

void CodeGenerator::release_temp(const std::string& temp) {
    if (live_temps.count(temp)) {
        live_temps.erase(temp);
        available_temps.push(temp);
    }
}

void CodeGenerator::emit(const std::string& code) {
    if (output_stack.empty()) {
        output_stack.push(&body);
    }
    (*output_stack.top()) << code << "\n";
}

void CodeGenerator::emit_header(const std::string& code) {
    header << code << "\n";
}

std::string CodeGenerator::storage_prefix() const {
    return current_function_non_reentrant ? "static " : "";
}

int64_t CodeGenerator::resolve_array_length(TypePtr type, const SourceLocation& loc) {
    if (!type || type->kind != Type::Kind::Array || !type->array_size) {
        throw CompileError("Cannot determine array length for comparator generation", loc);
    }
    if (!type_checker) {
        throw CompileError("Internal error: array length requested without type checker", loc);
    }

    CompileTimeEvaluator evaluator(type_checker);
    CTValue size_val;
    if (!evaluator.try_evaluate(type->array_size, size_val)) {
        throw CompileError("Array length must be compile-time constant", loc);
    }

    if (std::holds_alternative<int64_t>(size_val)) {
        return std::get<int64_t>(size_val);
    }
    if (std::holds_alternative<uint64_t>(size_val)) {
        return static_cast<int64_t>(std::get<uint64_t>(size_val));
    }

    throw CompileError("Array length must be an integer constant", loc);
}

std::string CodeGenerator::ensure_comparator(TypePtr type) {
    if (!type) {
        throw CompileError("Cannot compare value of unknown type", SourceLocation());
    }

    std::string key = type->to_string();
    auto it = comparator_cache.find(key);
    if (it != comparator_cache.end()) {
        return it->second;
    }

    std::string func_name = "vx_cmp_" + sanitize_identifier(key) + "_" + std::to_string(comparator_cache.size());
    comparator_cache[key] = func_name;

    std::ostringstream fn;
    fn << "static int " << func_name << "(" << gen_type(type) << " lhs, " << gen_type(type) << " rhs) {\n";

    switch (type->kind) {
        case Type::Kind::Primitive: {
            if (type->primitive == PrimitiveType::String) {
                fn << "    if (!lhs && !rhs) return 0;\n";
                fn << "    if (!lhs) return -1;\n";
                fn << "    if (!rhs) return 1;\n";
                fn << "    int cmp = strcmp(lhs, rhs);\n";
                fn << "    if (cmp < 0) return -1;\n";
                fn << "    if (cmp > 0) return 1;\n";
                fn << "    return 0;\n";
            } else {
                fn << "    if (lhs < rhs) return -1;\n";
                fn << "    if (lhs > rhs) return 1;\n";
                fn << "    return 0;\n";
            }
            break;
        }
        case Type::Kind::Array: {
            int64_t length = resolve_array_length(type, type->location);
            std::string elem_cmp = ensure_comparator(type->element_type);
            fn << "    for (int i = 0; i < " << length << "; ++i) {\n";
            fn << "        int cmp = " << elem_cmp << "(lhs[i], rhs[i]);\n";
            fn << "        if (cmp != 0) return cmp;\n";
            fn << "    }\n";
            fn << "    return 0;\n";
            break;
        }
        case Type::Kind::Named: {
            if (!type_checker) {
                throw CompileError("Internal error: comparator generation without type checker", type->location);
            }
            Symbol* sym = type_checker->get_scope()->lookup(type->type_name);
            if (!sym || sym->kind != Symbol::Kind::Type || !sym->declaration || sym->declaration->kind != Stmt::Kind::TypeDecl) {
                throw CompileError("Cannot compare values of type " + type->type_name, type->location);
            }
            auto decl = sym->declaration;
            fn << "    int cmp;\n";
            for (const auto& field : decl->fields) {
                if (!field.type) {
                    throw CompileError("Field type inference required before comparison for " + field.name, field.location);
                }
                std::string field_cmp = ensure_comparator(field.type);
                fn << "    cmp = " << field_cmp << "(lhs." << mangle_name(field.name) << ", rhs." << mangle_name(field.name) << ");\n";
                fn << "    if (cmp != 0) return cmp;\n";
            }
            fn << "    return 0;\n";
            break;
        }
        case Type::Kind::TypeVar:
            throw CompileError("Cannot compare generic type without concrete instantiation", type->location);
    }

    fn << "}\n";
    comparator_definitions.push_back(fn.str());
    return func_name;
}

}
