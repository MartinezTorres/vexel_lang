#include "codegen.h"
#include "analysis.h"
#include "evaluator.h"
#include "expr_access.h"
#include "function_key.h"
#include "optimizer.h"
#include "typechecker.h"
#include "constants.h"
#include <algorithm>
#include <functional>
#include <iomanip>
#include <cctype>
#include <tuple>
#include <sstream>
#include <deque>

namespace {
std::string escape_c_string(const std::string& input) {
    std::ostringstream oss;
    oss << std::hex << std::setfill('0');
    for (unsigned char c : input) {
        switch (c) {
            case '\\':
                oss << "\\\\";
                break;
            case '"':
                oss << "\\\"";
                break;
            case '\n':
                oss << "\\n";
                break;
            case '\r':
                oss << "\\r";
                break;
            case '\t':
                oss << "\\t";
                break;
            default:
                if (c >= 0x20 && c <= 0x7e) {
                    oss << static_cast<char>(c);
                } else {
                    oss << "\\x" << std::uppercase << std::setw(2) << static_cast<int>(c) << std::nouppercase;
                }
                break;
        }
    }
    return oss.str();
}

std::string sanitize_identifier(const std::string& input) {
    std::string result;
    result.reserve(input.size());
    for (unsigned char c : input) {
        if (std::isalnum(c)) {
            result.push_back(static_cast<char>(c));
        } else {
            result.push_back('_');
        }
    }
    if (result.empty() || std::isdigit(static_cast<unsigned char>(result.front()))) {
        result.insert(result.begin(), '_');
    }
    return result;
}

}

namespace vexel {

static std::string render_annotation_comment(const std::vector<Annotation>& anns) {
    if (anns.empty()) return "";
    std::ostringstream os;
    os << "// Annotations:";
    for (const auto& ann : anns) {
        os << " [[" << ann.name;
        if (!ann.args.empty()) {
            os << "(";
            for (size_t i = 0; i < ann.args.size(); ++i) {
                if (i > 0) os << ", ";
                os << ann.args[i];
            }
            os << ")";
        }
        os << "]]";
    }
    return os.str();
}

CodeGenerator::CodeGenerator() : temp_counter(0), type_checker(nullptr), in_function(false) {
    output_stack.push(&body);
}

CCodegenResult CodeGenerator::generate(const Module& mod, TypeChecker* tc,
                                       const AnalysisFacts* analysis,
                                       const OptimizationFacts* optimization_facts) {
    type_checker = tc;

    header.str("");
    header.clear();
    body.str("");
    body.clear();
    generated_functions.clear();
    generated_vars.clear();
    current_ref_params.clear();
    facts = AnalysisFacts{};
    optimization = optimization_facts;
    current_reentrancy_key = 'N';
    current_module_id_expr = "0";
    current_bank_page = 'A';
    current_func_key.clear();
    current_variant_id.clear();
    current_variant_name_override.clear();
    current_instance_id = -1;
    current_func_symbol = nullptr;
    current_returns_aggregate = false;
    aggregate_out_param.clear();
    aggregate_out_type.clear();
    current_aggregate_params.clear();
    tuple_types.clear();
    expr_param_substitutions.clear();
    value_param_replacements.clear();
    underscore_var.clear();
    if (tc) {
        for (const auto& pair : tc->get_forced_tuple_types()) {
            tuple_types[pair.first] = pair.second;
        }
    }
    comparator_cache.clear();
    comparator_definitions.clear();
    while (!output_stack.empty()) output_stack.pop();
    output_stack.push(&body);

    entry_instance_id = 0;
    if (tc) {
        Program* program = tc->get_program();
        if (program && !program->instances.empty()) {
            entry_instance_id = program->instances.front().id;
        }
    }

    emit_header("// Generated by Vexel compiler");
    emit_header("// https://github.com/vexel-lang/vexel");
    emit_header("// Dead code elimination: only reachable functions and referenced globals/types are generated");
    emit_header("");
    emit_header("#pragma once");
    emit_header("");
    emit_header("#include <stdint.h>");
    emit_header("#include <stdbool.h>");
    emit_header("#include <string.h>");
    emit_header("#include <stdlib.h>");
    emit_header("#include <math.h>");
    emit_header("");
    emit_header("#ifndef VX_MUTABLE");
    emit_header("#define VX_MUTABLE");
    emit_header("#endif");
    emit_header("#ifndef VX_NON_MUTABLE");
    emit_header("#define VX_NON_MUTABLE const");
    emit_header("#endif");
    emit_header("#ifndef VX_CONSTEXPR");
    emit_header("#define VX_CONSTEXPR const");
    emit_header("#endif");
    emit_header("#ifndef VX_REENTRANT");
    emit_header("#define VX_REENTRANT");
    emit_header("#endif");
    emit_header("#ifndef VX_NON_REENTRANT");
    emit_header("#define VX_NON_REENTRANT");
    emit_header("#endif");
    emit_header("#ifndef VX_REF_MASK");
    emit_header("#define VX_REF_MASK(x)");
    emit_header("#endif");
    emit_header("#ifndef VX_ENTRYPOINT");
    emit_header("#define VX_ENTRYPOINT");
    emit_header("#endif");
    emit_header("#ifndef VX_INLINE");
    emit_header("#define VX_INLINE");
    emit_header("#endif");
    emit_header("#ifndef VX_NOINLINE");
    emit_header("#define VX_NOINLINE");
    emit_header("#endif");
    emit_header("#ifndef VX_PURE");
    emit_header("#define VX_PURE");
    emit_header("#endif");
    emit_header("#ifndef VX_NO_GLOBAL_WRITE");
    emit_header("#define VX_NO_GLOBAL_WRITE");
    emit_header("#endif");
    emit_header("");

    if (analysis) {
        facts = *analysis;
    } else {
        Analyzer analyzer(type_checker);
        facts = analyzer.run(mod);
    }

    validate_codegen_invariants(mod);

    gen_module(mod);

    CCodegenResult result;
    result.header = header.str();
    if (comparator_definitions.empty()) {
        result.source = body.str();
    } else {
        std::ostringstream combined;
        for (const auto& helper : comparator_definitions) {
            combined << helper << "\n";
        }
        combined << body.str();
        result.source = combined.str();
    }
    return result;
}

GeneratedFunctionInfo CodeGenerator::generate_single_function(const Module& mod,
                                                              StmtPtr func,
                                                              TypeChecker* tc,
                                                              const AnalysisFacts* analysis,
                                                              const OptimizationFacts* optimization_facts,
                                                              const CodegenABI& options,
                                                              int instance_id,
                                                              const std::string& ref_key,
                                                              char reent_key,
                                                              const std::string& variant_name_override,
                                                              const std::string& variant_id_override) {
    type_checker = tc;
    abi = options;

    header.str("");
    header.clear();
    body.str("");
    body.clear();
    generated_functions.clear();
    generated_vars.clear();
    current_ref_params.clear();
    current_aggregate_params.clear();
    facts = AnalysisFacts{};
    optimization = optimization_facts;
    current_reentrancy_key = reent_key;
    current_module_id_expr = "0";
    current_bank_page = 'A';
    current_func_key.clear();
    current_variant_id = variant_id_override;
    current_variant_name_override = variant_name_override;
    current_instance_id = instance_id;
    current_func_symbol = nullptr;
    current_returns_aggregate = false;
    aggregate_out_param.clear();
    aggregate_out_type.clear();
    tuple_types.clear();
    expr_param_substitutions.clear();
    value_param_replacements.clear();
    underscore_var.clear();
    if (tc) {
        for (const auto& pair : tc->get_forced_tuple_types()) {
            tuple_types[pair.first] = pair.second;
        }
    }
    comparator_cache.clear();
    comparator_definitions.clear();
    while (!output_stack.empty()) output_stack.pop();
    output_stack.push(&body);
    temp_counter = 0;
    while (!available_temps.empty()) available_temps.pop();
    live_temps.clear();
    declared_temps.clear();

    int saved_instance = -1;
    if (tc) {
        saved_instance = tc->current_instance();
        tc->set_current_instance(instance_id);
        Program* program = tc->get_program();
        if (program && !program->instances.empty()) {
            entry_instance_id = program->instances.front().id;
        } else {
            entry_instance_id = 0;
        }
    } else {
        entry_instance_id = 0;
    }

    if (analysis) {
        facts = *analysis;
    } else {
        Analyzer analyzer(type_checker);
        facts = analyzer.run(mod);
    }

    validate_codegen_invariants(func);

    if (func) {
        gen_func_decl(func, ref_key, reent_key);
    }

    if (!generated_functions.empty()) {
        if (tc) {
            tc->set_current_instance(saved_instance);
        }
        return generated_functions.back();
    }
    if (tc) {
        tc->set_current_instance(saved_instance);
    }
    return GeneratedFunctionInfo{};
}

void CodeGenerator::validate_codegen_invariants(const Module& mod) {
    Program* program = type_checker ? type_checker->get_program() : nullptr;
    int saved_instance = type_checker ? type_checker->current_instance() : -1;

    auto set_instance = [&](int instance_id) {
        current_instance_id = instance_id;
        if (type_checker) {
            type_checker->set_current_instance(instance_id);
        }
    };

    auto validate_module = [&](const Module& module) {
        validate_codegen_invariants_impl(module.top_level, true, true);
    };

    if (program) {
        for (const auto& instance : program->instances) {
            set_instance(instance.id);
            const Module& module = program->modules[static_cast<size_t>(instance.module_id)].module;
            validate_module(module);
        }
    } else {
        set_instance(-1);
        validate_module(mod);
    }

    if (type_checker) {
        type_checker->set_current_instance(saved_instance);
    }
}

void CodeGenerator::validate_codegen_invariants(StmtPtr func) {
    if (!func) return;
    std::vector<StmtPtr> stmts = {func};
    validate_codegen_invariants_impl(stmts, false, true);
}

void CodeGenerator::validate_codegen_invariants_impl(const std::vector<StmtPtr>& stmts,
                                                     bool use_facts,
                                                     bool top_level) {
    std::function<void(ExprPtr, bool)> validate_expr;
    std::function<void(StmtPtr, bool)> validate_stmt;

    validate_expr = [&](ExprPtr expr, bool value_required) {
        if (!expr) return;
        bool allow_untyped = expr->kind == Expr::Kind::ArrayLiteral && expr->elements.empty();
        if (value_required && !expr->is_expr_param_ref && !allow_untyped && !expr->type) {
            throw CompileError("Internal error: missing type before code generation", expr->location);
        }

        switch (expr->kind) {
            case Expr::Kind::Binary:
                validate_expr(expr->left, true);
                validate_expr(expr->right, true);
                break;
            case Expr::Kind::Unary:
            case Expr::Kind::Cast:
            case Expr::Kind::Length:
                validate_expr(expr->operand, true);
                break;
            case Expr::Kind::Call: {
                if (expr->operand && expr->operand->kind != Expr::Kind::Identifier) {
                    validate_expr(expr->operand, true);
                }
                for (const auto& rec : expr->receivers) {
                    validate_expr(rec, true);
                }
                const Symbol* callee = nullptr;
                if (expr->operand && expr->operand->kind == Expr::Kind::Identifier) {
                    callee = binding_for(expr->operand.get());
                }
                size_t param_index = 0;
                for (const auto& arg : expr->args) {
                    if (callee && callee->kind == Symbol::Kind::Function && callee->declaration &&
                        param_index < callee->declaration->params.size() &&
                        callee->declaration->params[param_index].is_expression_param) {
                        ++param_index;
                        continue;
                    }
                    validate_expr(arg, true);
                    ++param_index;
                }
                break;
            }
            case Expr::Kind::Index:
                validate_expr(expr->operand, true);
                if (!expr->args.empty()) {
                    validate_expr(expr->args[0], true);
                }
                break;
            case Expr::Kind::Member:
                validate_expr(expr->operand, true);
                break;
            case Expr::Kind::ArrayLiteral:
            case Expr::Kind::TupleLiteral:
                for (const auto& elem : expr->elements) {
                    validate_expr(elem, true);
                }
                break;
            case Expr::Kind::Block:
                for (const auto& st : expr->statements) {
                    validate_stmt(st, false);
                }
                validate_expr(expr->result_expr, value_required);
                break;
            case Expr::Kind::Conditional:
                if (type_checker) {
                    auto cond = type_checker->constexpr_condition(expr->condition);
                    if (cond.has_value()) {
                        validate_expr(cond.value() ? expr->true_expr : expr->false_expr, value_required);
                        break;
                    }
                }
                validate_expr(expr->condition, true);
                validate_expr(expr->true_expr, value_required);
                validate_expr(expr->false_expr, value_required);
                break;
            case Expr::Kind::Assignment:
                if (!expr->creates_new_variable) {
                    validate_expr(expr->left, true);
                } else if (expr->left && expr->left->kind != Expr::Kind::Identifier) {
                    validate_expr(expr->left, true);
                }
                validate_expr(expr->right, true);
                break;
            case Expr::Kind::Range:
                validate_expr(expr->left, true);
                validate_expr(expr->right, true);
                break;
            case Expr::Kind::Iteration:
                validate_expr(loop_subject(expr), true);
                validate_expr(loop_body(expr), false);
                break;
            case Expr::Kind::Repeat:
                validate_expr(loop_subject(expr), true);
                validate_expr(loop_body(expr), false);
                break;
            default:
                break;
        }
    };

    validate_stmt = [&](StmtPtr stmt, bool is_top_level) {
        if (!stmt) return;
        switch (stmt->kind) {
            case Stmt::Kind::FuncDecl: {
                if (stmt->is_external) {
                    return;
                }
                Symbol* sym = binding_for(stmt);
                if (use_facts && sym && !facts.reachable_functions.count(sym)) {
                    return;
                }
                if (stmt->body) {
                    bool require_value = stmt->return_type || !stmt->return_types.empty();
                    if (stmt->body->kind == Expr::Kind::Block) {
                        for (const auto& bstmt : stmt->body->statements) {
                            validate_stmt(bstmt, false);
                        }
                        if (stmt->body->result_expr) {
                            validate_expr(stmt->body->result_expr, require_value);
                        }
                    } else {
                        validate_expr(stmt->body, require_value);
                    }
                }
                break;
            }
            case Stmt::Kind::VarDecl: {
                if (!stmt->var_type) {
                    throw CompileError("Internal error: variable '" + stmt->var_name +
                                       "' missing type before code generation", stmt->location);
                }
                bool skip = false;
                if (is_top_level && use_facts) {
                    bool is_exported = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                                   [](const Annotation& a) { return a.name == "export"; });
                    Symbol* sym = binding_for(stmt);
                    if (sym && !facts.used_global_vars.count(sym) && !is_exported) {
                        skip = true;
                    }
                }
                if (!skip && stmt->var_init) {
                    validate_expr(stmt->var_init, true);
                }
                break;
            }
            case Stmt::Kind::Expr:
                validate_expr(stmt->expr, false);
                break;
            case Stmt::Kind::Return:
                validate_expr(stmt->return_expr, true);
                break;
            case Stmt::Kind::ConditionalStmt:
                validate_expr(stmt->condition, true);
                validate_stmt(stmt->true_stmt, false);
                break;
            case Stmt::Kind::TypeDecl:
            case Stmt::Kind::Import:
            case Stmt::Kind::Break:
            case Stmt::Kind::Continue:
                break;
        }
    };

    for (const auto& stmt : stmts) {
        validate_stmt(stmt, top_level);
    }
}

void CodeGenerator::gen_module(const Module& mod) {
    Program* program = type_checker ? type_checker->get_program() : nullptr;
    int saved_instance = type_checker ? type_checker->current_instance() : -1;

    auto set_instance = [&](int instance_id) {
        current_instance_id = instance_id;
        if (type_checker) {
            type_checker->set_current_instance(instance_id);
        }
    };

    auto for_instances = [&](auto&& fn) {
        if (program) {
            for (const auto& instance : program->instances) {
                set_instance(instance.id);
                const Module& module = program->modules[static_cast<size_t>(instance.module_id)].module;
                fn(module);
            }
        } else {
            set_instance(-1);
            fn(mod);
        }
    };

    // External function forward declarations
    for_instances([&](const Module& module) {
        for (const auto& stmt : module.top_level) {
            if (stmt->kind == Stmt::Kind::FuncDecl && stmt->is_external) {
                std::string func_name = stmt->func_name;
                if (!stmt->type_namespace.empty()) {
                    func_name = stmt->type_namespace + "::" + stmt->func_name;
                }
                bool is_reentrant = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                                [](const Annotation& a) { return a.name == "reentrant"; });
                bool is_nonreentrant = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                                   [](const Annotation& a) { return a.name == "nonreentrant"; });
                if (is_reentrant && is_nonreentrant) {
                    throw CompileError("Conflicting annotations: [[reentrant]] and [[nonreentrant]] on external function '" +
                                       stmt->func_name + "'", stmt->location);
                }
                std::string reent_prefix = is_reentrant ? "VX_REENTRANT " : "VX_NON_REENTRANT ";
                bool has_inline = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                              [](const Annotation& a) { return a.name == "inline"; });
                bool has_noinline = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                                [](const Annotation& a) { return a.name == "noinline"; });
                std::string label_prefix;
                if (!stmt->ref_params.empty()) {
                    std::string ref_key(stmt->ref_params.size(), 'M');
                    label_prefix += "VX_REF_MASK(\"" + ref_key + "\") ";
                }
                if (stmt->is_exported) {
                    label_prefix += "VX_ENTRYPOINT ";
                }
                if (has_noinline) {
                    label_prefix += "VX_NOINLINE ";
                } else if (has_inline) {
                    label_prefix += "VX_INLINE ";
                }
                std::string ret_type = stmt->return_type ? gen_type(stmt->return_type) : "void";
                emit_header(label_prefix + reent_prefix + ret_type + " " + mangle_name(func_name) + "(");
                for (size_t i = 0; i < stmt->params.size(); i++) {
                    if (i > 0) emit_header(", ");
                    std::string ptype = require_type(stmt->params[i].type,
                                                     stmt->params[i].location,
                                                     "parameter '" + stmt->params[i].name +
                                                     "' in external function '" + stmt->func_name + "'");
                    emit_header(ptype + " " + mangle_name(stmt->params[i].name));
                }
                emit_header(");");
            }
        }
    });
    emit_header("");

    // Type declarations (deduped by name)
    std::unordered_set<std::string> emitted_types;
    if (program) {
        for (const auto& mod_info : program->modules) {
            for (const auto& stmt : mod_info.module.top_level) {
                if (stmt->kind != Stmt::Kind::TypeDecl) continue;
                if (!facts.used_type_names.empty() && !facts.used_type_names.count(stmt->type_decl_name)) {
                    continue;
                }
                if (!emitted_types.insert(stmt->type_decl_name).second) {
                    continue;
                }
                gen_type_decl(stmt);
            }
        }
    } else {
        for (const auto& stmt : mod.top_level) {
            if (stmt->kind != Stmt::Kind::TypeDecl) continue;
            if (!facts.used_type_names.empty() && !facts.used_type_names.count(stmt->type_decl_name)) {
                continue;
            }
            if (!emitted_types.insert(stmt->type_decl_name).second) {
                continue;
            }
            gen_type_decl(stmt);
        }
    }

    // Note: tuple type declarations will be emitted after code generation

    // Forward declarations (only for reachable functions)
    for_instances([&](const Module& module) {
        for (const auto& stmt : module.top_level) {
            if (stmt->kind != Stmt::Kind::FuncDecl || stmt->is_external) {
                continue;
            }
            Symbol* sym = binding_for(stmt);
            if (!sym || sym->kind != Symbol::Kind::Function) continue;
            if (!facts.reachable_functions.count(sym)) {
                continue;
            }

            bool has_expr_params = false;
            for (const auto& param : stmt->params) {
                if (param.is_expression_param) {
                    has_expr_params = true;
                    break;
                }
            }
            if (has_expr_params) {
                continue;
            }

            std::string func_name = sym->name;
            std::string func_key = func_key_for(sym);

            std::string storage = stmt->is_exported ? "" : "static ";
            bool has_inline = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                          [](const Annotation& a) { return a.name == "inline"; });
            bool has_noinline = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                            [](const Annotation& a) { return a.name == "noinline"; });
            bool is_pure = false;
            bool no_global_write = false;
            {
                auto pure_it = facts.function_is_pure.find(sym);
                if (pure_it != facts.function_is_pure.end() && pure_it->second) {
                    is_pure = true;
                }
                auto gw_it = facts.function_writes_global.find(sym);
                if (gw_it != facts.function_writes_global.end() && !gw_it->second) {
                    no_global_write = true;
                }
            }

            std::string ret_type;
            bool returns_tuple = !stmt->return_types.empty();
            if (returns_tuple) {
                std::string tuple_name = std::string(TUPLE_TYPE_PREFIX) + std::to_string(stmt->return_types.size());
                for (const auto& t : stmt->return_types) {
                    tuple_name += "_";
                    if (t) {
                        tuple_name += t->to_string();
                    } else {
                        tuple_name += "unknown";
                    }
                }
                if (!tuple_types.count(tuple_name)) {
                    tuple_types[tuple_name] = stmt->return_types;
                }
                ret_type = mangle_name(tuple_name);
            } else {
                if (stmt->return_type) {
                    if (stmt->return_type->kind == Type::Kind::TypeVar) {
                        ret_type = "void";
                    } else {
                        ret_type = gen_type(stmt->return_type);
                    }
                } else {
                    if (stmt->body && stmt->body->type && stmt->body->type->kind != Type::Kind::TypeVar) {
                        ret_type = gen_type(stmt->body->type);
                    } else {
                        ret_type = "void";
                    }
                }
            }

            TypePtr return_type_ptr = nullptr;
            if (!returns_tuple) {
                if (stmt->return_type && stmt->return_type->kind != Type::Kind::TypeVar) {
                    return_type_ptr = stmt->return_type;
                } else if (stmt->body && stmt->body->type && stmt->body->type->kind != Type::Kind::TypeVar) {
                    return_type_ptr = stmt->body->type;
                }
            }

            bool returns_aggregate = abi.lower_aggregates && (returns_tuple || is_aggregate_type(return_type_ptr));
            std::string agg_out_type;
            if (returns_aggregate) {
                agg_out_type = ret_type;
                ret_type = "void";
            } else if (return_type_ptr && is_pointer_like(return_type_ptr)) {
                if (abi.func_return_ptr_kind && abi.func_return_ptr_kind(func_key) == PtrKind::Far) {
                    ret_type = "uint32_t";
                }
            }

            auto ref_keys = ref_variant_keys_for(stmt);
            auto reent_keys = reentrancy_keys_for(sym);
            for (const auto& reent_key : reent_keys) {
                std::string reent_prefix = (reent_key == 'R') ? "VX_REENTRANT " : "VX_NON_REENTRANT ";
                for (const auto& ref_key : ref_keys) {
                    std::string variant = variant_name(func_name, sym, reent_key, ref_key);
                    std::string codegen_name = mangle_name(variant) + instance_suffix(sym);
                    std::string label_prefix;
                    if (!ref_key.empty()) {
                        label_prefix += "VX_REF_MASK(\"" + ref_key + "\") ";
                    }
                    if (stmt->is_exported) {
                        label_prefix += "VX_ENTRYPOINT ";
                    }
                    if (is_pure) {
                        label_prefix += "VX_PURE ";
                    }
                    if (no_global_write) {
                        label_prefix += "VX_NO_GLOBAL_WRITE ";
                    }
                    if (has_noinline) {
                        label_prefix += "VX_NOINLINE ";
                    } else if (has_inline) {
                        label_prefix += "VX_INLINE ";
                    }
                    emit_header(label_prefix + reent_prefix + storage + ret_type + " " + codegen_name + "(");

                    bool first_param = true;
                    if (returns_aggregate) {
                        emit_header(agg_out_type + "* __vx_out");
                        first_param = false;
                    }

                    for (size_t i = 0; i < stmt->ref_params.size(); i++) {
                        if (!first_param) emit_header(", ");
                        first_param = false;

                        std::string ref_type;
                        TypePtr ref_type_ptr = resolve_ref_param_type_or_fail(stmt, i);
                        bool by_ref = true;
                        if (!ref_key.empty() && i < ref_key.size()) {
                            by_ref = ref_key[i] == 'M';
                        }
                        if (abi.lower_aggregates && ref_type_ptr && is_aggregate_type(ref_type_ptr)) {
                            by_ref = true;
                        }
                        if (ref_type_ptr) {
                            ref_type = gen_type(ref_type_ptr);
                        } else if (!stmt->type_namespace.empty() && i == 0) {
                            ref_type = mangle_name(stmt->type_namespace);
                        } else {
                            ref_type = "void";
                        }

                        if (by_ref) {
                            ref_type += "*";
                        } else if (ref_type == "void") {
                            ref_type = "void*";
                        }

                        emit_header(ref_type + " " + mangle_name(stmt->ref_params[i]));
                    }

                    for (size_t i = 0; i < stmt->params.size(); i++) {
                        if (stmt->params[i].is_expression_param) continue;
                        if (!first_param) emit_header(", ");
                        first_param = false;
                        std::string ptype = require_type(stmt->params[i].type,
                                                         stmt->params[i].location,
                                                         "parameter '" + stmt->params[i].name +
                                                         "' in function '" + stmt->func_name + "'");
                        if (stmt->params[i].type && is_pointer_like(stmt->params[i].type)) {
                            Symbol* param_sym = binding_for(&stmt->params[i]);
                            if (ptr_kind_for_symbol(param_sym) == PtrKind::Far) {
                                ptype = "uint32_t";
                            }
                        }
                        if (abi.lower_aggregates && stmt->params[i].type && is_aggregate_type(stmt->params[i].type)) {
                            ptype = gen_type(stmt->params[i].type) + "*";
                        }
                        emit_header(ptype + " " + mangle_name(stmt->params[i].name));
                    }
                    emit_header(");");
                }
            }
        }
    });
    emit_header("");

    // Global variables and functions
    for_instances([&](const Module& module) {
        for (const auto& stmt : module.top_level) {
            gen_stmt(stmt);
        }
    });

    // Generate tuple type declarations (collected during code generation)
    // These are emitted at the end of gen_module after everything is processed
    // We need to insert them after includes but before function declarations
    std::vector<std::pair<std::string, std::vector<TypePtr>>> tuple_decls;
    if (!tuple_types.empty()) {
        for (const auto& pair : tuple_types) {
            if (!facts.used_type_names.empty() && !facts.used_type_names.count(pair.first)) {
                continue;
            }
            tuple_decls.push_back(pair);
        }
    }

    if (!tuple_decls.empty()) {
        // Save current header and body
        std::string header_str = header.str();
        std::string body_str = body.str();

        // Clear streams
        header.str("");
        header.clear();
        body.str("");
        body.clear();

        // Find the end of includes in header (after the empty line following includes)
        size_t includes_end = header_str.find("#include <math.h>");
        if (includes_end != std::string::npos) {
            includes_end = header_str.find('\n', includes_end);
            includes_end = header_str.find('\n', includes_end + 1) + 1; // Skip the empty line
        } else {
            includes_end = 0;
        }

        // Reconstruct header with tuple declarations inserted after includes
        header << header_str.substr(0, includes_end);

        emit_header("// Tuple type declarations");
        for (const auto& pair : tuple_decls) {
            const std::string& tuple_name = pair.first;
            const std::vector<TypePtr>& elem_types = pair.second;

            emit_header("typedef struct {");
            for (size_t i = 0; i < elem_types.size(); i++) {
                TypePtr elem = elem_types[i];
                std::string elem_type = require_type(elem,
                                                    elem ? elem->location : SourceLocation(),
                                                    "tuple element in '" + tuple_name + "'");
                emit_header("  " + elem_type + " __" + std::to_string(i) + ";");
            }
            emit_header("} " + mangle_name(tuple_name) + ";");
        }
        emit_header("");

        // Append rest of header
        header << header_str.substr(includes_end);

        // Restore body section
        body << body_str;
    }

    if (type_checker) {
        type_checker->set_current_instance(saved_instance);
    }
}


void CodeGenerator::gen_stmt(StmtPtr stmt) {
    switch (stmt->kind) {
        case Stmt::Kind::FuncDecl:
            {
                Symbol* sym = binding_for(stmt);
                if (!sym || sym->kind != Symbol::Kind::Function) {
                    break;
                }
                auto reent_keys = reentrancy_keys_for(sym);
                auto ref_keys = ref_variant_keys_for(stmt);
                for (const auto& reent_key : reent_keys) {
                    for (const auto& ref_key : ref_keys) {
                        gen_func_decl(stmt, ref_key, reent_key);
                    }
                }
            }
            break;
        case Stmt::Kind::TypeDecl:
            // Already generated
            break;
        case Stmt::Kind::VarDecl:
            gen_var_decl(stmt);
            break;
        case Stmt::Kind::Expr:
            if (stmt->expr) {
                // Special handling for assignment expressions that create new variables
                // Check the creates_new_variable flag set by typechecker
                if (stmt->expr->kind == Expr::Kind::Assignment &&
                    stmt->expr->left->kind == Expr::Kind::Identifier &&
                    stmt->expr->creates_new_variable) {

                    // Generate variable declaration with initialization
                    std::string var_type_str;

                    // Special handling for tuple-returning function calls
                    if (stmt->expr->right && stmt->expr->right->kind == Expr::Kind::Call &&
                        stmt->expr->right->operand && stmt->expr->right->operand->kind == Expr::Kind::Identifier) {

                        std::string func_name = stmt->expr->right->operand->name;
                        Symbol* sym = binding_for(stmt->expr->right->operand);

                        if (sym && sym->kind == Symbol::Kind::Function && sym->declaration &&
                            !sym->declaration->return_types.empty()) {
                            // This is a tuple-returning function
                            std::string tuple_name = std::string(TUPLE_TYPE_PREFIX) + std::to_string(sym->declaration->return_types.size());
                            for (const auto& t : sym->declaration->return_types) {
                                tuple_name += "_";
                                if (t) {
                                    tuple_name += t->to_string();
                                } else {
                                    tuple_name += "unknown";
                                }
                            }
                            var_type_str = mangle_name(tuple_name);
                        } else if (stmt->expr->right->type) {
                            var_type_str = gen_type(stmt->expr->right->type);
                        } else {
                            throw CompileError("Missing type for assignment-generated variable '" +
                                               stmt->expr->left->name + "'", stmt->expr->location);
                        }
                    } else if (stmt->expr->left && stmt->expr->left->type) {
                        // Use explicit type annotation from left side
                        var_type_str = gen_type(stmt->expr->left->type);
                    } else if (stmt->expr->right && stmt->expr->right->type) {
                        // Infer from right side
                        var_type_str = gen_type(stmt->expr->right->type);
                    } else {
                        throw CompileError("Missing type for assignment-generated variable '" +
                                           stmt->expr->left->name + "'", stmt->expr->location);
                    }

                    std::string var_name = mangle_name(stmt->expr->left->name);
                    if (Symbol* sym = binding_for(stmt->expr->left)) {
                        var_name += instance_suffix(sym);
                    }

                    // Special handling for array initialization
                    TypePtr var_type = stmt->expr->left->type ? stmt->expr->left->type : stmt->expr->type;
                    if (var_type && var_type->kind == Type::Kind::Array &&
                        stmt->expr->right->kind == Expr::Kind::ArrayLiteral) {
                        // Generate array declaration with inline initialization
                        std::string elem_type = gen_type(var_type->element_type);
                        std::string size_str = "0";
                        if (var_type->array_size) {
                            CTValue size_val;
                            if (try_evaluate(var_type->array_size, size_val)) {
                                size_str = std::to_string(std::get<int64_t>(size_val));
                            }
                        }
                        emit(elem_type + " " + var_name + "[" + size_str + "] = {");
                        {
                            VoidCallGuard guard(*this, false);
                            for (size_t i = 0; i < stmt->expr->right->elements.size(); i++) {
                                if (i > 0) emit(", ");
                                emit(gen_expr(stmt->expr->right->elements[i]));
                            }
                        }
                        emit("};");
                        break;
                    }

                    std::string rhs;
                    {
                        VoidCallGuard guard(*this, false);
                        rhs = gen_expr(stmt->expr->right);
                    }
                    emit(var_type_str + " " + var_name + " = " + rhs + ";");
                    // Release RHS temp if it's a temporary
                    if (rhs.substr(0, 3) == "tmp") {
                        release_temp(rhs);
                    }
                    break;
                }

                // Regular expression statement (including assignments to existing variables)
                {
                    VoidCallGuard guard(*this, true);
                    std::string expr_code = gen_expr(stmt->expr);
                    if (!expr_code.empty()) {
                        emit(expr_code + ";");
                    }
                }
            }
            break;
        case Stmt::Kind::Return:
            if (stmt->return_expr) {
                std::string ret_expr;
                {
                    VoidCallGuard guard(*this, false);
                    ret_expr = gen_expr(stmt->return_expr);
                }
                emit_return_stmt(ret_expr);
            } else {
                emit_return_stmt("");
            }
            break;
        case Stmt::Kind::Break:
            emit("break;");
            break;
        case Stmt::Kind::Continue:
            emit("continue;");
            break;
        case Stmt::Kind::ConditionalStmt:
            // Try compile-time evaluation for dead branch elimination
            {
                CTValue cond_val;
                if (try_evaluate(stmt->condition, cond_val)) {
                    // Compile-time constant condition
                    bool is_true = false;
                    if (std::holds_alternative<int64_t>(cond_val)) {
                        is_true = std::get<int64_t>(cond_val) != 0;
                    } else if (std::holds_alternative<bool>(cond_val)) {
                        is_true = std::get<bool>(cond_val);
                    } else if (std::holds_alternative<uint64_t>(cond_val)) {
                        is_true = std::get<uint64_t>(cond_val) != 0;
                    }

                    if (is_true) {
                        // Only generate true branch
                        gen_stmt(stmt->true_stmt);
                    }
                    // If false, generate nothing (dead branch eliminated)
                    break;
                }
            }

            // Runtime conditional
            {
                std::string cond_expr;
                {
                    VoidCallGuard guard(*this, false);
                    cond_expr = gen_expr(stmt->condition);
                }
                emit("if (" + cond_expr + ") {");
            }
            gen_stmt(stmt->true_stmt);
            emit("}");
            break;
        default:
            break;
    }
}

void CodeGenerator::gen_func_decl(StmtPtr stmt, const std::string& ref_key, char reent_key) {
    if (stmt->is_external) return;

    Symbol* sym = binding_for(stmt);
    if (!sym || sym->kind != Symbol::Kind::Function) {
        return;
    }

    std::string func_name = sym->name;
    std::string func_key = func_key_for(sym);
    std::string variant_id = variant_name(func_name, sym, reent_key, ref_key);

    if (!current_variant_name_override.empty()) {
        variant_id = current_variant_name_override;
        if (current_variant_id.empty()) {
            current_variant_id = variant_id;
        }
    } else {
        current_variant_id = variant_id;
    }

    current_reentrancy_key = reent_key;
    current_function_non_reentrant = (reent_key == 'N');
    std::string reent_prefix = (reent_key == 'R') ? "VX_REENTRANT " : "VX_NON_REENTRANT ";

    // Skip unreachable functions (dead code elimination)
    if (!facts.reachable_functions.count(sym)) {
        current_function_non_reentrant = false;
        current_reentrancy_key = 'N';
        return;
    }

    current_func_key = func_key;
    current_func_symbol = sym;
    if (abi.func_page) {
        current_bank_page = abi.func_page(func_key);
    } else {
        current_bank_page = 'A';
    }
    if (abi.func_module_id_expr) {
        current_module_id_expr = abi.func_module_id_expr(func_key, current_bank_page);
    } else {
        current_module_id_expr = "0";
    }

    bool has_inline = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                  [](const Annotation& a) { return a.name == "inline"; });
    bool has_noinline = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                    [](const Annotation& a) { return a.name == "noinline"; });
    bool is_pure = false;
    bool no_global_write = false;
    {
        auto pure_it = facts.function_is_pure.find(sym);
        if (pure_it != facts.function_is_pure.end() && pure_it->second) {
            is_pure = true;
        }
        auto gw_it = facts.function_writes_global.find(sym);
        if (gw_it != facts.function_writes_global.end() && !gw_it->second) {
            no_global_write = true;
        }
    }

    // Skip functions with expression parameters - they're inlined at call sites
    for (const auto& param : stmt->params) {
        if (param.is_expression_param) {
            current_function_non_reentrant = false;
            current_reentrancy_key = 'N';
            return;
        }
    }

    // Reset temporary state for new function
    while (!available_temps.empty()) available_temps.pop();
    live_temps.clear();
    declared_temps.clear();
    temp_counter = 0;

    // Track reference parameters for this function (mutable paths use pointers)
    current_ref_params.clear();
    current_aggregate_params.clear();
    for (size_t i = 0; i < stmt->ref_params.size(); i++) {
        bool by_ref = true;
        if (!ref_key.empty() && i < ref_key.size()) {
            by_ref = ref_key[i] == 'M';
        }
        TypePtr ref_type_ptr = resolve_ref_param_type_or_fail(stmt, i);
        if (abi.lower_aggregates && ref_type_ptr && is_aggregate_type(ref_type_ptr)) {
            by_ref = true;
            current_aggregate_params.insert(stmt->ref_params[i]);
        }
        if (by_ref) {
            current_ref_params.insert(stmt->ref_params[i]);
        }
    }
    for (const auto& param : stmt->params) {
        if (param.is_expression_param) continue;
        if (abi.lower_aggregates && param.type && is_aggregate_type(param.type)) {
            current_aggregate_params.insert(param.name);
        }
    }

    // Internal functions are static, exported functions are public
    std::string storage = stmt->is_exported ? "" : "static ";
    std::string attr;
    if (stmt->is_exported) {
        if (std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                        [](const Annotation& a) { return a.name == "hot"; })) {
            attr = "__attribute__((hot)) ";
        }
        if (std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                        [](const Annotation& a) { return a.name == "cold"; })) {
            attr = "__attribute__((cold)) ";
        }
    }

    // Handle tuple return types
    std::string ret_type;
    bool returns_tuple = !stmt->return_types.empty();
    if (returns_tuple) {
        std::string tuple_name = std::string(TUPLE_TYPE_PREFIX) + std::to_string(stmt->return_types.size());
        for (const auto& t : stmt->return_types) {
            tuple_name += "_";
            if (t) {
                tuple_name += t->to_string();
            } else {
                tuple_name += "unknown";
            }
        }
        if (!tuple_types.count(tuple_name)) {
            tuple_types[tuple_name] = stmt->return_types;
        }
        ret_type = mangle_name(tuple_name);
    } else {
        if (stmt->return_type) {
            if (stmt->return_type->kind == Type::Kind::TypeVar) {
                ret_type = "void";
            } else {
                ret_type = gen_type(stmt->return_type);
            }
        } else {
            if (stmt->body && stmt->body->type && stmt->body->type->kind != Type::Kind::TypeVar) {
                ret_type = gen_type(stmt->body->type);
            } else {
                ret_type = "void";
            }
        }
    }

    TypePtr return_type_ptr = nullptr;
    if (!returns_tuple) {
        if (stmt->return_type && stmt->return_type->kind != Type::Kind::TypeVar) {
            return_type_ptr = stmt->return_type;
        } else if (stmt->body && stmt->body->type && stmt->body->type->kind != Type::Kind::TypeVar) {
            return_type_ptr = stmt->body->type;
        }
    }

    current_returns_aggregate = false;
    aggregate_out_param.clear();
    aggregate_out_type.clear();

    if (abi.lower_aggregates && (returns_tuple || is_aggregate_type(return_type_ptr))) {
        current_returns_aggregate = true;
        aggregate_out_param = "__vx_out";
        aggregate_out_type = ret_type;
        ret_type = "void";
    } else if (return_type_ptr && is_pointer_like(return_type_ptr)) {
        if (abi.func_return_ptr_kind && abi.func_return_ptr_kind(func_key) == PtrKind::Far) {
            ret_type = "uint32_t";
        }
    }

    bool prev_in_function = in_function;
    in_function = true;
    std::ostringstream func_stream;
    output_stack.push(&func_stream);

    emit("");
    std::string ann_comment = render_annotation_comment(stmt->annotations);
    if (!ann_comment.empty()) emit(ann_comment);
    std::string codegen_name = mangle_name(variant_id) + instance_suffix(sym);
    std::string label_prefix;
    if (!ref_key.empty()) {
        label_prefix += "VX_REF_MASK(\"" + ref_key + "\") ";
    }
    if (stmt->is_exported) {
        label_prefix += "VX_ENTRYPOINT ";
    }
    if (is_pure) {
        label_prefix += "VX_PURE ";
    }
    if (no_global_write) {
        label_prefix += "VX_NO_GLOBAL_WRITE ";
    }
    if (has_noinline) {
        label_prefix += "VX_NOINLINE ";
    } else if (has_inline) {
        label_prefix += "VX_INLINE ";
    }
    emit(label_prefix + reent_prefix + storage + attr + ret_type + " " + codegen_name + "(");

    bool first_param = true;
    if (current_returns_aggregate) {
        emit(aggregate_out_type + "* " + aggregate_out_param);
        first_param = false;
    }

    for (size_t i = 0; i < stmt->ref_params.size(); i++) {
        if (!first_param) emit(", ");
        first_param = false;
        std::string ref_type;
        TypePtr ref_type_ptr = (i < stmt->ref_param_types.size()) ? stmt->ref_param_types[i] : nullptr;
        bool by_ref = true;
        if (!ref_key.empty() && i < ref_key.size()) {
            by_ref = ref_key[i] == 'M';
        }
        if (abi.lower_aggregates && ref_type_ptr && is_aggregate_type(ref_type_ptr)) {
            by_ref = true;
        }
        if (ref_type_ptr) {
            ref_type = gen_type(ref_type_ptr);
        } else if (!stmt->type_namespace.empty() && i == 0) {
            ref_type = mangle_name(stmt->type_namespace);
        } else {
            ref_type = "void";
        }
        if (by_ref) {
            ref_type += "*";
        } else if (ref_type == "void") {
            ref_type = "void*";
        }
        emit(ref_type + " " + mangle_name(stmt->ref_params[i]));
    }

    for (size_t i = 0; i < stmt->params.size(); i++) {
        if (stmt->params[i].is_expression_param) continue;
        if (!first_param) emit(", ");
        first_param = false;
        std::string ptype = require_type(stmt->params[i].type,
                                         stmt->params[i].location,
                                         "parameter '" + stmt->params[i].name +
                                         "' in function '" + stmt->func_name + "'");
        if (stmt->params[i].type && is_pointer_like(stmt->params[i].type)) {
            Symbol* param_sym = binding_for(&stmt->params[i]);
            if (ptr_kind_for_symbol(param_sym) == PtrKind::Far) {
                ptype = "uint32_t";
            }
        }
        if (abi.lower_aggregates && stmt->params[i].type && is_aggregate_type(stmt->params[i].type)) {
            ptype = gen_type(stmt->params[i].type) + "*";
        }
        emit(ptype + " " + mangle_name(stmt->params[i].name));
    }

    emit(") {");

    bool handled_body = false;

    if (stmt->body) {
        if (stmt->params.empty() && stmt->ref_params.empty()) {
            CTValue result;
            if (try_evaluate(stmt->body, result)) {
                if (std::holds_alternative<int64_t>(result)) {
                    emit_return_stmt(std::to_string(std::get<int64_t>(result)));
                    handled_body = true;
                } else if (std::holds_alternative<uint64_t>(result)) {
                    emit_return_stmt(std::to_string(std::get<uint64_t>(result)));
                    handled_body = true;
                } else if (std::holds_alternative<bool>(result)) {
                    emit_return_stmt(std::string(std::get<bool>(result) ? "1" : "0"));
                    handled_body = true;
                } else if (std::holds_alternative<double>(result)) {
                    emit_return_stmt(std::to_string(std::get<double>(result)));
                    handled_body = true;
                }
            }
        }

        if (!handled_body && type_checker && stmt->body->kind == Expr::Kind::Block &&
            stmt->params.empty() && stmt->ref_params.empty()) {
            std::string optimized = gen_block_optimized(stmt->body);
            if (!optimized.empty()) {
                emit(optimized);
                handled_body = true;
            }
        }

        if (!handled_body) {
            std::string body_expr;
            if (stmt->return_type) {
                if (stmt->body && stmt->body->kind == Expr::Kind::Block) {
                    for (const auto& bstmt : stmt->body->statements) {
                        gen_stmt(bstmt);
                    }
                    if (stmt->body->result_expr) {
                        VoidCallGuard guard(*this, false);
                        body_expr = gen_expr(stmt->body->result_expr);
                        emit_return_stmt(body_expr);
                    }
                } else {
                    VoidCallGuard guard(*this, false);
                    body_expr = gen_expr(stmt->body);
                    emit_return_stmt(body_expr);
                }
            } else {
                VoidCallGuard guard(*this, true);
                body_expr = gen_expr(stmt->body);
                if (!body_expr.empty()) {
                    emit(body_expr + ";");
                }
            }
        }
    }

    if (!current_returns_aggregate && !stmt->return_type && stmt->return_types.empty() &&
        !abi.return_prefix.empty()) {
        emit_return_stmt("");
    }

    emit("}");

    current_function_non_reentrant = false;
    current_reentrancy_key = 'N';
    current_returns_aggregate = false;
    aggregate_out_param.clear();
    aggregate_out_type.clear();
    current_aggregate_params.clear();
    current_variant_name_override.clear();
    current_variant_id.clear();
    current_func_key.clear();
    current_func_symbol = nullptr;
    current_module_id_expr = "0";
    current_bank_page = 'A';
    
    output_stack.pop();
    in_function = prev_in_function;
    std::string func_code = func_stream.str();
    if (!func_code.empty()) {
        GeneratedFunctionInfo info;
        info.declaration = stmt;
        info.qualified_name = variant_id;
        info.c_name = codegen_name;
        info.storage = storage;
        info.code = func_code;
        generated_functions.push_back(std::move(info));
        body << func_code;
    }
}

void CodeGenerator::gen_type_decl(StmtPtr stmt) {
    std::string ann_comment = render_annotation_comment(stmt->annotations);
    if (!ann_comment.empty()) emit_header(ann_comment);
    emit_header("typedef struct {");
    for (const auto& field : stmt->fields) {
        std::string ftype = require_type(field.type,
                                         field.location,
                                         "field '" + field.name + "' in type '" + stmt->type_decl_name + "'");
        emit_header("  " + ftype + " " + mangle_name(field.name) + ";");
    }
    emit_header("} " + mangle_name(stmt->type_decl_name) + ";");
    emit_header("");

    type_map[stmt->type_decl_name] = mangle_name(stmt->type_decl_name);
}

void CodeGenerator::gen_var_decl(StmtPtr stmt) {
    bool is_local = in_function;
    bool is_exported = std::any_of(stmt->annotations.begin(), stmt->annotations.end(),
                                   [](const Annotation& a) { return a.name == "export"; });
    Symbol* sym = binding_for(stmt);
    if (!is_local && sym && !facts.used_global_vars.count(sym) && !is_exported) {
        return;
    }
    // Top-level mutable globals must be internal to the translation unit
    std::string storage = (!is_local && stmt->is_mutable) ? "static " : "";
    if (!is_local && is_exported && !stmt->is_mutable) {
        storage = "extern ";
    }
    std::ostringstream var_stream;
    output_stack.push(&var_stream);
    std::string ann_comment = render_annotation_comment(stmt->annotations);
    if (!ann_comment.empty()) {
        emit(ann_comment);
    }
    auto finalize = [&]() {
        output_stack.pop();
        std::string code = var_stream.str();
        if (is_local) {
            if (!output_stack.empty()) {
                *output_stack.top() << code;
            }
        } else {
            GeneratedVarInfo info;
            info.declaration = stmt;
            info.symbol = sym;
            info.code = code;
            generated_vars.push_back(std::move(info));
            if (!abi.multi_file_globals) {
                body << code;
            }
        }
    };

    std::string var_name = stmt->var_name;
    if (sym) {
        var_name += instance_suffix(sym);
    }

    std::string vtype = require_type(stmt->var_type,
                                     stmt->location,
                                     "variable '" + stmt->var_name + "'");
    if (stmt->var_type) {
        TypePtr resolved = resolve_type(stmt->var_type);
        if (resolved && is_pointer_like(resolved) && resolved->kind != Type::Kind::Array) {
            if (ptr_kind_for_symbol(sym) == PtrKind::Far) {
                vtype = "uint32_t";
            }
        }
    }
    std::string mutability = mutability_prefix(stmt);
    if (!is_local && is_exported) {
        if (stmt->var_type && stmt->var_type->kind == Type::Kind::Array) {
            std::string elem_type = gen_type(stmt->var_type->element_type);
            std::string size_str;
            if (stmt->var_type->array_size) {
                CTValue size_val;
                if (try_evaluate(stmt->var_type->array_size, size_val)) {
                    size_str = std::to_string(std::get<int64_t>(size_val));
                }
            }
            std::string suffix = size_str.empty() ? "[]" : ("[" + size_str + "]");
            emit_header("extern " + mutability + elem_type + " " + mangle_name(var_name) + suffix + ";");
        } else {
            emit_header("extern " + mutability + vtype + " " + mangle_name(var_name) + ";");
        }
    }
    if (stmt->var_init) {
        // Special handling for array literals and ranges
            if (stmt->var_type && stmt->var_type->kind == Type::Kind::Array &&
            (stmt->var_init->kind == Expr::Kind::ArrayLiteral || stmt->var_init->kind == Expr::Kind::Range)) {

            std::string elem_type = gen_type(stmt->var_type->element_type);
            std::string size_str = "0";
            if (stmt->var_type->array_size) {
                CTValue size_val;
                if (try_evaluate(stmt->var_type->array_size, size_val)) {
                    size_str = std::to_string(std::get<int64_t>(size_val));
                }
            }

            // Handle range expansion
            if (stmt->var_init->kind == Expr::Kind::Range) {
                auto bounds = evaluate_range(stmt->var_init);
                if (bounds) {
                    int64_t start = bounds->first;
                    int64_t end = bounds->second;
                    if (start == end) {
                        throw CompileError("Range cannot produce an empty array", stmt->var_init->location);
                    }
                    int64_t count = (start < end) ? (end - start) : (start - end);
                    std::ostringstream init;
                    init << storage << mutability << elem_type << " " << mangle_name(var_name) << "[" << count << "] = {";
                    bool first = true;
                    if (start < end) {
                        for (int64_t i = start; i < end; ++i) {
                            if (!first) init << ", ";
                            first = false;
                            init << i;
                        }
                    } else {
                        for (int64_t i = start; i > end; --i) {
                            if (!first) init << ", ";
                            first = false;
                            init << i;
                        }
                    }
                    init << "};";
                    emit(init.str());
                    finalize();
                    return;
                }
            }

                // Handle array literal
                if (stmt->var_init->kind == Expr::Kind::ArrayLiteral) {
                    emit(storage + mutability + elem_type + " " + mangle_name(var_name) + "[" + size_str + "] = {");
                    {
                        VoidCallGuard guard(*this, false);
                        for (size_t i = 0; i < stmt->var_init->elements.size(); i++) {
                            if (i > 0) emit(", ");
                            emit(gen_expr(stmt->var_init->elements[i]));
                        }
                    }
                    emit("};");
                    finalize();
                    return;
                }
            }

            // Fallback for arrays initialized from existing arrays/expressions: allocate and copy
            if (stmt->var_type && stmt->var_type->kind == Type::Kind::Array) {
                std::string elem_type = gen_type(stmt->var_type->element_type);
                std::string size_str = "0";
                if (stmt->var_type->array_size) {
                    CTValue size_val;
                    if (try_evaluate(stmt->var_type->array_size, size_val)) {
                        size_str = std::to_string(std::get<int64_t>(size_val));
                    }
                }
                emit(storage + mutability + elem_type + " " + mangle_name(var_name) + "[" + size_str + "];");
                std::string init_expr;
                {
                    VoidCallGuard guard(*this, false);
                    init_expr = gen_expr(stmt->var_init);
                }
                emit("memcpy(" + mangle_name(var_name) + ", " + init_expr + ", sizeof(" + mangle_name(var_name) + "));");
                finalize();
                return;
            }

            // Try compile-time evaluation for simple constants
            {
            CTValue result;
            if (try_evaluate(stmt->var_init, result)) {
                // Successfully evaluated at compile time
                std::string init_val;
                if (std::holds_alternative<int64_t>(result)) {
                    int64_t val = std::get<int64_t>(result);
                    // For integer types, ensure the value is in range for C
                    // Apply wrapping if needed
                    if (stmt->var_type && stmt->var_type->kind == Type::Kind::Primitive) {
                        switch (stmt->var_type->primitive) {
                            case PrimitiveType::I8:
                                val = static_cast<int8_t>(val);
                                break;
                            case PrimitiveType::I16:
                                val = static_cast<int16_t>(val);
                                break;
                            case PrimitiveType::I32:
                                val = static_cast<int32_t>(val);
                                break;
                            case PrimitiveType::U8:
                                val = static_cast<uint8_t>(val);
                                break;
                            case PrimitiveType::U16:
                                val = static_cast<uint16_t>(val);
                                break;
                            case PrimitiveType::U32:
                                val = static_cast<uint32_t>(val);
                                break;
                            default:
                                break;
                        }
                    }
                    init_val = std::to_string(val);
                } else if (std::holds_alternative<uint64_t>(result)) {
                    uint64_t val = std::get<uint64_t>(result);
                    // Apply wrapping for smaller unsigned types
                    if (stmt->var_type && stmt->var_type->kind == Type::Kind::Primitive) {
                        switch (stmt->var_type->primitive) {
                            case PrimitiveType::U8:
                                val = static_cast<uint8_t>(val);
                                break;
                            case PrimitiveType::U16:
                                val = static_cast<uint16_t>(val);
                                break;
                            case PrimitiveType::U32:
                                val = static_cast<uint32_t>(val);
                                break;
                            default:
                                break;
                        }
                    }
                    init_val = std::to_string(val);
                } else if (std::holds_alternative<double>(result)) {
                    init_val = std::to_string(std::get<double>(result));
                } else if (std::holds_alternative<std::string>(result)) {
                    init_val = "\"" + escape_c_string(std::get<std::string>(result)) + "\"";
                }
                emit(storage + mutability + vtype + " " + mangle_name(var_name) + " = " + init_val + ";");
                finalize();
                return;
            } else if (!stmt->is_mutable) {
                // Immutable constant must be compile-time evaluable
                std::string error;
                if (type_checker) {
                    CompileTimeEvaluator evaluator(type_checker);
                    CTValue tmp;
                    (void)evaluator.try_evaluate(stmt->var_init, tmp);
                    error = evaluator.get_error();
                }
                throw CompileError("Constant '" + stmt->var_name + "' cannot be evaluated at compile time: " +
                                 error, stmt->location);
            }
        }
        // Fallback to runtime evaluation (only for mutable variables)
        std::string init_expr;
        {
            VoidCallGuard guard(*this, false);
            init_expr = gen_expr(stmt->var_init);
        }
        emit(storage + mutability + vtype + " " + mangle_name(var_name) + " = " + init_expr + ";");
    } else {
        // No initializer - special handling for arrays
        if (stmt->var_type && stmt->var_type->kind == Type::Kind::Array) {
            std::string elem_type = gen_type(stmt->var_type->element_type);
            std::string size_str = "0";
            if (stmt->var_type->array_size) {
                CTValue size_val;
                if (try_evaluate(stmt->var_type->array_size, size_val)) {
                    size_str = std::to_string(std::get<int64_t>(size_val));
                }
            }
            emit(storage + mutability + elem_type + " " + mangle_name(var_name) + "[" + size_str + "];");
        } else {
            emit(storage + mutability + vtype + " " + mangle_name(var_name) + ";");
        }
    }

    finalize();
}

bool CodeGenerator::is_compile_time_init(StmtPtr stmt) const {
    if (!stmt || !stmt->var_init) return false;
    if (optimization && optimization->constexpr_inits.count(stmt.get())) return true;
    if (stmt->var_type && stmt->var_type->kind == Type::Kind::Array &&
        (stmt->var_init->kind == Expr::Kind::ArrayLiteral || stmt->var_init->kind == Expr::Kind::Range)) {
        return true;
    }
    CTValue result;
    return try_evaluate(stmt->var_init, result);
}

std::string CodeGenerator::mutability_prefix(StmtPtr stmt) const {
    Symbol* sym = binding_for(stmt);
    auto it = sym ? facts.var_mutability.find(sym) : facts.var_mutability.end();
    VarMutability kind = stmt->is_mutable ? VarMutability::Mutable : VarMutability::Constexpr;
    if (it != facts.var_mutability.end()) {
        kind = it->second;
    }
    switch (kind) {
        case VarMutability::Mutable:
            return "VX_MUTABLE ";
        case VarMutability::NonMutableRuntime:
            return "VX_NON_MUTABLE ";
        case VarMutability::Constexpr:
            return "VX_CONSTEXPR ";
        default:
            return "";
    }
}

std::string CodeGenerator::ref_variant_key(const ExprPtr& call, size_t ref_count) const {
    std::string key;
    key.reserve(ref_count);
    for (size_t i = 0; i < ref_count; i++) {
        bool is_mut = false;
        if (call && i < call->receivers.size()) {
            is_mut = receiver_is_mutable_arg(call->receivers[i]);
        }
        key.push_back(is_mut ? 'M' : 'N');
    }
    return key;
}

std::vector<std::string> CodeGenerator::ref_variant_keys_for(StmtPtr stmt) const {
    std::vector<std::string> keys;
    if (!stmt || stmt->ref_params.empty()) {
        keys.push_back("");
        return keys;
    }
    Symbol* sym = binding_for(stmt);
    if (sym) {
        auto it = facts.ref_variants.find(sym);
        if (it != facts.ref_variants.end()) {
            keys.assign(it->second.begin(), it->second.end());
        }
    }
    if (keys.empty()) {
        keys.push_back(std::string(stmt->ref_params.size(), 'M'));
    }
    std::sort(keys.begin(), keys.end());
    return keys;
}

std::string CodeGenerator::ref_variant_name(const std::string& func_name, const std::string& ref_key) const {
    if (ref_key.empty()) return func_name;
    bool all_mut = std::all_of(ref_key.begin(), ref_key.end(), [](char c) { return c == 'M'; });
    if (all_mut) return func_name;
    return func_name + "__ref" + ref_key;
}

std::vector<char> CodeGenerator::reentrancy_keys_for(const Symbol* func_sym) const {
    std::vector<char> keys;
    if (func_sym) {
        auto it = facts.reentrancy_variants.find(func_sym);
        if (it != facts.reentrancy_variants.end()) {
            keys.assign(it->second.begin(), it->second.end());
        }
    }
    if (keys.empty()) {
        keys.push_back('N');
    }
    std::sort(keys.begin(), keys.end());
    return keys;
}

std::string CodeGenerator::reentrancy_variant_name(const std::string& func_name, const Symbol* func_sym, char reent_key) const {
    auto it = func_sym ? facts.reentrancy_variants.find(func_sym) : facts.reentrancy_variants.end();
    if (it == facts.reentrancy_variants.end() || it->second.size() <= 1) {
        return func_name;
    }
    if (reent_key == 'R') {
        return func_name + "__reent";
    }
    return func_name + "__nonreent";
}

std::string CodeGenerator::variant_name(const std::string& func_name, const Symbol* func_sym,
                                        char reent_key, const std::string& ref_key) const {
    std::string name = reentrancy_variant_name(func_name, func_sym, reent_key);
    return ref_variant_name(name, ref_key);
}

bool CodeGenerator::receiver_is_mutable_arg(ExprPtr expr) const {
    return is_addressable_lvalue(expr) && is_mutable_lvalue(expr);
}

bool CodeGenerator::is_void_call(ExprPtr expr, std::string* name_out) const {
    if (!expr || expr->kind != Expr::Kind::Call) return false;
    if (!expr->operand || expr->operand->kind != Expr::Kind::Identifier) return false;
    Symbol* sym = binding_for(expr->operand);
    if (!sym || sym->kind != Symbol::Kind::Function || !sym->declaration) return false;
    if (sym->declaration->return_type || !sym->declaration->return_types.empty()) return false;

    if (name_out) {
        *name_out = expr->operand->name;
    }
    return true;
}

bool CodeGenerator::try_evaluate(ExprPtr expr, CTValue& out) const {
    if (!expr) return false;
    if (optimization) {
        auto it = optimization->constexpr_values.find(expr.get());
        if (it != optimization->constexpr_values.end()) {
            out = it->second;
            return true;
        }
    }
    if (!type_checker) return false;
    CompileTimeEvaluator evaluator(type_checker);
    return evaluator.try_evaluate(expr, out);
}

bool CodeGenerator::is_addressable_lvalue(ExprPtr expr) const {
    if (!expr) return false;
    switch (expr->kind) {
        case Expr::Kind::Identifier:
            return true;
        case Expr::Kind::Member:
        case Expr::Kind::Index:
            return is_addressable_lvalue(expr->operand);
        default:
            return false;
    }
}

bool CodeGenerator::is_mutable_lvalue(ExprPtr expr) const {
    if (!expr) return false;
    switch (expr->kind) {
        case Expr::Kind::Identifier:
            return expr->is_mutable_binding;
        case Expr::Kind::Member:
        case Expr::Kind::Index:
            return is_mutable_lvalue(expr->operand);
        default:
            return false;
    }
}

bool CodeGenerator::is_aggregate_type(TypePtr type) const {
    TypePtr resolved = resolve_type(type);
    if (!resolved) return false;
    if (resolved->kind == Type::Kind::Named) return true;
    return false;
}

bool CodeGenerator::is_pointer_like(TypePtr type) const {
    if (!type) return false;
    if (type->kind == Type::Kind::Array) return true;
    if (type->kind == Type::Kind::Primitive && type->primitive == PrimitiveType::String) return true;
    return false;
}

TypePtr CodeGenerator::resolve_type(TypePtr type) const {
    if (!type) return nullptr;
    if (type_checker) {
        return type_checker->resolve_type(type);
    }
    return type;
}

TypePtr CodeGenerator::resolve_ref_param_type_or_fail(StmtPtr stmt, size_t index) const {
    if (!stmt) return nullptr;
    TypePtr type = (index < stmt->ref_param_types.size()) ? stmt->ref_param_types[index] : nullptr;
    if (!type) return nullptr;
    if (type->kind != Type::Kind::TypeVar) return type;

    TypePtr resolved = resolve_type(type);
    if (resolved && resolved->kind != Type::Kind::TypeVar) {
        return resolved;
    }

    std::string ref_name = (index < stmt->ref_params.size()) ? stmt->ref_params[index] : ("ref#" + std::to_string(index));
    throw CompileError("Internal error: unresolved receiver type '" + ref_name +
                       "' in function '" + stmt->func_name + "'", stmt->location);
}

Symbol* CodeGenerator::binding_for(const void* node) const {
    if (!type_checker) return nullptr;
    return type_checker->binding_for(current_instance_id, node);
}

std::string CodeGenerator::instance_suffix(const Symbol* sym) const {
    if (!sym || sym->is_local) return "";
    if (sym->instance_id < 0 || sym->instance_id == entry_instance_id) return "";
    return "_s" + std::to_string(sym->instance_id);
}

std::string CodeGenerator::func_key_for(const Symbol* sym) const {
    if (!sym) return "";
    int key_id = (sym->instance_id == entry_instance_id) ? -1 : sym->instance_id;
    return reachability_key(sym->name, key_id);
}

int CodeGenerator::scope_id_for_symbol(const Symbol* sym) const {
    if (!sym) return -1;
    if (sym->is_local) return -1;
    if (sym->instance_id < 0 || sym->instance_id == entry_instance_id) return -1;
    return sym->instance_id;
}

PtrKind CodeGenerator::ptr_kind_for_expr(const ExprPtr& expr) const {
    if (!expr || !expr->type) return PtrKind::Ram;
    if (!is_pointer_like(expr->type)) return PtrKind::Ram;
    if (abi.expr_ptr_kind) {
        return abi.expr_ptr_kind(expr);
    }
    return PtrKind::Ram;
}

PtrKind CodeGenerator::ptr_kind_for_symbol(const std::string& name, int scope_id) const {
    if (!abi.symbol_ptr_kind) return PtrKind::Ram;
    return abi.symbol_ptr_kind(name, scope_id);
}

PtrKind CodeGenerator::ptr_kind_for_symbol(const Symbol* sym) const {
    if (!sym) return PtrKind::Ram;
    return ptr_kind_for_symbol(sym->name, scope_id_for_symbol(sym));
}

std::string CodeGenerator::c_type_for_expr(ExprPtr expr) {
    if (!expr || !expr->type) return "void";
    if (is_pointer_like(expr->type)) {
        if (ptr_kind_for_expr(expr) == PtrKind::Far) {
            return "uint32_t";
        }
    }
    return gen_type(expr->type);
}

bool CodeGenerator::expr_has_side_effects(ExprPtr expr) const {
    if (!expr) return false;
    switch (expr->kind) {
        case Expr::Kind::Call:
        case Expr::Kind::Assignment:
        case Expr::Kind::Process:
        case Expr::Kind::Resource:
            return true;
        case Expr::Kind::Binary:
            return expr_has_side_effects(expr->left) || expr_has_side_effects(expr->right);
        case Expr::Kind::Unary:
        case Expr::Kind::Cast:
        case Expr::Kind::Length:
            return expr_has_side_effects(expr->operand);
        case Expr::Kind::Conditional:
            return expr_has_side_effects(expr->condition) ||
                   expr_has_side_effects(expr->true_expr) ||
                   expr_has_side_effects(expr->false_expr);
        case Expr::Kind::Index:
        case Expr::Kind::Member:
            return expr_has_side_effects(expr->operand);
        case Expr::Kind::ArrayLiteral:
            for (const auto& el : expr->elements) {
                if (expr_has_side_effects(el)) return true;
            }
            return false;
        case Expr::Kind::TupleLiteral:
            for (const auto& el : expr->elements) {
                if (expr_has_side_effects(el)) return true;
            }
            return false;
        case Expr::Kind::Block:
            return true;
        case Expr::Kind::Iteration:
        case Expr::Kind::Repeat:
            return true;
        default:
            return false;
    }
}

std::string CodeGenerator::gen_expr(ExprPtr expr) {
    if (!expr) return "";
    std::string void_name;
    if (is_void_call(expr, &void_name) && !allow_void_call) {
        throw CompileError(
            "Function '" + void_name +
            "' has no return type; its result cannot be used as a value. "
            "Declare a return type or call it as a statement.",
            expr->location);
    }

    switch (expr->kind) {
        case Expr::Kind::IntLiteral:
            return std::to_string((int64_t)expr->uint_val);
        case Expr::Kind::FloatLiteral:
            return std::to_string(expr->float_val);
        case Expr::Kind::StringLiteral:
            {
                std::string lit = "\"" + escape_c_string(expr->string_val) + "\"";
                if (ptr_kind_for_expr(expr) == PtrKind::Far) {
                    std::string mod = current_module_id_expr.empty() ? "0" : current_module_id_expr;
                    return "VX_FARPTR(" + mod + ", " + lit + ")";
                }
                return lit;
            }
        case Expr::Kind::CharLiteral:
            return std::to_string(expr->uint_val);
        case Expr::Kind::Identifier:
            // Check if this is an expression parameter reference
            if (expr->is_expr_param_ref && expr_param_substitutions.count(expr->name)) {
                // Substitute the expression
                return gen_expr(expr_param_substitutions[expr->name]);
            }
            {
                auto value_it = value_param_replacements.find(expr->name);
                if (value_it != value_param_replacements.end()) {
                    return value_it->second;
                }
            }
            // Check if this is the underscore loop variable
            if (expr->name == "_" && !underscore_var.empty()) {
                return underscore_var;
            }
            {
                Symbol* sym = binding_for(expr);
                std::string name = mangle_name(expr->name);
                bool is_ref_param = current_ref_params.count(expr->name) > 0;
                bool is_agg_param = current_aggregate_params.count(expr->name) > 0;
                if (sym) {
                    name += instance_suffix(sym);
                }
                int scope_id = sym ? scope_id_for_symbol(sym) : -1;

                if (abi.symbol_load_expr) {
                    std::string load_expr = abi.symbol_load_expr(expr->name, scope_id, current_bank_page);
                    if (!load_expr.empty()) {
                        std::string load_fn = (current_bank_page == 'A') ? "vx_load_module_id_b" : "vx_load_module_id_a";
                        emit(load_fn + "(" + load_expr + ");");
                    }
                }

                if (expr->type && is_pointer_like(expr->type) &&
                    ptr_kind_for_symbol(sym) == PtrKind::Far) {
                    std::string mod_expr;
                    if (abi.symbol_module_id_expr) {
                        mod_expr = abi.symbol_module_id_expr(expr->name, scope_id, current_bank_page);
                    }
                    if (!mod_expr.empty()) {
                        return "VX_FARPTR(" + mod_expr + ", " + name + ")";
                    }
                }
                if (is_ref_param) {
                    return "(*" + name + ")";
                }
                if (is_agg_param) {
                    return "(*" + name + ")";
                }
                return name;
            }
        case Expr::Kind::Binary:
            return gen_binary(expr);
        case Expr::Kind::Unary:
            return gen_unary(expr);
        case Expr::Kind::Call:
            return gen_call(expr);
        case Expr::Kind::Index:
            return gen_index(expr);
        case Expr::Kind::Member:
            return gen_member(expr);
        case Expr::Kind::ArrayLiteral:
            return gen_array_literal(expr);
        case Expr::Kind::TupleLiteral:
            return gen_tuple_literal(expr);
        case Expr::Kind::Block:
            return gen_block(expr);
        case Expr::Kind::Conditional:
            return gen_conditional(expr);
        case Expr::Kind::Cast:
            return gen_cast(expr);
        case Expr::Kind::Assignment:
            return gen_assignment(expr);
        case Expr::Kind::Range:
            return gen_range(expr);
        case Expr::Kind::Length:
            return gen_length(expr);
        case Expr::Kind::Iteration:
            return gen_iteration(expr);
        case Expr::Kind::Repeat:
            return gen_repeat(expr);
        case Expr::Kind::Resource:
            return "";
        case Expr::Kind::Process:
            return "";
    }
    return "";
}

std::string CodeGenerator::gen_binary(ExprPtr expr) {
    std::string left;
    std::string right;
    {
        VoidCallGuard guard(*this, false);
        left = gen_expr(expr->left);
        right = gen_expr(expr->right);
    }
    if (expr->op == "==" || expr->op == "!=") {
        TypePtr cmp_type = expr->left ? expr->left->type : nullptr;
        if (!cmp_type && expr->left && expr->left->kind == Expr::Kind::Identifier) {
            Symbol* sym = binding_for(expr->left);
            if (sym) {
                cmp_type = sym->type;
            }
        }
        if (!cmp_type && expr->right) {
            cmp_type = expr->right->type;
        }
        if (cmp_type &&
            (cmp_type->kind == Type::Kind::Array ||
             cmp_type->kind == Type::Kind::Named ||
             (cmp_type->kind == Type::Kind::Primitive && cmp_type->primitive == PrimitiveType::String))) {
            std::string cmp_name = ensure_comparator(cmp_type);
            return "(" + cmp_name + "(" + left + ", " + right + ") " + expr->op + " 0)";
        }
    }
    return "(" + left + " " + expr->op + " " + right + ")";
}

std::string CodeGenerator::gen_unary(ExprPtr expr) {
    std::string operand;
    {
        VoidCallGuard guard(*this, false);
        operand = gen_expr(expr->operand);
    }
    return "(" + expr->op + operand + ")";
}

std::string CodeGenerator::gen_call(ExprPtr expr) {
    // Check if this is a type constructor call
    if (expr->operand && expr->operand->kind == Expr::Kind::Identifier &&
        expr->type && expr->type->kind == Type::Kind::Named) {

        Symbol* sym = binding_for(expr->operand);

        if (sym && sym->kind == Symbol::Kind::Type && sym->declaration) {
            // Generate C struct initialization
            std::string type_name = mangle_name(expr->operand->name);
            std::string result = "((" + type_name + "){";

            // Match arguments to fields by position
            {
                VoidCallGuard guard(*this, false);
                for (size_t i = 0; i < expr->args.size() && i < sym->declaration->fields.size(); i++) {
                    if (i > 0) result += ", ";
                    result += "." + mangle_name(sym->declaration->fields[i].name) + " = ";
                    result += gen_expr(expr->args[i]);
                }
            }

            result += "})";
            return result;
        }
    }

    // Check if this function has expression parameters - if so, inline it
    if (expr->operand && expr->operand->kind == Expr::Kind::Identifier) {
        Symbol* sym = binding_for(expr->operand);
        if (sym && sym->kind == Symbol::Kind::Function && sym->declaration) {
            // Check if any parameters are expression parameters
            bool has_expr_params = false;
            for (const auto& param : sym->declaration->params) {
                if (param.is_expression_param) {
                    has_expr_params = true;
                    break;
                }
            }

            if (has_expr_params) {
                // Inline the function body with expression parameter substitutions
                // Save current substitutions
                auto saved_substitutions = expr_param_substitutions;
                expr_param_substitutions.clear();
                auto saved_value_replacements = value_param_replacements;
                value_param_replacements.clear();

                // Map expression parameters to their argument expressions
                for (size_t i = 0; i < expr->args.size() && i < sym->declaration->params.size(); i++) {
                    const auto& param = sym->declaration->params[i];
                    if (param.is_expression_param) {
                        expr_param_substitutions[param.name] = expr->args[i];
                    } else {
                        std::string arg_expr;
                        {
                            VoidCallGuard guard(*this, false);
                            arg_expr = gen_expr(expr->args[i]);
                        }
                        value_param_replacements[param.name] = arg_expr;
                    }
                }

                // Generate the inlined function body
                std::string result = gen_expr(sym->declaration->body);

                // Restore previous substitutions
                expr_param_substitutions = saved_substitutions;
                value_param_replacements = saved_value_replacements;

                return result;
            }
        }
    }

    // Regular function call or method call
    std::string func_name;
    std::string ref_key;
    std::vector<std::string> all_args;

    Symbol* sym = nullptr;
    StmtPtr callee_decl;
    bool is_external = false;
    std::string base_name;
    std::string func_key;

    // Get function name (already qualified by type checker for methods)
    if (expr->operand && expr->operand->kind == Expr::Kind::Identifier) {
        // Look up symbol to get original function name and instance
        base_name = expr->operand->name;
        sym = binding_for(expr->operand);
        if (sym && sym->declaration && sym->kind == Symbol::Kind::Function) {
            callee_decl = sym->declaration;
            base_name = sym->name;
            is_external = sym->is_external || callee_decl->is_external;
        }

        if (callee_decl) {
            if (!callee_decl->ref_params.empty()) {
                if (is_external) {
                    ref_key = std::string(callee_decl->ref_params.size(), 'M');
                } else {
                    ref_key = ref_variant_key(expr, callee_decl->ref_params.size());
                }
            }
            if (!is_external) {
                func_key = func_key_for(sym);
                std::string variant = variant_name(base_name, sym, current_reentrancy_key, ref_key);
                func_name = mangle_name(variant) + instance_suffix(sym);
            } else if (!ref_key.empty()) {
                std::string variant = ref_variant_name(base_name, ref_key);
                func_name = mangle_name(variant);
            } else {
                func_name = mangle_name(base_name);
            }
        } else {
            func_name = mangle_name(base_name);
        }
    } else if (expr->operand) {
        VoidCallGuard guard(*this, false);
        func_name = gen_expr(expr->operand);
    }

    CallTargetInfo target;
    if (abi.resolve_call && callee_decl && !is_external && !func_key.empty()) {
        target = abi.resolve_call(expr, base_name, func_key, current_variant_id, current_bank_page, ref_key);
        if (!target.name.empty()) {
            if (target.name_is_mangled) {
                func_name = target.name;
            } else {
                func_name = mangle_name(target.name);
            }
            func_name += instance_suffix(sym);
        }
    }

    bool returns_aggregate = false;
    std::string agg_out_type;
    if (abi.lower_aggregates && callee_decl && !is_external) {
        bool returns_tuple = !callee_decl->return_types.empty();
        TypePtr return_type_ptr = nullptr;
        if (!returns_tuple) {
            if (callee_decl->return_type) {
                return_type_ptr = callee_decl->return_type;
            } else if (callee_decl->body && callee_decl->body->type) {
                return_type_ptr = callee_decl->body->type;
            }
        }
        if (returns_tuple || is_aggregate_type(return_type_ptr)) {
            returns_aggregate = true;
            if (returns_tuple) {
                std::string tuple_name = std::string(TUPLE_TYPE_PREFIX) + std::to_string(callee_decl->return_types.size());
                for (const auto& t : callee_decl->return_types) {
                    tuple_name += "_";
                    if (t) {
                        tuple_name += t->to_string();
                    } else {
                        tuple_name += "unknown";
                    }
                }
                agg_out_type = mangle_name(tuple_name);
            } else if (return_type_ptr) {
                agg_out_type = gen_type(return_type_ptr);
            }
        }
    }

    std::vector<bool> param_is_aggregate;
    if (abi.lower_aggregates && callee_decl) {
        for (const auto& param : callee_decl->params) {
            if (param.is_expression_param) continue;
            param_is_aggregate.push_back(param.type && is_aggregate_type(param.type));
        }
    }

    // Handle method calls with receivers - add them as first arguments
    if (!expr->receivers.empty()) {
        for (size_t i = 0; i < expr->receivers.size(); i++) {
            ExprPtr rec = expr->receivers[i];
            bool by_ref = receiver_is_mutable_arg(rec);
            if (!ref_key.empty() && i < ref_key.size()) {
                by_ref = ref_key[i] == 'M';
            }
            if (abi.lower_aggregates && rec && rec->type && is_aggregate_type(rec->type)) {
                by_ref = true;
            }
            if (by_ref) {
                if (is_addressable_lvalue(rec) && is_mutable_lvalue(rec)) {
                    std::string rec_expr;
                    {
                        VoidCallGuard guard(*this, false);
                        rec_expr = gen_expr(rec);
                    }
                    all_args.push_back("&" + rec_expr);
                } else {
                    std::string temp = fresh_temp();
                    if (!rec || !rec->type) {
                        throw CompileError("Missing receiver type for call", rec ? rec->location : expr->location);
                    }
                    std::string rtype = gen_type(rec->type);
                    std::string rec_expr;
                    {
                        VoidCallGuard guard(*this, false);
                        rec_expr = gen_expr(rec);
                    }
                    emit(rtype + " " + temp + " = " + rec_expr + ";");
                    all_args.push_back("&" + temp);
                }
            } else {
                std::string rec_expr;
                {
                    VoidCallGuard guard(*this, false);
                    rec_expr = gen_expr(rec);
                }
                all_args.push_back(rec_expr);
            }
        }
    }

    // Add regular arguments (skip expression parameters)
    size_t param_idx = 0;
    size_t agg_idx = 0;
    for (size_t i = 0; i < expr->args.size(); i++) {
        // Check if this argument corresponds to an expression parameter
        if (expr->operand && expr->operand->kind == Expr::Kind::Identifier) {
            Symbol* psym = binding_for(expr->operand);
            if (psym && psym->kind == Symbol::Kind::Function && psym->declaration &&
                param_idx < psym->declaration->params.size() &&
                psym->declaration->params[param_idx].is_expression_param) {
                param_idx++;
                continue;  // Skip expression parameters
            }
        }
        bool by_ref = (agg_idx < param_is_aggregate.size() && param_is_aggregate[agg_idx]);
        std::string arg_expr;
        {
            VoidCallGuard guard(*this, false);
            arg_expr = gen_expr(expr->args[i]);
        }
        if (by_ref) {
            if (is_addressable_lvalue(expr->args[i])) {
                all_args.push_back("&" + arg_expr);
            } else {
                std::string temp = fresh_temp();
                if (!expr->args[i] || !expr->args[i]->type) {
                    throw CompileError("Missing argument type for call", expr->args[i] ? expr->args[i]->location : expr->location);
                }
                std::string atype = gen_type(expr->args[i]->type);
                emit(atype + " " + temp + " = " + arg_expr + ";");
                all_args.push_back("&" + temp);
            }
        } else {
            all_args.push_back(arg_expr);
        }
        param_idx++;
        agg_idx++;
    }

    std::string out_temp;
    if (returns_aggregate) {
        out_temp = fresh_temp();
        if (!declared_temps.count(out_temp)) {
            emit(storage_prefix() + agg_out_type + " " + out_temp + ";");
            declared_temps.insert(out_temp);
        }
        all_args.insert(all_args.begin(), "&" + out_temp);
    }

    if (!target.module_id_expr.empty()) {
        std::string load_fn = (target.page == 'A') ? "vx_load_module_id_a" : "vx_load_module_id_b";
        emit(load_fn + "(" + target.module_id_expr + ");");
    }

    std::string result = func_name + "(";
    for (size_t i = 0; i < all_args.size(); i++) {
        if (i > 0) result += ", ";
        result += all_args[i];
    }
    result += ")";

    if (returns_aggregate) {
        emit(result + ";");
        if (allow_void_call) {
            return "";
        }
        return out_temp;
    }

    return result;
}

std::string CodeGenerator::gen_index(ExprPtr expr) {
    std::string arr;
    std::string idx;
    {
        VoidCallGuard guard(*this, false);
        arr = gen_expr(expr->operand);
        idx = gen_expr(expr->args[0]);
    }
    if (ptr_kind_for_expr(expr->operand) == PtrKind::Far) {
        std::string ptr_expr = arr;
        if (expr_has_side_effects(expr->operand)) {
            std::string temp = fresh_temp();
            if (!declared_temps.count(temp)) {
                emit(storage_prefix() + std::string("uint32_t ") + temp + ";");
                declared_temps.insert(temp);
            }
            emit(temp + " = " + arr + ";");
            ptr_expr = temp;
        }
        std::string load_fn = (current_bank_page == 'A') ? "vx_load_module_id_b" : "vx_load_module_id_a";
        emit(load_fn + "(VX_FARPTR_MOD(" + ptr_expr + "));");
        std::string elem_type = require_type(expr->type,
                                             expr->location,
                                             "index expression element type");
        return "(((" + elem_type + "*)VX_FARPTR_ADDR(" + ptr_expr + "))[" + idx + "])";
    }
    return arr + "[" + idx + "]";
}

std::string CodeGenerator::gen_member(ExprPtr expr) {
    bool operand_is_ref = false;
    std::string obj;
    if (expr->operand && expr->operand->kind == Expr::Kind::Identifier &&
        (current_ref_params.count(expr->operand->name) ||
         current_aggregate_params.count(expr->operand->name))) {
        operand_is_ref = true;
        obj = mangle_name(expr->operand->name);
        Symbol* sym = binding_for(expr->operand);
        if (sym) {
            obj += instance_suffix(sym);
        }
    } else {
        VoidCallGuard guard(*this, false);
        obj = gen_expr(expr->operand);
    }

    // Check if the operand is a reference parameter (pointer in C)
    std::string accessor = operand_is_ref ? "->" : ".";

    // Don't mangle compiler-generated tuple field names (e.g., __0, __1)
    std::string member_name = expr->name;
    if (member_name.size() < 2 || member_name.substr(0, 2) != MANGLED_PREFIX) {
        member_name = mangle_name(member_name);
    }

    return obj + accessor + member_name;
}

std::string CodeGenerator::gen_array_literal(ExprPtr expr) {
    std::string temp = fresh_temp();

    // Determine element type
    if (!expr->type || expr->type->kind != Type::Kind::Array || !expr->type->element_type) {
        throw CompileError("Missing array element type for array literal", expr->location);
    }
    std::string elem_type = gen_type(expr->type->element_type);

    size_t count = expr->elements.size();
    size_t storage_count = count == 0 ? 1 : count;
    // Generate array declaration and initialization
    // Use static to ensure it persists beyond the current scope (important for struct fields)
    emit("static " + elem_type + " " + temp + "[" + std::to_string(storage_count) + "] = {");
    {
        VoidCallGuard guard(*this, false);
        for (size_t i = 0; i < count; i++) {
            if (i > 0) emit(", ");
            emit(gen_expr(expr->elements[i]));
        }
    }
    emit("};");

    if (ptr_kind_for_expr(expr) == PtrKind::Far) {
        std::string mod = current_module_id_expr.empty() ? "0" : current_module_id_expr;
        return "VX_FARPTR(" + mod + ", " + temp + ")";
    }
    return temp;
}

std::string CodeGenerator::gen_tuple_literal(ExprPtr expr) {
    // Generate tuple struct literal: (Type){.field0 = val0, .field1 = val1, ...}
    std::string type_name = require_type(expr->type,
                                         expr->location,
                                         "tuple literal type");

    // Track this tuple type for declaration generation
    if (expr->type && expr->type->kind == Type::Kind::Named) {
        std::string tuple_name = expr->type->type_name;
        if (tuple_name.find(TUPLE_TYPE_PREFIX) == 0 && !tuple_types.count(tuple_name)) {
            // Collect element types
            std::vector<TypePtr> elem_types;
            for (const auto& elem : expr->elements) {
                elem_types.push_back(elem->type);
            }
            tuple_types[tuple_name] = elem_types;
        }
    }

    std::string result = "((" + type_name + "){";
    {
        VoidCallGuard guard(*this, false);
        for (size_t i = 0; i < expr->elements.size(); i++) {
            if (i > 0) result += ", ";
            result += ".__" + std::to_string(i) + " = ";
            result += gen_expr(expr->elements[i]);
        }
    }
    result += "})";

    return result;
}

std::string CodeGenerator::gen_block(ExprPtr expr) {
    if (allow_void_call) {
        emit("{");
        for (const auto& stmt : expr->statements) {
            gen_stmt(stmt);
        }
        if (expr->result_expr) {
            std::string result = gen_expr(expr->result_expr);
            if (!result.empty()) {
                emit(result + ";");
            }
        }
        emit("}");
        return "";
    }

    if (!expr->result_expr) {
        throw CompileError("Block expression has no result; use it as a statement or add a final expression",
                           expr->location);
    }

    std::string temp = fresh_temp();
    std::string result_type;

    // Infer result type from expression type or result_expr type
    if (expr->type) {
        result_type = gen_type(expr->type);
        if (is_pointer_like(expr->type) && ptr_kind_for_expr(expr) == PtrKind::Far) {
            result_type = "uint32_t";
        }
    } else if (expr->result_expr && expr->result_expr->type) {
        result_type = gen_type(expr->result_expr->type);
        if (is_pointer_like(expr->result_expr->type) &&
            ptr_kind_for_expr(expr->result_expr) == PtrKind::Far) {
            result_type = "uint32_t";
        }
    } else {
        throw CompileError("Missing type for block expression result", expr->location);
    }

    // Declare temp variable outside block scope only if not already declared
    if (!declared_temps.count(temp)) {
        emit(storage_prefix() + result_type + " " + temp + ";");
        declared_temps.insert(temp);
    }

    emit("{");
    for (const auto& stmt : expr->statements) {
        gen_stmt(stmt);
    }

    std::string result;
    {
        VoidCallGuard guard(*this, false);
        result = gen_expr(expr->result_expr);
    }
    emit(temp + " = " + result + ";");
    // Release the result temp if it's a temporary
    if (result.substr(0, 3) == "tmp") {
        release_temp(result);
    }
    emit("}");

    return temp;
}

std::string CodeGenerator::gen_block_optimized(ExprPtr expr) {
    if (!type_checker) return "";

    CompileTimeEvaluator evaluator(type_checker);
    std::ostringstream optimized;

    // Process each statement
    for (const auto& stmt : expr->statements) {
        if (stmt->kind == Stmt::Kind::Expr && stmt->expr) {
            // Handle assignment expressions
            if (stmt->expr->kind == Expr::Kind::Assignment &&
                stmt->expr->left->kind == Expr::Kind::Identifier) {

                std::string var_name = stmt->expr->left->name;

                // Try to evaluate RHS at compile-time
                CTValue rhs_val;
                if (evaluator.try_evaluate(stmt->expr->right, rhs_val)) {
                    // Store compile-time value in evaluator, don't generate code
                    evaluator.set_constant(var_name, rhs_val);
                    continue;
                }
                // Can't evaluate - must generate runtime code
                return "";
            }

            // Handle other expressions (like function calls)
            // Check if it's a call to external function
            if (stmt->expr->kind == Expr::Kind::Call) {
                // Try to evaluate arguments and generate optimized call
                std::string call_str = gen_call_optimized_with_evaluator(stmt->expr, evaluator);
                if (!call_str.empty()) {
                    optimized << call_str << ";\n";
                    continue;
                }
                // Can't optimize, bail out
                return "";
            }

            // Try to evaluate other expressions with current compile-time context
            CTValue stmt_val;
            if (!evaluator.try_evaluate(stmt->expr, stmt_val)) {
                return "";
            }
        } else if (stmt->kind == Stmt::Kind::VarDecl) {
            // Try to evaluate initializer
            if (stmt->var_init) {
                CTValue init_val;
                if (evaluator.try_evaluate(stmt->var_init, init_val)) {
                    evaluator.set_constant(stmt->var_name, init_val);
                    continue;
                } else {
                    // Can't evaluate (e.g., array literal)
                    // Store a placeholder so references to this variable won't fail
                    evaluator.set_constant(stmt->var_name, (int64_t)0);
                    // Don't generate code for it - we'll inline everything
                    continue;
                }
            }
        } else {
            // Can't handle this statement type
            return "";
        }
    }

    // Try to evaluate result expression
    if (expr->result_expr) {
        CTValue result_val;
        if (evaluator.try_evaluate(expr->result_expr, result_val)) {
            std::string value;
            if (std::holds_alternative<int64_t>(result_val)) {
                value = std::to_string(std::get<int64_t>(result_val));
            } else if (std::holds_alternative<uint64_t>(result_val)) {
                value = std::to_string(std::get<uint64_t>(result_val));
            }
            if (!value.empty()) {
                if (current_returns_aggregate) {
                    optimized << "*" << aggregate_out_param << " = " << value << ";\n";
                    append_return_prefix(optimized);
                    optimized << "return;\n";
                } else {
                    append_return_prefix(optimized);
                    optimized << "return " << value << ";\n";
                }
                return optimized.str();
            }
        }
    }

    return "";
}

std::string CodeGenerator::gen_call_optimized_with_evaluator(ExprPtr expr, CompileTimeEvaluator& evaluator) {
    if (!expr || expr->kind != Expr::Kind::Call) return "";
    if (!expr->operand || expr->operand->kind != Expr::Kind::Identifier) return "";

    std::string func_name = expr->operand->name;

    // Check if it's an external function
    Symbol* sym = binding_for(expr->operand);
    if (!sym || sym->kind != Symbol::Kind::Function || !sym->declaration) return "";
    if (!sym->declaration->is_external) return "";

    // Try to evaluate all arguments at compile-time
    std::vector<std::string> arg_strs;

    for (const auto& arg : expr->args) {
        CTValue arg_val;
        if (evaluator.try_evaluate(arg, arg_val)) {
            if (std::holds_alternative<int64_t>(arg_val)) {
                arg_strs.push_back(std::to_string(std::get<int64_t>(arg_val)));
            } else if (std::holds_alternative<uint64_t>(arg_val)) {
                arg_strs.push_back(std::to_string(std::get<uint64_t>(arg_val)));
            } else {
                return "";
            }
        } else {
            return "";
        }
    }

    // Generate optimized call
    std::string result = mangle_name(func_name) + "(";
    for (size_t i = 0; i < arg_strs.size(); i++) {
        if (i > 0) result += ", ";
        result += arg_strs[i];
    }
    result += ")";
    return result;
}

std::string CodeGenerator::gen_conditional(ExprPtr expr) {
    // Try to evaluate condition at compile time for dead branch elimination
    {
        CTValue cond_val;
        if (try_evaluate(expr->condition, cond_val)) {
            // Condition is compile-time constant - eliminate dead branch
            bool is_true = false;
            if (std::holds_alternative<int64_t>(cond_val)) {
                is_true = std::get<int64_t>(cond_val) != 0;
            } else if (std::holds_alternative<bool>(cond_val)) {
                is_true = std::get<bool>(cond_val);
            } else if (std::holds_alternative<uint64_t>(cond_val)) {
                is_true = std::get<uint64_t>(cond_val) != 0;
            }

            if (is_true) {
                if (allow_void_call) {
                    return gen_expr(expr->true_expr);
                }
                VoidCallGuard guard(*this, false);
                return gen_expr(expr->true_expr);
            } else {
                if (allow_void_call) {
                    return gen_expr(expr->false_expr);
                }
                VoidCallGuard guard(*this, false);
                return gen_expr(expr->false_expr);
            }
        }
    }

    // Runtime conditional
    std::string cond;
    {
        VoidCallGuard guard(*this, false);
        cond = gen_expr(expr->condition);
    }
    std::string true_expr;
    std::string false_expr;
    if (allow_void_call) {
        true_expr = gen_expr(expr->true_expr);
        false_expr = gen_expr(expr->false_expr);
    } else {
        VoidCallGuard guard(*this, false);
        true_expr = gen_expr(expr->true_expr);
        false_expr = gen_expr(expr->false_expr);
    }
    return "(" + cond + " ? " + true_expr + " : " + false_expr + ")";
}

std::string CodeGenerator::gen_cast(ExprPtr expr) {
    // Primitive to byte array conversion (big-endian order)
    if (expr->target_type && expr->target_type->kind == Type::Kind::Array &&
        expr->target_type->element_type &&
        expr->target_type->element_type->kind == Type::Kind::Primitive &&
        expr->target_type->element_type->primitive == PrimitiveType::U8 &&
        expr->operand && expr->operand->type &&
        expr->operand->type->kind == Type::Kind::Primitive &&
        !is_float(expr->operand->type->primitive)) {

        int64_t length = resolve_array_length(expr->target_type, expr->location);
        int bits = type_bits(expr->operand->type->primitive);
        if (bits / 8 != length) {
            throw CompileError("Array length/type size mismatch in cast", expr->location);
        }

        std::string source_val;
        {
            VoidCallGuard guard(*this, false);
            source_val = gen_expr(expr->operand);
        }
        std::string source_tmp = fresh_temp();
        std::string source_type = gen_type(expr->operand->type);
        if (!declared_temps.count(source_tmp)) {
            emit(storage_prefix() + source_type + " " + source_tmp + ";");
            declared_temps.insert(source_tmp);
        }
        emit(source_tmp + " = " + source_val + ";");

        std::string result = fresh_temp();
        std::string elem_type = gen_type(expr->target_type->element_type);
        std::string size_str = std::to_string(length);
        if (!declared_temps.count(result)) {
            emit(storage_prefix() + elem_type + " " + result + "[" + size_str + "];");
            declared_temps.insert(result);
        }

        for (int64_t i = 0; i < length; ++i) {
            int64_t shift = (length - 1 - i) * 8;
            emit(result + "[" + std::to_string(i) + "] = (" + elem_type + ")((" + source_tmp +
                 " >> " + std::to_string(shift) + ") & 0xFF);");
        }

        return result;
    }

    // Special-case: pack boolean arrays into unsigned integers
    if (expr->operand && expr->operand->type &&
        expr->operand->type->kind == Type::Kind::Array &&
        expr->operand->type->element_type &&
        expr->operand->type->element_type->kind == Type::Kind::Primitive &&
        expr->operand->type->element_type->primitive == PrimitiveType::Bool &&
        expr->target_type && expr->target_type->kind == Type::Kind::Primitive &&
        is_unsigned_int(expr->target_type->primitive)) {

        int64_t length = resolve_array_length(expr->operand->type, expr->location);
        std::string target = gen_type(expr->target_type);
        std::string source;
        {
            VoidCallGuard guard(*this, false);
            source = gen_expr(expr->operand);
        }
        std::string temp = fresh_temp();
        if (!declared_temps.count(temp)) {
            emit(storage_prefix() + target + " " + temp + ";");
            declared_temps.insert(temp);
        }
        emit(temp + " = 0;");
        for (int64_t i = 0; i < length; ++i) {
            int64_t shift = (length - 1 - i);
            emit(temp + " |= (" + source + "[" + std::to_string(i) + "] ? (" + target + ")(1u << " + std::to_string(shift) + ") : 0);");
        }
        return temp;
    }

    std::string target = gen_type(expr->target_type);
    std::string operand;
    {
        VoidCallGuard guard(*this, false);
        operand = gen_expr(expr->operand);
    }
    return "((" + target + ")" + operand + ")";
}

std::string CodeGenerator::gen_assignment(ExprPtr expr) {
    // Use the flag set by the typechecker to determine if this creates a new variable
    if (expr->creates_new_variable) {
        TypePtr var_type = expr->left->type ? expr->left->type : expr->type;
        std::string var_type_str = gen_type(var_type);
        if (var_type && is_pointer_like(var_type) && var_type->kind != Type::Kind::Array) {
            Symbol* sym = binding_for(expr->left);
            if (ptr_kind_for_symbol(sym) == PtrKind::Far) {
                var_type_str = "uint32_t";
            }
        }
        std::string var_name = mangle_name(expr->left->name);
        if (Symbol* sym = binding_for(expr->left)) {
            var_name += instance_suffix(sym);
        }

        // For array declarations, we need to handle the literal specially
        if (var_type && var_type->kind == Type::Kind::Array && expr->right->kind == Expr::Kind::ArrayLiteral) {
            // Generate array literal inline with correct type
            std::string elem_type = gen_type(var_type->element_type);

            // Get array size
            std::string size_str = "0";
            if (var_type->array_size) {
                CTValue size_val;
                if (try_evaluate(var_type->array_size, size_val)) {
                    size_str = std::to_string(std::get<int64_t>(size_val));
                }
            }

            emit(elem_type + " " + var_name + "[" + size_str + "] = {");
            {
                VoidCallGuard guard(*this, false);
                for (size_t i = 0; i < expr->right->elements.size(); i++) {
                    if (i > 0) emit(", ");
                    emit(gen_expr(expr->right->elements[i]));
                }
            }
            emit("};");

            std::string temp = fresh_temp();
            emit(storage_prefix() + std::string("int ") + temp + " = 0;");
            return temp;
        }

        std::string rhs;
        {
            VoidCallGuard guard(*this, false);
            rhs = gen_expr(expr->right);
        }
        // Release RHS temp if it's a temporary
        if (rhs.substr(0, 3) == "tmp") {
            release_temp(rhs);
        }
        std::string temp = fresh_temp();
        emit(var_type_str + " " + var_name + " = " + rhs + ";");
        emit(storage_prefix() + std::string("int ") + temp + " = 0;"); // Assignment as expression returns dummy value
        return temp;
    }

    // Regular assignment
    std::string lhs;
    std::string rhs;
    {
        VoidCallGuard guard(*this, false);
        lhs = gen_expr(expr->left);
        rhs = gen_expr(expr->right);
    }
    // Release RHS temp if it's a temporary
    if (rhs.substr(0, 3) == "tmp") {
        release_temp(rhs);
    }
    return "(" + lhs + " = " + rhs + ")";
}

std::optional<std::pair<int64_t, int64_t>> CodeGenerator::evaluate_range(ExprPtr range_expr) {
    if (!range_expr || range_expr->kind != Expr::Kind::Range) {
        return std::nullopt;
    }

    CTValue start_val, end_val;
    if (try_evaluate(range_expr->left, start_val) &&
        try_evaluate(range_expr->right, end_val)) {
        return std::make_pair(std::get<int64_t>(start_val), std::get<int64_t>(end_val));
    }
    return std::nullopt;
}

std::string CodeGenerator::gen_range(ExprPtr expr) {
    auto bounds = evaluate_range(expr);
    if (!bounds) {
        throw CompileError("Range bounds must be compile-time constants", expr->location);
    }

    int64_t start = bounds->first;
    int64_t end = bounds->second;

    if (start == end) {
        throw CompileError("Range cannot produce an empty array; bounds must differ", expr->location);
    }

    std::string temp = fresh_temp();
    std::string elem_type = "int32_t";
    if (expr->type && expr->type->kind == Type::Kind::Array && expr->type->element_type) {
        elem_type = gen_type(expr->type->element_type);
    }

    int64_t size = (start < end) ? (end - start) : (start - end);
    if (size <= 0) {
        throw CompileError("Invalid range bounds", expr->location);
    }

    std::ostringstream init;
    init << storage_prefix() << elem_type << " " << temp << "[" << size << "] = {";
    bool first = true;
    if (start < end) {
        for (int64_t i = start; i < end; ++i) {
            if (!first) init << ", ";
            first = false;
            init << i;
        }
    } else {
        for (int64_t i = start; i > end; --i) {
            if (!first) init << ", ";
            first = false;
            init << i;
        }
    }
    init << "};";
    emit(init.str());
    return temp;
}

std::string CodeGenerator::gen_length(ExprPtr expr) {
    // Array length or absolute value
    if (expr->operand->type) {
        if (expr->operand->type->kind == Type::Kind::Array) {
            // Array length - try to evaluate at compile time
            if (expr->operand->type->array_size) {
                CTValue size_val;
                if (try_evaluate(expr->operand->type->array_size, size_val)) {
                    return std::to_string(std::get<int64_t>(size_val));
                }
            }
            throw CompileError("Array length must be a compile-time constant", expr->location);
        } else if (expr->operand->type->kind == Type::Kind::Primitive &&
                   expr->operand->type->primitive == PrimitiveType::String) {
            // String length - compile time constant
            if (expr->operand->kind == Expr::Kind::StringLiteral) {
                return std::to_string(expr->operand->string_val.size());
            }
            std::string operand;
            {
                VoidCallGuard guard(*this, false);
                operand = gen_expr(expr->operand);
            }
            if (ptr_kind_for_expr(expr->operand) == PtrKind::Far) {
                std::string fn = (current_bank_page == 'A') ? "vx_strlen_far_b" : "vx_strlen_far_a";
                return fn + "(" + operand + ")";
            }
            return "strlen(" + operand + ")";
        }
    }

    // Absolute value for numeric types
    std::string operand;
    {
        VoidCallGuard guard(*this, false);
        operand = gen_expr(expr->operand);
    }
    if (expr->operand->type && expr->operand->type->kind == Type::Kind::Primitive) {
        if (is_float(expr->operand->type->primitive)) {
            return "fabs(" + operand + ")";
        } else if (is_signed_int(expr->operand->type->primitive)) {
            return "abs(" + operand + ")";
        } else {
            // Unsigned - identity
            return operand;
        }
    }
    return "abs(" + operand + ")";
}

std::string CodeGenerator::gen_iteration(ExprPtr expr) {
    if (!expr->operand || !expr->operand->type || expr->operand->type->kind != Type::Kind::Array) {
        throw CompileError("Iteration requires array or range", expr->location);
    }

    TypePtr array_type = expr->operand->type;
    TypePtr element_type = array_type->element_type;
    std::string element_c_type = require_type(element_type,
                                              array_type->location,
                                              "iteration element type");

    std::string size_str;
    int64_t element_count = 0;
    auto value_to_int64 = [&](const CTValue& v, const SourceLocation& loc) -> int64_t {
        if (std::holds_alternative<int64_t>(v)) {
            return std::get<int64_t>(v);
        }
        if (std::holds_alternative<uint64_t>(v)) {
            return static_cast<int64_t>(std::get<uint64_t>(v));
        }
        throw CompileError("Iteration bounds must be integer constants", loc);
    };

    if (expr->operand->kind == Expr::Kind::Range) {
        CTValue start_val, end_val;
        if (!try_evaluate(expr->operand->left, start_val) ||
            !try_evaluate(expr->operand->right, end_val)) {
            throw CompileError("Range iteration requires compile-time constant bounds", expr->location);
        }
        int64_t start = value_to_int64(start_val, expr->operand->left->location);
        int64_t end = value_to_int64(end_val, expr->operand->right->location);
        element_count = (start < end) ? (end - start) : (start - end);
        if (element_count <= 0) {
            throw CompileError("Range iteration produced empty sequence", expr->location);
        }
        size_str = std::to_string(element_count);
    } else {
        if (!array_type->array_size) {
            throw CompileError("Array size must be compile-time constant for iteration", expr->location);
        }
        CTValue size_val;
        if (!try_evaluate(array_type->array_size, size_val)) {
            throw CompileError("Array size must be compile-time constant for iteration", expr->location);
        }
        element_count = value_to_int64(size_val, array_type->array_size->location);
        if (element_count < 0) {
            throw CompileError("Array size cannot be negative", expr->location);
        }
        size_str = std::to_string(element_count);
    }

    std::string array_expr;
    {
        VoidCallGuard guard(*this, false);
        array_expr = gen_expr(expr->operand);
    }
    std::string array_ptr = fresh_temp();
    std::string loop_var = fresh_temp();
    std::string underscore = fresh_temp();

    emit("{");
    emit("  " + element_c_type + "* " + array_ptr + " = " + array_expr + ";");

    if (expr->is_sorted_iteration && element_count > 1) {
        if (!element_type) {
            throw CompileError("Cannot sort array with unknown element type", expr->location);
        }
        std::string copy_var = fresh_temp();
        std::string sort_buffer = fresh_temp();
        std::string cmp_name = ensure_comparator(element_type);
        std::string i_var = fresh_temp();
        std::string j_var = fresh_temp();
        std::string key_var = fresh_temp();

        emit("  " + storage_prefix() + element_c_type + " " + sort_buffer + "[" + size_str + "];");
        emit("  for (int " + copy_var + " = 0; " + copy_var + " < " + size_str + "; " + copy_var + "++) {");
        emit("    " + sort_buffer + "[" + copy_var + "] = " + array_ptr + "[" + copy_var + "];");
        emit("  }");
        emit("  for (int " + i_var + " = 1; " + i_var + " < " + size_str + "; " + i_var + "++) {");
        emit("    " + element_c_type + " " + key_var + " = " + sort_buffer + "[" + i_var + "];");
        emit("    int " + j_var + " = " + i_var + " - 1;");
        emit("    while (" + j_var + " >= 0 && " + cmp_name + "(" + sort_buffer + "[" + j_var + "], " + key_var + ") > 0) {");
        emit("      " + sort_buffer + "[" + j_var + " + 1] = " + sort_buffer + "[" + j_var + "];");
        emit("      " + j_var + " = " + j_var + " - 1;");
        emit("    }");
        emit("    " + sort_buffer + "[" + j_var + " + 1] = " + key_var + ";");
        emit("  }");
        emit("  " + array_ptr + " = " + sort_buffer + ";");
    }

    emit("  for (int " + loop_var + " = 0; " + loop_var + " < " + size_str + "; " + loop_var + "++) {");
    emit("    " + element_c_type + " " + underscore + " = " + array_ptr + "[" + loop_var + "];");

    std::string saved_underscore = underscore_var;
    underscore_var = underscore;

    std::string body_code;
    {
        VoidCallGuard guard(*this, true);
        body_code = gen_expr(expr->right);
    }
    if (!body_code.empty()) {
        emit("    " + body_code + ";");
    }

    underscore_var = saved_underscore;

    emit("  }");
    emit("}");

    return "";
}

std::string CodeGenerator::gen_repeat(ExprPtr expr) {
    std::string cond;
    {
        VoidCallGuard guard(*this, false);
        cond = gen_expr(expr->condition);
    }
    emit("while (" + cond + ") {");
    std::string body_code;
    {
        VoidCallGuard guard(*this, true);
        body_code = gen_expr(expr->right);
    }
    if (!body_code.empty()) {
        emit("  " + body_code + ";");
    }
    emit("}");
    return "";
}

std::string CodeGenerator::require_type(TypePtr type, const SourceLocation& loc, const std::string& context) {
    if (!type) {
        throw CompileError("Missing type during code generation: " + context, loc);
    }
    return gen_type(type);
}

std::string CodeGenerator::gen_type(TypePtr type) {
    if (!type) return "void";

    switch (type->kind) {
        case Type::Kind::Primitive:
            switch (type->primitive) {
                case PrimitiveType::I8: return "int8_t";
                case PrimitiveType::I16: return "int16_t";
                case PrimitiveType::I32: return "int32_t";
                case PrimitiveType::I64: return "int64_t";
                case PrimitiveType::U8: return "uint8_t";
                case PrimitiveType::U16: return "uint16_t";
                case PrimitiveType::U32: return "uint32_t";
                case PrimitiveType::U64: return "uint64_t";
                case PrimitiveType::F32: return "float";
                case PrimitiveType::F64: return "double";
                case PrimitiveType::Bool: return "_Bool";
                case PrimitiveType::String: return "const char*";
            }
            break;

        case Type::Kind::Array: {
            std::string elem = gen_type(type->element_type);
            // Simplified: size would need compile-time evaluation
            return elem + "*";
        }

        case Type::Kind::Named:
            if (type_map.count(type->type_name)) {
                return type_map[type->type_name];
            }
            return mangle_name(type->type_name);

        case Type::Kind::TypeVar:
            throw CompileError("Type could not be inferred; add an explicit type annotation", type->location);
    }

    return "void";
}

std::string CodeGenerator::mangle_name(const std::string& name) {
    // Special case: main function doesn't get mangled
    if (name == "main") {
        return "main";
    }

    std::string result = "vx_";
    auto append_encoded = [&](unsigned char c) {
        if (std::isalnum(c) || c == '_') {
            result.push_back(static_cast<char>(c));
        } else {
            std::ostringstream oss;
            oss << "_" << std::uppercase << std::hex << std::setw(2) << std::setfill('0')
                << static_cast<int>(c);
            result += oss.str();
        }
    };

    // Replace :: with __ for method names
    for (size_t i = 0; i < name.size(); i++) {
        if (i + 1 < name.size() && name[i] == ':' && name[i+1] == ':') {
            result += MANGLED_PREFIX;
            i++; // Skip the second :
        } else {
            append_encoded(static_cast<unsigned char>(name[i]));
        }
    }
    return result;
}

std::string CodeGenerator::fresh_temp() {
    if (!available_temps.empty()) {
        std::string temp = available_temps.top();
        available_temps.pop();
        live_temps.insert(temp);
        return temp;
    }
    std::string temp = "tmp" + std::to_string(temp_counter++);
    live_temps.insert(temp);
    return temp;
}

void CodeGenerator::release_temp(const std::string& temp) {
    if (live_temps.count(temp)) {
        live_temps.erase(temp);
        available_temps.push(temp);
    }
}

void CodeGenerator::emit(const std::string& code) {
    if (output_stack.empty()) {
        output_stack.push(&body);
    }
    (*output_stack.top()) << code << "\n";
}

void CodeGenerator::emit_header(const std::string& code) {
    header << code << "\n";
}

std::string CodeGenerator::storage_prefix() const {
    return current_function_non_reentrant ? "static " : "";
}

void CodeGenerator::emit_return_stmt(const std::string& expr) {
    if (current_returns_aggregate) {
        if (!expr.empty()) {
            emit("*" + aggregate_out_param + " = " + expr + ";");
        }
        if (!abi.return_prefix.empty()) {
            emit(abi.return_prefix);
        }
        emit("return;");
        return;
    }

    if (!abi.return_prefix.empty()) {
        emit(abi.return_prefix);
    }
    if (expr.empty()) {
        emit("return;");
    } else {
        emit("return " + expr + ";");
    }
}

void CodeGenerator::append_return_prefix(std::ostringstream& out) const {
    if (!abi.return_prefix.empty()) {
        out << abi.return_prefix << "\n";
    }
}

int64_t CodeGenerator::resolve_array_length(TypePtr type, const SourceLocation& loc) {
    if (!type || type->kind != Type::Kind::Array || !type->array_size) {
        throw CompileError("Cannot determine array length for comparator generation", loc);
    }
    CTValue size_val;
    if (!try_evaluate(type->array_size, size_val)) {
        throw CompileError("Array length must be compile-time constant", loc);
    }

    if (std::holds_alternative<int64_t>(size_val)) {
        return std::get<int64_t>(size_val);
    }
    if (std::holds_alternative<uint64_t>(size_val)) {
        return static_cast<int64_t>(std::get<uint64_t>(size_val));
    }

    throw CompileError("Array length must be an integer constant", loc);
}

std::string CodeGenerator::ensure_comparator(TypePtr type) {
    if (!type) {
        throw CompileError("Cannot compare value of unknown type", SourceLocation());
    }

    std::string key = type->to_string();
    auto it = comparator_cache.find(key);
    if (it != comparator_cache.end()) {
        return it->second;
    }

    std::string func_name = "vx_cmp_" + sanitize_identifier(key) + "_" + std::to_string(comparator_cache.size());
    comparator_cache[key] = func_name;

    std::ostringstream fn;
    fn << "static int " << func_name << "(" << gen_type(type) << " lhs, " << gen_type(type) << " rhs) {\n";

    switch (type->kind) {
        case Type::Kind::Primitive: {
            if (type->primitive == PrimitiveType::String) {
                fn << "    if (!lhs && !rhs) return 0;\n";
                fn << "    if (!lhs) return -1;\n";
                fn << "    if (!rhs) return 1;\n";
                fn << "    int cmp = strcmp(lhs, rhs);\n";
                fn << "    if (cmp < 0) return -1;\n";
                fn << "    if (cmp > 0) return 1;\n";
                fn << "    return 0;\n";
            } else {
                fn << "    if (lhs < rhs) return -1;\n";
                fn << "    if (lhs > rhs) return 1;\n";
                fn << "    return 0;\n";
            }
            break;
        }
        case Type::Kind::Array: {
            int64_t length = resolve_array_length(type, type->location);
            std::string elem_cmp = ensure_comparator(type->element_type);
            fn << "    for (int i = 0; i < " << length << "; ++i) {\n";
            fn << "        int cmp = " << elem_cmp << "(lhs[i], rhs[i]);\n";
            fn << "        if (cmp != 0) return cmp;\n";
            fn << "    }\n";
            fn << "    return 0;\n";
            break;
        }
        case Type::Kind::Named: {
            if (!type_checker) {
                throw CompileError("Internal error: comparator generation without type checker", type->location);
            }
            Symbol* sym = type_checker->get_scope()->lookup(type->type_name);
            if (!sym || sym->kind != Symbol::Kind::Type || !sym->declaration || sym->declaration->kind != Stmt::Kind::TypeDecl) {
                throw CompileError("Cannot compare values of type " + type->type_name, type->location);
            }
            auto decl = sym->declaration;
            fn << "    int cmp;\n";
            for (const auto& field : decl->fields) {
                if (!field.type) {
                    throw CompileError("Field type inference required before comparison for " + field.name, field.location);
                }
                std::string field_cmp = ensure_comparator(field.type);
                fn << "    cmp = " << field_cmp << "(lhs." << mangle_name(field.name) << ", rhs." << mangle_name(field.name) << ");\n";
                fn << "    if (cmp != 0) return cmp;\n";
            }
            fn << "    return 0;\n";
            break;
        }
        case Type::Kind::TypeVar:
            throw CompileError("Cannot compare generic type without concrete instantiation", type->location);
    }

    fn << "}\n";
    comparator_definitions.push_back(fn.str());
    return func_name;
}

}
