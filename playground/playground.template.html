<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Vexel Playground</title>
  <style>
    :root {
      --bg: #0f1115;
      --bg-2: #151821;
      --panel: #1a1f2b;
      --panel-2: #11151d;
      --ink: #e7edf7;
      --muted: #a9b2c3;
      --accent: #ffb454;
      --accent-2: #4dd0e1;
      --danger: #ff6b6b;
      --tab: #1f2432;
      --tab-active: #273047;
      --outline: #2e364a;
      --shadow: 0 16px 40px rgba(0, 0, 0, 0.45);
      --code-line-height: 1.5;
      --code-font-size: 0.95rem;
      --mobile-code-lines: 20;
    }

    * { box-sizing: border-box; }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--ink);
      font-family: "Space Grotesk", "Avenir Next", "Segoe UI", "Helvetica Neue", Arial, sans-serif;
    }

    body {
      display: flex;
      align-items: stretch;
      justify-content: center;
      background: radial-gradient(1200px 600px at 10% -20%, rgba(77, 208, 225, 0.18), transparent 60%),
                  radial-gradient(900px 500px at 110% 10%, rgba(255, 180, 84, 0.16), transparent 55%),
                  linear-gradient(180deg, #0c0f14 0%, #121722 50%, #0f1115 100%);
    }

    .app {
      width: min(1600px, 96vw);
      height: 96vh;
      display: grid;
      grid-template-rows: auto 1fr 190px;
      gap: 16px;
      padding: 16px;
    }

    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--panel);
      border: 1px solid var(--outline);
      border-radius: 14px;
      padding: 12px 16px;
      box-shadow: var(--shadow);
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo {
      width: 36px;
      height: 36px;
      border-radius: 10px;
      background: conic-gradient(from 140deg, var(--accent), var(--accent-2), #ffffff22, var(--accent));
      display: grid;
      place-items: center;
      color: #0a0c11;
      font-weight: 700;
    }

    .brand h1 {
      font-size: 1.1rem;
      margin: 0;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .btn, select {
      border: 1px solid var(--outline);
      background: var(--tab);
      color: var(--ink);
      padding: 8px 12px;
      border-radius: 10px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: transform 0.15s ease, border 0.15s ease, background 0.15s ease;
    }

    .btn:hover, select:hover {
      transform: translateY(-1px);
      border-color: #3b4760;
      background: var(--tab-active);
    }

    .btn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      transform: none;
    }

    .btn.primary {
      background: linear-gradient(135deg, var(--accent) 0%, #ffd18a 100%);
      color: #201404;
      border-color: transparent;
      font-weight: 600;
    }

    .btn.ghost {
      background: transparent;
    }

    .panes {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      min-height: 0;
    }

    .pane {
      display: flex;
      flex-direction: column;
      background: var(--panel);
      border: 1px solid var(--outline);
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow: hidden;
      min-height: 0;
    }

    .pane-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px;
      border-bottom: 1px solid var(--outline);
      background: var(--panel-2);
    }

    .pane-title {
      font-size: 0.9rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .pane-path {
      flex: 1;
      margin-left: 10px;
      margin-right: 10px;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: #8fa1be;
      font-size: 0.8rem;
      font-family: "IBM Plex Mono", "JetBrains Mono", ui-monospace, monospace;
    }

    .tabs {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 12px;
      border-bottom: 1px solid var(--outline);
      background: var(--tab);
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: thin;
      scroll-snap-type: x proximity;
    }

    .tab {
      border: 1px solid transparent;
      background: transparent;
      color: var(--muted);
      padding: 6px 10px;
      border-radius: 10px;
      font-size: 0.85rem;
      cursor: pointer;
      white-space: nowrap;
      transition: 0.15s ease;
      scroll-snap-align: start;
    }

    .tab.active {
      color: var(--ink);
      background: var(--tab-active);
      border-color: #394258;
    }

    .tab.dir {
      color: #8ed0ff;
      border-color: #35506f;
    }

    .tab.parent {
      color: #ffd18a;
      border: 1px dashed #5c4b2f;
    }

    .tab.add {
      color: var(--accent-2);
      border: 1px dashed #3b4760;
    }

    .editor, .output {
      flex: 1;
      border: none;
      outline: none;
      resize: none;
      background: #0f141c;
      color: #e9efff;
      font-family: "IBM Plex Mono", "JetBrains Mono", "Fira Code", ui-monospace, monospace;
      font-size: var(--code-font-size);
      line-height: var(--code-line-height);
      padding: 16px;
      min-height: 0;
    }

    .output {
      background: #0d1118;
      color: #c7d2e5;
    }

    .debug {
      background: var(--panel);
      border: 1px solid var(--outline);
      border-radius: 16px;
      padding: 12px 16px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 0;
    }

    .debug-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 0.8rem;
    }

    .debug-log {
      flex: 1;
      background: #0b0e13;
      border: 1px solid #222b3d;
      border-radius: 12px;
      padding: 10px;
      font-family: "IBM Plex Mono", "JetBrains Mono", ui-monospace, monospace;
      font-size: 0.85rem;
      color: #aeb9cc;
      overflow: auto;
      white-space: pre-wrap;
    }

    .status {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #3ddc84;
      box-shadow: 0 0 6px rgba(61, 220, 132, 0.5);
    }

    .status-dot.loading {
      background: #ffb454;
      box-shadow: 0 0 6px rgba(255, 180, 84, 0.45);
    }

    .status-dot.error {
      background: #ff6b6b;
      box-shadow: 0 0 6px rgba(255, 107, 107, 0.5);
    }

    @media (max-width: 1100px) {
      .app {
        height: auto;
        min-height: 100vh;
        grid-template-rows: auto auto auto;
      }

      .panes {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 900px) {
      .app {
        width: 100vw;
        min-height: 100vh;
        padding: 10px;
        gap: 10px;
      }

      .topbar {
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
      }

      .controls {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }

      .controls .status {
        grid-column: 1 / -1;
      }

      #compileBtn {
        grid-column: 1 / -1;
      }

      .controls .btn,
      .controls select {
        width: 100%;
      }

      .pane-header {
        padding: 9px 11px;
      }

      .tabs {
        padding: 7px 10px;
      }

      .editor, .output {
        min-height: calc(var(--mobile-code-lines) * var(--code-line-height) * 1em + 32px);
      }

      .debug {
        min-height: 170px;
      }

      .debug-log {
        min-height: 140px;
        max-height: 240px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="topbar">
      <div class="brand">
        <div class="logo">V</div>
        <h1>Vexel Playground</h1>
      </div>
      <div class="controls">
        <button class="btn primary" id="compileBtn" disabled>Compile</button>
        <button class="btn" id="addFileBtn">Add File</button>
        <button class="btn" id="shareBtn">Copy Link</button>
        <select id="backendSelect"></select>
        <span class="status"><span class="status-dot loading" id="statusDot"></span><span id="statusText">Loading</span></span>
      </div>
    </header>

    <section class="panes">
      <div class="pane" id="sourcePane">
        <div class="pane-header">
          <span class="pane-title">Sources</span>
          <span class="pane-path" id="sourcePath"></span>
          <button class="btn ghost" id="addFileBtnInline">New file</button>
        </div>
        <div class="tabs" id="sourceTabs"></div>
        <textarea class="editor" id="sourceEditor" spellcheck="false"></textarea>
      </div>

      <div class="pane" id="outputPane">
        <div class="pane-header">
          <span class="pane-title">Output Files</span>
          <button class="btn ghost" id="copyOutputBtn">Copy</button>
        </div>
        <div class="tabs" id="outputTabs"></div>
        <textarea class="output" id="outputViewer" spellcheck="false" readonly></textarea>
      </div>
    </section>

    <section class="debug">
      <div class="debug-header">
        <span>Build Log</span>
        <button class="btn ghost" id="clearLogBtn">Clear</button>
      </div>
      <div class="debug-log" id="debugLog"></div>
    </section>
  </div>

  <script>
  /*__VEXEL_JS__*/
  </script>
  <script>
    const VEXEL_WASM_BASE64 = "__VEXEL_WASM_BASE64__";
    const BACKENDS = __VEXEL_BACKENDS_JSON__;
    const BUNDLED_EXAMPLES = __VEXEL_EXAMPLES_JSON__;
    const ROOT_DIR = "examples";

    const state = {
      files: [],
      currentDir: ROOT_DIR,
      selectedPath: "",
      outputs: [],
      activeOutput: 0,
      messages: [],
      backend: (Array.isArray(BACKENDS) && BACKENDS.length > 0) ? BACKENDS[0] : "c"
    };

    const sourceTabs = document.getElementById("sourceTabs");
    const outputTabs = document.getElementById("outputTabs");
    const sourceEditor = document.getElementById("sourceEditor");
    const outputViewer = document.getElementById("outputViewer");
    const debugLog = document.getElementById("debugLog");
    const compileBtn = document.getElementById("compileBtn");
    const addFileBtn = document.getElementById("addFileBtn");
    const addFileBtnInline = document.getElementById("addFileBtnInline");
    const clearLogBtn = document.getElementById("clearLogBtn");
    const backendSelect = document.getElementById("backendSelect");
    const copyOutputBtn = document.getElementById("copyOutputBtn");
    const shareBtn = document.getElementById("shareBtn");
    const statusText = document.getElementById("statusText");
    const statusDot = document.getElementById("statusDot");
    const sourcePath = document.getElementById("sourcePath");

    let wasmBinaryCache = null;
    let compilerReady = false;

    function log(message, level = "info") {
      const time = new Date().toLocaleTimeString();
      const prefix = level === "error" ? "[error]" : "[info]";
      state.messages.push(`${time} ${prefix} ${message}`);
      debugLog.textContent = state.messages.join("\n");
      debugLog.scrollTop = debugLog.scrollHeight;
    }

    function setStatus(text, stateName) {
      statusText.textContent = text;
      statusDot.classList.remove("loading", "error");
      if (stateName === "loading") {
        statusDot.classList.add("loading");
      } else if (stateName === "error") {
        statusDot.classList.add("error");
      }
    }

    function sanitizeRelativePath(path) {
      let clean = String(path || "").trim().replace(/\\/g, "/");
      if (!clean) return null;
      clean = clean.replace(/\/+/g, "/");
      clean = clean.replace(/^\/+/, "");
      if (!clean || clean.includes("..")) return null;
      return clean;
    }

    function sanitizeLeafName(name) {
      let clean = String(name || "").trim().replace(/\\/g, "/");
      if (!clean) return null;
      if (clean.includes("/")) return null;
      if (!clean.endsWith(".vx")) clean += ".vx";
      return clean.replace(/\s+/g, "_");
    }

    function parentDir(path) {
      const clean = sanitizeRelativePath(path);
      if (!clean) return ROOT_DIR;
      const idx = clean.lastIndexOf("/");
      if (idx <= 0) return ROOT_DIR;
      return clean.slice(0, idx);
    }

    function isCompilableFile(file) {
      return !!file && file.encoding === "utf8" && file.path.endsWith(".vx");
    }

    function decodeBase64ToBytes(text) {
      const binary = atob(text);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes;
    }

    function ensureDir(FS, path) {
      const parts = path.split("/").filter(Boolean);
      let current = "";
      for (const part of parts) {
        current += `/${part}`;
        if (!FS.analyzePath(current).exists) {
          FS.mkdir(current);
        }
      }
    }

    function findFile(path) {
      const clean = sanitizeRelativePath(path);
      if (!clean) return null;
      return state.files.find((file) => file.path === clean) || null;
    }

    function chooseDefaultFile() {
      if (findFile("examples/simple.vx")) {
        return "examples/simple.vx";
      }
      const vxFile = state.files.find((file) => file.path.endsWith(".vx"));
      if (vxFile) return vxFile.path;
      if (state.files.length > 0) return state.files[0].path;
      return "";
    }

    function listDirEntries(dirPath) {
      const cleanDir = sanitizeRelativePath(dirPath) || ROOT_DIR;
      const prefix = cleanDir ? `${cleanDir}/` : "";
      const dirs = new Set();
      const files = [];

      state.files.forEach((file) => {
        if (!file.path.startsWith(prefix)) return;
        const rest = file.path.slice(prefix.length);
        if (!rest) return;
        const slashIdx = rest.indexOf("/");
        if (slashIdx === -1) {
          files.push({
            kind: "file",
            name: rest,
            path: file.path
          });
        } else {
          const child = rest.slice(0, slashIdx);
          dirs.add(child);
        }
      });

      const dirEntries = Array.from(dirs)
        .sort((a, b) => a.localeCompare(b))
        .map((name) => ({
          kind: "dir",
          name,
          path: `${cleanDir}/${name}`
        }));
      files.sort((a, b) => a.name.localeCompare(b.name));
      return dirEntries.concat(files);
    }

    function updateCompileButtonState() {
      compileBtn.disabled = !compilerReady || !isCompilableFile(findFile(state.selectedPath));
    }

    function renderSourceTabs() {
      sourceTabs.innerHTML = "";
      sourcePath.textContent = state.currentDir;

      if (state.currentDir !== ROOT_DIR) {
        const up = document.createElement("button");
        up.className = "tab parent";
        up.textContent = "..";
        up.title = "Parent folder";
        up.addEventListener("click", () => {
          state.currentDir = parentDir(state.currentDir);
          renderSourceTabs();
          renderEditor();
        });
        sourceTabs.appendChild(up);
      }

      const entries = listDirEntries(state.currentDir);
      entries.forEach((entry) => {
        const button = document.createElement("button");
        const active = entry.kind === "file" && entry.path === state.selectedPath;
        button.className = `tab ${entry.kind === "dir" ? "dir" : "file"}${active ? " active" : ""}`;
        button.textContent = entry.kind === "dir" ? `${entry.name}/` : entry.name;
        button.addEventListener("click", () => {
          if (entry.kind === "dir") {
            state.currentDir = entry.path;
            renderSourceTabs();
            renderEditor();
            return;
          }
          state.selectedPath = entry.path;
          state.currentDir = parentDir(entry.path);
          renderSourceTabs();
          renderEditor();
        });
        sourceTabs.appendChild(button);
      });

      if (entries.length === 0) {
        const empty = document.createElement("span");
        empty.className = "tab";
        empty.textContent = "(empty)";
        sourceTabs.appendChild(empty);
      }
    }

    function renderOutputTabs() {
      outputTabs.innerHTML = "";
      state.outputs.forEach((out, idx) => {
        const button = document.createElement("button");
        button.className = "tab" + (idx === state.activeOutput ? " active" : "");
        button.textContent = out.name;
        button.addEventListener("click", () => {
          state.activeOutput = idx;
          renderOutput();
          renderOutputTabs();
        });
        outputTabs.appendChild(button);
      });
    }

    function renderEditor() {
      const file = findFile(state.selectedPath);
      if (!file) {
        sourceEditor.value = "";
        sourceEditor.readOnly = true;
        updateCompileButtonState();
        return;
      }

      if (file.encoding === "utf8") {
        sourceEditor.readOnly = false;
        sourceEditor.value = file.content;
      } else {
        sourceEditor.readOnly = true;
        sourceEditor.value = `[binary] ${file.path}\n\nThis file is embedded as binary and cannot be edited in the playground.`;
      }
      updateCompileButtonState();
    }

    function renderOutput() {
      const active = state.outputs[state.activeOutput];
      outputViewer.value = active ? active.content : "";
    }

    function clearOutputs() {
      state.outputs = [];
      state.activeOutput = 0;
      renderOutputTabs();
      renderOutput();
    }

    function loadBundledFiles() {
      const files = [];
      (Array.isArray(BUNDLED_EXAMPLES) ? BUNDLED_EXAMPLES : []).forEach((entry) => {
        if (!entry || typeof entry !== "object") return;
        const path = sanitizeRelativePath(entry.path);
        if (!path) return;
        if (entry.encoding === "base64") {
          files.push({ path, encoding: "base64", contentBase64: String(entry.contentBase64 || "") });
          return;
        }
        files.push({ path, encoding: "utf8", content: String(entry.content || "") });
      });
      files.sort((a, b) => a.path.localeCompare(b.path));
      state.files = files;

      const params = new URLSearchParams(window.location.search);
      const requestedFile = sanitizeRelativePath(params.get("file") || "");
      const selected = requestedFile && findFile(requestedFile) ? requestedFile : chooseDefaultFile();
      state.selectedPath = selected;
      state.currentDir = selected ? parentDir(selected) : ROOT_DIR;
    }

    function prepareWorkspace(FS) {
      if (!FS.analyzePath("/project").exists) {
        FS.mkdir("/project");
      }
      FS.chdir("/project");

      state.files.forEach((file) => {
        const rel = sanitizeRelativePath(file.path);
        if (!rel) return;
        const fullPath = `/project/${rel}`;
        const dir = fullPath.substring(0, fullPath.lastIndexOf("/"));
        ensureDir(FS, dir);
        if (file.encoding === "base64") {
          FS.writeFile(fullPath, decodeBase64ToBytes(file.contentBase64));
        } else {
          FS.writeFile(fullPath, file.content);
        }
      });
    }

    function listWorkspaceFiles(FS, root) {
      const files = [];
      const walk = (absDir, relDir) => {
        if (!FS.analyzePath(absDir).exists) return;
        const entries = FS.readdir(absDir).filter((name) => name !== "." && name !== "..");
        entries.forEach((name) => {
          const absPath = `${absDir}/${name}`.replace(/\/+/g, "/");
          const relPath = relDir ? `${relDir}/${name}` : name;
          const stat = FS.stat(absPath);
          if (FS.isDir(stat.mode)) {
            walk(absPath, relPath);
            return;
          }
          files.push({ absPath, relPath });
        });
      };
      walk(root, "");
      files.sort((a, b) => a.relPath.localeCompare(b.relPath));
      return files;
    }

    function readOutputs(FS) {
      const sourceSet = new Set(state.files.map((file) => file.path));
      const results = [];
      const files = listWorkspaceFiles(FS, "/project");
      files.forEach((file) => {
        if (sourceSet.has(file.relPath)) return;
        try {
          results.push({
            name: file.relPath,
            content: FS.readFile(file.absPath, { encoding: "utf8" })
          });
        } catch (_) {
          results.push({
            name: file.relPath,
            content: "[binary output omitted]"
          });
        }
      });
      return results;
    }

    function buildOutputBase(path) {
      const clean = sanitizeRelativePath(path) || "main.vx";
      const stem = clean.replace(/\.vx$/, "").replace(/[^A-Za-z0-9_]/g, "_");
      return `/project/__build/${stem || "out"}`;
    }

    async function compile() {
      const entry = findFile(state.selectedPath);
      if (!isCompilableFile(entry)) {
        log("Select a .vx source file to compile", "error");
        return;
      }
      if (!compilerReady || !wasmBinaryCache) {
        log("Compiler not loaded. Run 'make web' to embed the compiler.", "error");
        return;
      }

      compileBtn.disabled = true;
      setStatus("Compiling", "loading");
      clearOutputs();
      log(`Compiling ${entry.path} (${state.backend})...`);

      let exitCode = 0;
      let module;
      try {
        module = await createVexelModule({
          wasmBinary: wasmBinaryCache,
          noInitialRun: true,
          preRun: [(mod) => prepareWorkspace(mod.FS)],
          print: (text) => {
            if (text && text.trim().length > 0) log(text);
          },
          printErr: (text) => {
            if (text && text.trim().length > 0) log(text, "error");
          }
        });
      } catch (err) {
        log(`Compiler crashed during init: ${err}`, "error");
        setStatus("Ready", "ready");
        updateCompileButtonState();
        return;
      }

      try {
        module.callMain(["-b", state.backend, "-o", buildOutputBase(entry.path), entry.path]);
      } catch (err) {
        if (err && err.name === "ExitStatus") {
          exitCode = err.status;
        } else {
          log(`Compiler crashed: ${err}`, "error");
          setStatus("Ready", "ready");
          updateCompileButtonState();
          return;
        }
      }

      state.outputs = readOutputs(module.FS);
      state.activeOutput = 0;
      renderOutputTabs();
      renderOutput();

      if (exitCode !== 0) {
        log(`Compiler exited with code ${exitCode}`, "error");
      } else if (state.outputs.length === 0) {
        log("Compilation finished, but no outputs were produced", "error");
      } else {
        log(`Compilation finished (${state.outputs.length} file(s))`);
      }

      setStatus("Ready", "ready");
      updateCompileButtonState();
    }

    function addFile() {
      const leaf = sanitizeLeafName(prompt("New file name", "scratch.vx"));
      if (!leaf) return;
      const path = sanitizeRelativePath(`${state.currentDir}/${leaf}`);
      if (!path) return;
      if (findFile(path)) {
        log(`File '${path}' already exists`, "error");
        return;
      }
      state.files.push({ path, encoding: "utf8", content: "// New source file\n" });
      state.files.sort((a, b) => a.path.localeCompare(b.path));
      state.selectedPath = path;
      state.currentDir = parentDir(path);
      renderSourceTabs();
      renderEditor();
      log(`Added ${path}`);
    }

    function populateBackends() {
      const list = (Array.isArray(BACKENDS) && BACKENDS.length > 0) ? BACKENDS : ["c"];
      backendSelect.textContent = "";
      list.forEach((name) => {
        const option = document.createElement("option");
        option.value = name;
        option.textContent = `Backend: ${name}`;
        backendSelect.appendChild(option);
      });

      const params = new URLSearchParams(window.location.search);
      const requestedBackend = (params.get("backend") || "").trim();
      state.backend = list.includes(requestedBackend) ? requestedBackend : list[0];
      backendSelect.value = state.backend;
    }

    function buildShareUrl() {
      const url = new URL(window.location.href);
      if (state.selectedPath) {
        url.searchParams.set("file", state.selectedPath);
      } else {
        url.searchParams.delete("file");
      }
      url.searchParams.set("backend", state.backend);
      return url.toString();
    }

    function decodeWasmBase64() {
      if (!VEXEL_WASM_BASE64 || VEXEL_WASM_BASE64.startsWith("_")) return null;
      const binary = atob(VEXEL_WASM_BASE64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes;
    }

    async function initCompiler() {
      if (typeof createVexelModule !== "function") {
        log("Compiler bundle not found. Run 'make web' to embed the compiler.", "error");
        setStatus("No compiler", "error");
        return;
      }
      setStatus("Loading", "loading");
      try {
        wasmBinaryCache = decodeWasmBase64();
        if (!wasmBinaryCache) {
          log("Embedded wasm missing; run 'make web' to generate a self-contained playground.", "error");
          setStatus("No compiler", "error");
          return;
        }
        compilerReady = true;
        setStatus("Ready", "ready");
        updateCompileButtonState();
        log("Compiler ready");
        if (isCompilableFile(findFile(state.selectedPath))) {
          compile();
        }
      } catch (err) {
        log(`Failed to load compiler: ${err}`, "error");
        setStatus("Error", "error");
      }
    }

    sourceEditor.addEventListener("input", (event) => {
      const file = findFile(state.selectedPath);
      if (file && file.encoding === "utf8") {
        file.content = event.target.value;
      }
    });

    compileBtn.addEventListener("click", compile);
    addFileBtn.addEventListener("click", addFile);
    addFileBtnInline.addEventListener("click", addFile);

    backendSelect.addEventListener("change", (event) => {
      state.backend = event.target.value || state.backend || "c";
    });

    clearLogBtn.addEventListener("click", () => {
      state.messages = [];
      debugLog.textContent = "";
    });

    copyOutputBtn.addEventListener("click", () => {
      const active = state.outputs[state.activeOutput];
      if (!active) return;
      navigator.clipboard.writeText(active.content).then(
        () => log(`Copied ${active.name} to clipboard`),
        () => log("Clipboard copy failed", "error")
      );
    });

    shareBtn.addEventListener("click", () => {
      const url = buildShareUrl();
      navigator.clipboard.writeText(url).then(
        () => log("Copied link to clipboard"),
        () => log("Link copy failed", "error")
      );
    });

    window.addEventListener("DOMContentLoaded", () => {
      loadBundledFiles();
      populateBackends();
      renderSourceTabs();
      renderEditor();
      clearOutputs();
      initCompiler();
    });
  </script>
</body>
</html>
