<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Vexel Playground</title>
  <style>
    :root {
      --bg: #0f1115;
      --bg-2: #151821;
      --panel: #1a1f2b;
      --panel-2: #11151d;
      --ink: #e7edf7;
      --muted: #a9b2c3;
      --accent: #ffb454;
      --accent-2: #4dd0e1;
      --danger: #ff6b6b;
      --tab: #1f2432;
      --tab-active: #273047;
      --outline: #2e364a;
      --shadow: 0 16px 40px rgba(0, 0, 0, 0.45);
      --code-line-height: 1.5;
      --code-font-size: 0.95rem;
      --mobile-code-lines: 20;
    }

    * { box-sizing: border-box; }

    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--ink);
      font-family: "Space Grotesk", "Avenir Next", "Segoe UI", "Helvetica Neue", Arial, sans-serif;
    }

    body {
      display: flex;
      align-items: stretch;
      justify-content: center;
      background: radial-gradient(1200px 600px at 10% -20%, rgba(77, 208, 225, 0.18), transparent 60%),
                  radial-gradient(900px 500px at 110% 10%, rgba(255, 180, 84, 0.16), transparent 55%),
                  linear-gradient(180deg, #0c0f14 0%, #121722 50%, #0f1115 100%);
    }

    .app {
      width: min(1600px, 96vw);
      height: 96vh;
      display: grid;
      grid-template-rows: auto 1fr 190px;
      gap: 16px;
      padding: 16px;
    }

    .topbar {
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--panel);
      border: 1px solid var(--outline);
      border-radius: 14px;
      padding: 12px 16px;
      box-shadow: var(--shadow);
    }

    .brand {
      display: flex;
      align-items: center;
      gap: 12px;
    }

    .logo {
      width: 36px;
      height: 36px;
      border-radius: 10px;
      background: conic-gradient(from 140deg, var(--accent), var(--accent-2), #ffffff22, var(--accent));
      display: grid;
      place-items: center;
      color: #0a0c11;
      font-weight: 700;
    }

    .brand h1 {
      font-size: 1.1rem;
      margin: 0;
      letter-spacing: 0.04em;
      text-transform: uppercase;
    }

    .controls {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
    }

    .btn, select {
      border: 1px solid var(--outline);
      background: var(--tab);
      color: var(--ink);
      padding: 8px 12px;
      border-radius: 10px;
      font-size: 0.9rem;
      cursor: pointer;
      transition: transform 0.15s ease, border 0.15s ease, background 0.15s ease;
    }

    .btn:hover, select:hover {
      transform: translateY(-1px);
      border-color: #3b4760;
      background: var(--tab-active);
    }

    .btn:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      transform: none;
    }

    .btn.primary {
      background: linear-gradient(135deg, var(--accent) 0%, #ffd18a 100%);
      color: #201404;
      border-color: transparent;
      font-weight: 600;
    }

    .btn.ghost {
      background: transparent;
    }

    .panes {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      min-height: 0;
    }

    .pane {
      display: flex;
      flex-direction: column;
      background: var(--panel);
      border: 1px solid var(--outline);
      border-radius: 16px;
      box-shadow: var(--shadow);
      overflow: hidden;
      min-height: 0;
    }

    .pane-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px;
      border-bottom: 1px solid var(--outline);
      background: var(--panel-2);
    }

    .pane-title {
      font-size: 0.9rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .tabs {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 8px 12px;
      border-bottom: 1px solid var(--outline);
      background: var(--tab);
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      scrollbar-width: thin;
      scroll-snap-type: x proximity;
    }

    .tab {
      border: 1px solid transparent;
      background: transparent;
      color: var(--muted);
      padding: 6px 10px;
      border-radius: 10px;
      font-size: 0.85rem;
      cursor: pointer;
      white-space: nowrap;
      transition: 0.15s ease;
      scroll-snap-align: start;
    }

    .tab.active {
      color: var(--ink);
      background: var(--tab-active);
      border-color: #394258;
    }

    .tab.add {
      color: var(--accent-2);
      border: 1px dashed #3b4760;
    }

    .editor, .output {
      flex: 1;
      border: none;
      outline: none;
      resize: none;
      background: #0f141c;
      color: #e9efff;
      font-family: "IBM Plex Mono", "JetBrains Mono", "Fira Code", ui-monospace, monospace;
      font-size: var(--code-font-size);
      line-height: var(--code-line-height);
      padding: 16px;
      min-height: 0;
    }

    .output {
      background: #0d1118;
      color: #c7d2e5;
    }

    .debug {
      background: var(--panel);
      border: 1px solid var(--outline);
      border-radius: 16px;
      padding: 12px 16px;
      box-shadow: var(--shadow);
      display: flex;
      flex-direction: column;
      gap: 8px;
      min-height: 0;
    }

    .debug-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 0.8rem;
    }

    .debug-log {
      flex: 1;
      background: #0b0e13;
      border: 1px solid #222b3d;
      border-radius: 12px;
      padding: 10px;
      font-family: "IBM Plex Mono", "JetBrains Mono", ui-monospace, monospace;
      font-size: 0.85rem;
      color: #aeb9cc;
      overflow: auto;
      white-space: pre-wrap;
    }

    .status {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      font-size: 0.85rem;
      color: var(--muted);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #3ddc84;
      box-shadow: 0 0 6px rgba(61, 220, 132, 0.5);
    }

    .status-dot.loading {
      background: #ffb454;
      box-shadow: 0 0 6px rgba(255, 180, 84, 0.45);
    }

    .status-dot.error {
      background: #ff6b6b;
      box-shadow: 0 0 6px rgba(255, 107, 107, 0.5);
    }

    @media (max-width: 1100px) {
      .app {
        height: auto;
        min-height: 100vh;
        grid-template-rows: auto auto auto;
      }

      .panes {
        grid-template-columns: 1fr;
      }
    }

    @media (max-width: 900px) {
      .app {
        width: 100vw;
        min-height: 100vh;
        padding: 10px;
        gap: 10px;
      }

      .topbar {
        flex-direction: column;
        align-items: stretch;
        gap: 10px;
      }

      .controls {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 8px;
      }

      .controls .status {
        grid-column: 1 / -1;
      }

      #compileBtn {
        grid-column: 1 / -1;
      }

      .controls .btn,
      .controls select {
        width: 100%;
      }

      .pane-header {
        padding: 9px 11px;
      }

      .tabs {
        padding: 7px 10px;
      }

      .editor, .output {
        min-height: calc(var(--mobile-code-lines) * var(--code-line-height) * 1em + 32px);
      }

      .debug {
        min-height: 170px;
      }

      .debug-log {
        min-height: 140px;
        max-height: 240px;
      }
    }
  </style>
</head>
<body>
  <div class="app">
    <header class="topbar">
      <div class="brand">
        <div class="logo">V</div>
        <h1>Vexel Playground</h1>
      </div>
      <div class="controls">
        <button class="btn primary" id="compileBtn" disabled>Compile</button>
        <button class="btn" id="addFileBtn">Add File</button>
        <button class="btn" id="shareBtn">Copy Share URL</button>
        <select id="backendSelect"></select>
        <select id="exampleSelect">
          <option value="">Load example</option>
          <option value="quickadd">Quick Add</option>
          <option value="hello">Hello</option>
          <option value="structs">Structs + Methods</option>
          <option value="iteration">Iteration</option>
          <option value="sieve">Prime Sieve (&lt;1000)</option>
          <option value="banked">Banked Calls + Globals</option>
          <option value="reentrant">Recursive (Reentrant)</option>
          <option value="globals">ROM + RAM Globals</option>
        </select>
        <span class="status"><span class="status-dot loading" id="statusDot"></span><span id="statusText">Loading</span></span>
      </div>
    </header>

    <section class="panes">
      <div class="pane" id="sourcePane">
        <div class="pane-header">
          <span class="pane-title">Sources</span>
          <button class="btn ghost" id="addFileBtnInline">New file</button>
        </div>
        <div class="tabs" id="sourceTabs"></div>
        <textarea class="editor" id="sourceEditor" spellcheck="false"></textarea>
      </div>

      <div class="pane" id="outputPane">
        <div class="pane-header">
          <span class="pane-title">Output Files</span>
          <button class="btn ghost" id="copyOutputBtn">Copy</button>
        </div>
        <div class="tabs" id="outputTabs"></div>
        <textarea class="output" id="outputViewer" spellcheck="false" readonly></textarea>
      </div>
    </section>

    <section class="debug">
      <div class="debug-header">
        <span>Build Log</span>
        <button class="btn ghost" id="clearLogBtn">Clear</button>
      </div>
      <div class="debug-log" id="debugLog"></div>
    </section>
  </div>

  <script>
  /*__VEXEL_JS__*/
  </script>
  <script>
    const VEXEL_WASM_BASE64 = "__VEXEL_WASM_BASE64__";
    const BACKENDS = __VEXEL_BACKENDS_JSON__;
    const state = {
      sources: [
        {
          name: "main.vx",
          content:
            "&!putchar(c:#u8);\n\n&print_newline() {\n  putchar(10);\n}\n\n&^main() -> #i32 {\n  putchar(72);\n  putchar(101);\n  putchar(108);\n  putchar(108);\n  putchar(111);\n  print_newline();\n  0\n}\n"
        }
      ],
      outputs: [],
      activeSource: 0,
      activeOutput: 0,
      messages: [],
      backend: (Array.isArray(BACKENDS) && BACKENDS.length > 0) ? BACKENDS[0] : "c"
    };

    const examples = {
      quickadd: [
        {
          name: "main.vx",
          content:
            "// Vexel example\n&add(a:#i32, b:#i32) -> #i32 { a + b }\n\nres:#i32 = add(40, 2)\n\n&^main() -> #i32 {\n  res\n}\n"
        }
      ],
      hello: [
        {
          name: "main.vx",
          content:
            "&!putchar(c:#u8);\n\n&print_newline() {\n  putchar(10);\n}\n\n&^main() -> #i32 {\n  putchar(72);\n  putchar(101);\n  putchar(108);\n  putchar(108);\n  putchar(111);\n  print_newline();\n  0\n}\n"
        }
      ],
      structs: [
        {
          name: "main.vx",
          content:
            "#Vec2(x:#i32, y:#i32);\n\n&(self)#Vec2::len2() -> #i32 {\n  self.x * self.x + self.y * self.y\n}\n\n&(lhs)#Vec2::+(rhs:#Vec2) -> #Vec2 {\n  Vec2(lhs.x + rhs.x, lhs.y + rhs.y)\n}\n\n&^main() -> #i32 {\n  v = Vec2(3, 4);\n  sum = v + Vec2(1, 2);\n  sum.len2()\n}\n"
        }
      ],
      iteration: [
        {
          name: "main.vx",
          content:
            "arr:#i32[4] = [1, 2, 3, 4];\n\n&^main() -> #i32 {\n  sum:#i32 = 0;\n  arr@{\n    sum = sum + _\n  };\n  sum\n}\n"
        }
      ],
      sieve: [
        {
          name: "main.vx",
          content:
            "&^main() -> #i32 {\n  limit:#i32 = 1000;\n  prime:#b[1000];\n\n  i:#i32 = 0;\n  (i < limit)@{\n    prime[i] = 1;\n    i = i + 1;\n  };\n  prime[0] = 0;\n  prime[1] = 0;\n\n  p:#i32 = 2;\n  (p * p < limit)@{\n    prime[p] ? {\n      k:#i32 = p * p;\n      (k < limit)@{\n        prime[k] = 0;\n        k = k + p;\n      };\n    };\n    p = p + 1;\n  };\n\n  sum:#i32 = 0;\n  n:#i32 = 2;\n  (n < limit)@{\n    prime[n] ? { sum = sum + n; };\n    n = n + 1;\n  };\n\n  sum\n}\n"
        }
      ],
      banked: [
        {
          name: "main.vx",
          content:
            "G1:#i32 = 5;\nG2:#i32 = 7;\nGM:#i32;\n\n&reader() -> #i32 {\n  GM = GM + 1;\n  x:#i32 = G1;\n  x + GM\n}\n\n&callee(n:#i32) -> #i32 {\n  n + GM + G2\n}\n\n&caller1() -> #i32 {\n  reader() + callee(1)\n}\n\n&caller2() -> #i32 {\n  callee(2)\n}\n\n&^entry_add(n:#i32) -> #i32 {\n  callee(n)\n}\n\n&^main() -> #i32 {\n  GM = 0;\n  caller1() + caller2()\n}\n"
        }
      ],
      reentrant: [
        {
          name: "main.vx",
          content:
            "&fib(n:#i32) -> #i32 {\n  n < 2 ? n : fib(n - 1) + fib(n - 2)\n}\n\n&^main() -> #i32 {\n  fib(8)\n}\n"
        }
      ],
      globals: [
        {
          name: "main.vx",
          content:
            "LUT:#i32[6] = [2, 4, 6, 8, 10, 12];\nstate:#i32;\n\n&accumulate() -> #i32 {\n  sum:#i32 = 0;\n  LUT@{ sum = sum + _ };\n  state = state + 1;\n  sum + state\n}\n\n&^main() -> #i32 {\n  state = 10;\n  accumulate()\n}\n"
        }
      ]
    };

    const sourceTabs = document.getElementById("sourceTabs");
    const outputTabs = document.getElementById("outputTabs");
    const sourceEditor = document.getElementById("sourceEditor");
    const outputViewer = document.getElementById("outputViewer");
    const debugLog = document.getElementById("debugLog");
    const compileBtn = document.getElementById("compileBtn");
    const addFileBtn = document.getElementById("addFileBtn");
    const addFileBtnInline = document.getElementById("addFileBtnInline");
    const clearLogBtn = document.getElementById("clearLogBtn");
    const backendSelect = document.getElementById("backendSelect");
    const exampleSelect = document.getElementById("exampleSelect");
    const copyOutputBtn = document.getElementById("copyOutputBtn");
    const shareBtn = document.getElementById("shareBtn");
    const statusText = document.getElementById("statusText");
    const statusDot = document.getElementById("statusDot");

    let wasmBinaryCache = null;
    let compilerReady = false;

    function log(message, level = "info") {
      const time = new Date().toLocaleTimeString();
      const prefix = level === "error" ? "[error]" : "[info]";
      state.messages.push(`${time} ${prefix} ${message}`);
      debugLog.textContent = state.messages.join("\n");
      debugLog.scrollTop = debugLog.scrollHeight;
    }

    function setStatus(text, stateName) {
      statusText.textContent = text;
      statusDot.classList.remove("loading", "error");
      if (stateName === "loading") {
        statusDot.classList.add("loading");
      } else if (stateName === "error") {
        statusDot.classList.add("error");
      }
    }

    function renderSourceTabs() {
      sourceTabs.innerHTML = "";
      state.sources.forEach((src, idx) => {
        const button = document.createElement("button");
        button.className = "tab" + (idx === state.activeSource ? " active" : "");
        button.textContent = src.name;
        button.addEventListener("click", () => {
          state.activeSource = idx;
          renderEditors();
          renderSourceTabs();
        });
        sourceTabs.appendChild(button);
      });
    }

    function renderOutputTabs() {
      outputTabs.innerHTML = "";
      state.outputs.forEach((out, idx) => {
        const button = document.createElement("button");
        button.className = "tab" + (idx === state.activeOutput ? " active" : "");
        button.textContent = out.name;
        button.addEventListener("click", () => {
          state.activeOutput = idx;
          renderOutput();
          renderOutputTabs();
        });
        outputTabs.appendChild(button);
      });
    }

    function renderEditors() {
      const active = state.sources[state.activeSource];
      sourceEditor.value = active ? active.content : "";
    }

    function renderOutput() {
      const active = state.outputs[state.activeOutput];
      outputViewer.value = active ? active.content : "";
    }

    function sanitizeName(name) {
      let clean = name.trim();
      if (!clean) return null;
      if (!clean.endsWith(".vx")) clean += ".vx";
      clean = clean.replace(/\\/g, "/");
      if (clean.startsWith("/") || clean.includes("..") || clean.includes("/")) return null;
      return clean.replace(/\s+/g, "_");
    }

    function addFile() {
      const name = sanitizeName(prompt("New file name", "extra.vx"));
      if (!name) return;
      if (state.sources.some((src) => src.name === name)) {
        log(`File '${name}' already exists`, "error");
        return;
      }
      state.sources.push({ name, content: "// New source file\n" });
      state.activeSource = state.sources.length - 1;
      renderSourceTabs();
      renderEditors();
      log(`Added ${name}`);
    }

    function clearOutputs() {
      state.outputs = [];
      state.activeOutput = 0;
      renderOutputTabs();
      renderOutput();
    }

    function ensureDir(FS, path) {
      const parts = path.split("/").filter(Boolean);
      let current = "";
      for (const part of parts) {
        current += `/${part}`;
        if (!FS.analyzePath(current).exists) {
          FS.mkdir(current);
        }
      }
    }

    function prepareWorkspace(FS) {
      if (!FS.analyzePath("/project").exists) {
        FS.mkdir("/project");
      }
      FS.chdir("/project");
      state.sources.forEach((src) => {
        const clean = sanitizeName(src.name);
        if (!clean) {
          log(`Skipping invalid file name: ${src.name}`, "error");
          return;
        }
        const fullPath = `/project/${clean}`;
        const dir = fullPath.substring(0, fullPath.lastIndexOf("/"));
        ensureDir(FS, dir);
        FS.writeFile(fullPath, src.content);
      });
    }

    function selectEntry() {
      const main = state.sources.find((src) => src.name === "main.vx");
      return main || state.sources[state.activeSource];
    }

    function listWorkspaceFiles(FS, root) {
      const files = [];
      const walk = (absDir, relDir) => {
        if (!FS.analyzePath(absDir).exists) return;
        const entries = FS.readdir(absDir).filter((name) => name !== "." && name !== "..");
        entries.forEach((name) => {
          const absPath = `${absDir}/${name}`.replace(/\/+/g, "/");
          const relPath = relDir ? `${relDir}/${name}` : name;
          const stat = FS.stat(absPath);
          if (FS.isDir(stat.mode)) {
            walk(absPath, relPath);
            return;
          }
          files.push({ absPath, relPath });
        });
      };
      walk(root, "");
      files.sort((a, b) => a.relPath.localeCompare(b.relPath));
      return files;
    }

    function readOutputs(FS, sourceNames) {
      const sourceSet = new Set(
        sourceNames
          .map((name) => sanitizeName(name))
          .filter((name) => !!name)
      );
      const results = [];
      const files = listWorkspaceFiles(FS, "/project");
      files.forEach((file) => {
        if (sourceSet.has(file.relPath)) return;
        results.push({
          name: file.relPath,
          content: FS.readFile(file.absPath, { encoding: "utf8" })
        });
      });
      return results;
    }

    async function compile() {
      if (!compilerReady || !wasmBinaryCache) {
        log("Compiler not loaded. Run 'make web' to embed the compiler.", "error");
        return;
      }
      compileBtn.disabled = true;
      setStatus("Compiling", "loading");
      clearOutputs();

      const entry = selectEntry();
      if (!entry) {
        log("No source files to compile", "error");
        compileBtn.disabled = false;
        setStatus("Ready", "ready");
        return;
      }
      const entryName = sanitizeName(entry.name);
      if (!entryName) {
        log(`Invalid entry file name: ${entry.name}`, "error");
        compileBtn.disabled = false;
        setStatus("Ready", "ready");
        return;
      }
      log(`Compiling ${entryName} (${state.backend})...`);
      let exitCode = 0;
      let module;
      try {
        module = await createVexelModule({
          wasmBinary: wasmBinaryCache,
          noInitialRun: true,
          preRun: [(mod) => prepareWorkspace(mod.FS)],
          print: (text) => {
            if (text && text.trim().length > 0) log(text);
          },
          printErr: (text) => {
            if (text && text.trim().length > 0) log(text, "error");
          }
        });
      } catch (err) {
        log(`Compiler crashed during init: ${err}`, "error");
        compileBtn.disabled = false;
        setStatus("Ready", "ready");
        return;
      }

      try {
        module.callMain(["-b", state.backend, "-o", `/project/__build/${entryName.replace(/\.vx$/, "")}`, entryName]);
      } catch (err) {
        if (err && err.name === "ExitStatus") {
          exitCode = err.status;
        } else {
          log(`Compiler crashed: ${err}`, "error");
          compileBtn.disabled = false;
          setStatus("Ready", "ready");
          return;
        }
      }

      const outputs = readOutputs(module.FS, state.sources.map((src) => src.name));
      state.outputs = outputs;
      state.activeOutput = 0;
      renderOutputTabs();
      renderOutput();

      if (exitCode !== 0) {
        log(`Compiler exited with code ${exitCode}`, "error");
      } else if (state.outputs.length === 0) {
        log("Compilation finished, but no outputs were produced", "error");
      } else {
        log(`Compilation finished (${state.outputs.length} file(s))`);
      }
      compileBtn.disabled = false;
      setStatus("Ready", "ready");
    }

    function loadExample(key) {
      if (!examples[key]) return;
      state.sources = examples[key].map((src) => ({ ...src }));
      state.activeSource = 0;
      clearOutputs();
      renderSourceTabs();
      renderEditors();
      log(`Loaded example: ${key}`);
    }

    function encodeShareState() {
      const payload = {
        backend: state.backend,
        sources: state.sources.map((src) => ({
          name: src.name,
          content: src.content
        }))
      };
      const json = JSON.stringify(payload);
      if (typeof TextEncoder !== "undefined") {
        const bytes = new TextEncoder().encode(json);
        let binary = "";
        bytes.forEach((b) => {
          binary += String.fromCharCode(b);
        });
        return btoa(binary).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
      }
      return btoa(unescape(encodeURIComponent(json))).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
    }

    function decodeShareState(token) {
      try {
        const b64 = token.replace(/-/g, "+").replace(/_/g, "/");
        const padded = b64 + "===".slice((b64.length + 3) % 4);
        const binary = atob(padded);
        if (typeof TextDecoder !== "undefined") {
          const bytes = new Uint8Array(binary.length);
          for (let i = 0; i < binary.length; i++) {
            bytes[i] = binary.charCodeAt(i);
          }
          return JSON.parse(new TextDecoder().decode(bytes));
        }
        return JSON.parse(decodeURIComponent(escape(binary)));
      } catch (_) {
        return null;
      }
    }

    function buildShareUrl() {
      const token = encodeShareState();
      if (!token || token.length > 8000) {
        return null;
      }
      const url = new URL(window.location.href);
      url.searchParams.set("state", token);
      url.hash = "";
      return url.toString();
    }

    function applyShareStateFromUrl() {
      const params = new URLSearchParams(window.location.search);
      const token = params.get("state");
      if (!token) return false;

      const parsed = decodeShareState(token);
      if (!parsed || !Array.isArray(parsed.sources)) return false;

      const restored = [];
      parsed.sources.forEach((src) => {
        if (!src || typeof src !== "object") return;
        const name = sanitizeName(String(src.name || ""));
        if (!name) return;
        restored.push({
          name,
          content: typeof src.content === "string" ? src.content : ""
        });
      });
      if (restored.length === 0) return false;

      state.sources = restored.slice(0, 64);
      state.activeSource = 0;
      if (typeof parsed.backend === "string" && parsed.backend.trim().length > 0) {
        state.backend = parsed.backend.trim();
      }
      clearOutputs();
      return true;
    }

    function decodeWasmBase64() {
      if (!VEXEL_WASM_BASE64 || VEXEL_WASM_BASE64.startsWith("_")) return null;
      const binary = atob(VEXEL_WASM_BASE64);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes;
    }

    async function initCompiler() {
      if (typeof createVexelModule !== "function") {
        log("Compiler bundle not found. Run 'make web' to embed the compiler.", "error");
        setStatus("No compiler", "error");
        return;
      }
      setStatus("Loading", "loading");
      try {
        wasmBinaryCache = decodeWasmBase64();
        if (!wasmBinaryCache) {
          log("Embedded wasm missing; run 'make web' to generate a self-contained playground.", "error");
          setStatus("No compiler", "error");
          return;
        }
        compilerReady = true;
        setStatus("Ready", "ready");
        compileBtn.disabled = false;
        log("Compiler ready");
        compile();
      } catch (err) {
        log(`Failed to load compiler: ${err}`, "error");
        setStatus("Error", "error");
      }
    }

    sourceEditor.addEventListener("input", (event) => {
      const active = state.sources[state.activeSource];
      if (active) {
        active.content = event.target.value;
      }
    });

    compileBtn.addEventListener("click", compile);
    addFileBtn.addEventListener("click", addFile);
    addFileBtnInline.addEventListener("click", addFile);
    function populateBackends() {
      const list = (Array.isArray(BACKENDS) && BACKENDS.length > 0) ? BACKENDS : ["c"];
      backendSelect.textContent = "";
      list.forEach((name) => {
        const option = document.createElement("option");
        option.value = name;
        option.textContent = `Backend: ${name}`;
        backendSelect.appendChild(option);
      });
      state.backend = list[0] || "c";
      backendSelect.value = state.backend;
    }

    backendSelect.addEventListener("change", (event) => {
      state.backend = event.target.value || state.backend || "c";
    });
    clearLogBtn.addEventListener("click", () => {
      state.messages = [];
      debugLog.textContent = "";
    });

    exampleSelect.addEventListener("change", (event) => {
      const key = event.target.value;
      if (key) {
        loadExample(key);
        event.target.value = "";
      }
    });

    copyOutputBtn.addEventListener("click", () => {
      const active = state.outputs[state.activeOutput];
      if (!active) return;
      navigator.clipboard.writeText(active.content).then(
        () => log(`Copied ${active.name} to clipboard`),
        () => log("Clipboard copy failed", "error")
      );
    });

    shareBtn.addEventListener("click", () => {
      const url = buildShareUrl();
      if (!url) {
        log("Source set is too large to encode into a share URL", "error");
        return;
      }
      navigator.clipboard.writeText(url).then(
        () => log("Copied share URL to clipboard"),
        () => log("Share URL copy failed", "error")
      );
    });

    renderSourceTabs();
    renderEditors();
    clearOutputs();
    window.addEventListener("DOMContentLoaded", () => {
      populateBackends();
      if (applyShareStateFromUrl()) {
        const available = Array.from(backendSelect.options).map((opt) => opt.value);
        if (!available.includes(state.backend)) {
          state.backend = available[0] || "c";
        }
        backendSelect.value = state.backend;
        renderSourceTabs();
        renderEditors();
        clearOutputs();
        log("Loaded shared state from URL");
      }
      initCompiler();
    });
  </script>
</body>
</html>
